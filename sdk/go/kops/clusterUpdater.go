// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package kops

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## # ClusterUpdater
//
// This resource applies the cluster state on the target cloud provider and performs a rolling update.
//
// The rolling update and cluster validation can be disabled and/or configured through resource attributes.
//
// > This resource will trigger based on the `keepers` map attribute.
// Thats is, if something changes in the attribute, the resource update handler will fire and an apply/rolling update/validate cycle will run.
// A good candidate for `keepers` is to use the `revision` coming from `Cluster` and `InstanceGroup` resources.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-kops/sdk/go/kops"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cluster, err := kops.NewCluster(ctx, "cluster", nil)
//			if err != nil {
//				return err
//			}
//			_, err = kops.NewInstanceGroup(ctx, "master-0", &kops.InstanceGroupArgs{
//				ClusterName: cluster.Name,
//				Role:        pulumi.String("Master"),
//				MinSize:     pulumi.Int(1),
//				MaxSize:     pulumi.Int(1),
//				MachineType: pulumi.String("t3.medium"),
//				Subnets: pulumi.StringArray{
//					pulumi.String("private-0"),
//				},
//			}, pulumi.DependsOn([]pulumi.Resource{
//				cluster,
//			}))
//			if err != nil {
//				return err
//			}
//			_, err = kops.NewInstanceGroup(ctx, "master-1", &kops.InstanceGroupArgs{
//				ClusterName: cluster.Name,
//				Role:        pulumi.String("Master"),
//				MinSize:     pulumi.Int(1),
//				MaxSize:     pulumi.Int(1),
//				MachineType: pulumi.String("t3.medium"),
//				Subnets: pulumi.StringArray{
//					pulumi.String("private-1"),
//				},
//			}, pulumi.DependsOn([]pulumi.Resource{
//				cluster,
//			}))
//			if err != nil {
//				return err
//			}
//			_, err = kops.NewInstanceGroup(ctx, "master-2", &kops.InstanceGroupArgs{
//				ClusterName: cluster.Name,
//				Role:        pulumi.String("Master"),
//				MinSize:     pulumi.Int(1),
//				MaxSize:     pulumi.Int(1),
//				MachineType: pulumi.String("t3.medium"),
//				Subnets: pulumi.StringArray{
//					pulumi.String("private-2"),
//				},
//			}, pulumi.DependsOn([]pulumi.Resource{
//				cluster,
//			}))
//			if err != nil {
//				return err
//			}
//			_, err = kops.NewClusterUpdater(ctx, "updater", &kops.ClusterUpdaterArgs{
//				ClusterName: cluster.Name,
//				Keepers: pulumi.StringMap{
//					"cluster":  cluster.Revision,
//					"master-0": master_0.Revision,
//					"master-1": master_1.Revision,
//					"master-2": master_2.Revision,
//				},
//				RollingUpdate: &ClusterUpdaterRollingUpdateArgs{
//					Skip:             pulumi.Bool(false),
//					FailOnDrainError: pulumi.Bool(true),
//					FailOnValidate:   pulumi.Bool(true),
//					ValidateCount:    pulumi.Int(1),
//				},
//				Validate: &ClusterUpdaterValidateArgs{
//					Skip: pulumi.Bool(false),
//				},
//			}, pulumi.DependsOn([]pulumi.Resource{
//				cluster,
//				master_0,
//				master_1,
//				master_2,
//			}))
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ## Nested resources
//
// ### applyOptions
//
// #### Argument Reference
//
// The following arguments are supported:
//
// - `skip` - (Optional) - Bool - Skip allows skipping cluster apply.
// - `allowKopsDowngrade` - (Optional) - Bool - AllowKopsDowngrade permits applying with a kops version older than what was last used to apply to the cluster.
// - `lifecycleOverrides` - (Optional) - Map(String) - LifecycleOverrides is passed in to override the lifecycle for one of more tasks.<br />The key value is the task name such as InternetGateway and the value is the fi.Lifecycle<br />that is re-mapped.
//
// ### rollingUpdateOptions
//
// #### Argument Reference
//
// The following arguments are supported:
//
// - `skip` - (Optional) - Bool - Skip allows skipping cluster rolling update.
// - `masterInterval` - (Optional) - Duration - MasterInterval is the amount of time to wait after stopping a master instance.
// - `nodeInterval` - (Optional) - Duration - NodeInterval is the amount of time to wait after stopping a non-master instance.
// - `bastionInterval` - (Optional) - Duration - BastionInterval is the amount of time to wait after stopping a bastion instance.
// - `failOnDrainError` - (Optional) - Bool - FailOnDrainError will fail when a drain error occurs.
// - `failOnValidate` - (Optional) - Bool - FailOnValidate will fail when a validation error occurs.
// - `postDrainDelay` - (Optional) - Duration - PostDrainDelay is the duration we wait after draining each node.
// - `validationTimeout` - (Optional) - Duration - ValidationTimeout is the maximum time to wait for the cluster to validate, once we start validation.
// - `validateCount` - (Optional) - Int - ValidateCount is the amount of time that a cluster needs to be validated after single node update.
// - `cloudOnly` - (Optional) - Bool - CloudOnly perform rolling update without confirming progress with k8s.
// - `force` - (Optional) - Bool - Force forces a rolling update.
//
// ### validateOptions
//
// #### Argument Reference
//
// The following arguments are supported:
//
// - `skip` - (Optional) - Bool - Skip allows skipping cluster validation.
// - `timeout` - (Optional) - Duration - Timeout defines the maximum time to wait until the cluster becomes valid.
// - `pollInterval` - (Optional) - Duration - PollInterval defines the interval between validation attempts.
type ClusterUpdater struct {
	pulumi.CustomResourceState

	// - applyOptions - Apply holds cluster apply options.
	Apply ClusterUpdaterApplyPtrOutput `pulumi:"apply"`
	// - String - ClusterName is the target cluster name.
	ClusterName pulumi.StringOutput `pulumi:"clusterName"`
	// - Map(String) - Keepers contains arbitrary strings used to update the resource when one changes.
	Keepers pulumi.StringMapOutput `pulumi:"keepers"`
	// - String - ProviderVersion is set to the currently running provider version, this will trigger cluster updater on version changes.
	ProviderVersion pulumi.StringOutput `pulumi:"providerVersion"`
	// - Int - Revision is incremented every time the resource changes, this is useful for triggering cluster updater.
	Revision pulumi.IntOutput `pulumi:"revision"`
	// - rollingUpdateOptions - RollingUpdate holds cluster rolling update options.
	RollingUpdate ClusterUpdaterRollingUpdatePtrOutput `pulumi:"rollingUpdate"`
	// - validateOptions - Validate holds cluster validation options.
	Validate ClusterUpdaterValidatePtrOutput `pulumi:"validate"`
}

// NewClusterUpdater registers a new resource with the given unique name, arguments, and options.
func NewClusterUpdater(ctx *pulumi.Context,
	name string, args *ClusterUpdaterArgs, opts ...pulumi.ResourceOption) (*ClusterUpdater, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterName == nil {
		return nil, errors.New("invalid value for required argument 'ClusterName'")
	}
	var resource ClusterUpdater
	err := ctx.RegisterResource("kops:index/clusterUpdater:ClusterUpdater", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetClusterUpdater gets an existing ClusterUpdater resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetClusterUpdater(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ClusterUpdaterState, opts ...pulumi.ResourceOption) (*ClusterUpdater, error) {
	var resource ClusterUpdater
	err := ctx.ReadResource("kops:index/clusterUpdater:ClusterUpdater", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ClusterUpdater resources.
type clusterUpdaterState struct {
	// - applyOptions - Apply holds cluster apply options.
	Apply *ClusterUpdaterApply `pulumi:"apply"`
	// - String - ClusterName is the target cluster name.
	ClusterName *string `pulumi:"clusterName"`
	// - Map(String) - Keepers contains arbitrary strings used to update the resource when one changes.
	Keepers map[string]string `pulumi:"keepers"`
	// - String - ProviderVersion is set to the currently running provider version, this will trigger cluster updater on version changes.
	ProviderVersion *string `pulumi:"providerVersion"`
	// - Int - Revision is incremented every time the resource changes, this is useful for triggering cluster updater.
	Revision *int `pulumi:"revision"`
	// - rollingUpdateOptions - RollingUpdate holds cluster rolling update options.
	RollingUpdate *ClusterUpdaterRollingUpdate `pulumi:"rollingUpdate"`
	// - validateOptions - Validate holds cluster validation options.
	Validate *ClusterUpdaterValidate `pulumi:"validate"`
}

type ClusterUpdaterState struct {
	// - applyOptions - Apply holds cluster apply options.
	Apply ClusterUpdaterApplyPtrInput
	// - String - ClusterName is the target cluster name.
	ClusterName pulumi.StringPtrInput
	// - Map(String) - Keepers contains arbitrary strings used to update the resource when one changes.
	Keepers pulumi.StringMapInput
	// - String - ProviderVersion is set to the currently running provider version, this will trigger cluster updater on version changes.
	ProviderVersion pulumi.StringPtrInput
	// - Int - Revision is incremented every time the resource changes, this is useful for triggering cluster updater.
	Revision pulumi.IntPtrInput
	// - rollingUpdateOptions - RollingUpdate holds cluster rolling update options.
	RollingUpdate ClusterUpdaterRollingUpdatePtrInput
	// - validateOptions - Validate holds cluster validation options.
	Validate ClusterUpdaterValidatePtrInput
}

func (ClusterUpdaterState) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterUpdaterState)(nil)).Elem()
}

type clusterUpdaterArgs struct {
	// - applyOptions - Apply holds cluster apply options.
	Apply *ClusterUpdaterApply `pulumi:"apply"`
	// - String - ClusterName is the target cluster name.
	ClusterName string `pulumi:"clusterName"`
	// - Map(String) - Keepers contains arbitrary strings used to update the resource when one changes.
	Keepers map[string]string `pulumi:"keepers"`
	// - rollingUpdateOptions - RollingUpdate holds cluster rolling update options.
	RollingUpdate *ClusterUpdaterRollingUpdate `pulumi:"rollingUpdate"`
	// - validateOptions - Validate holds cluster validation options.
	Validate *ClusterUpdaterValidate `pulumi:"validate"`
}

// The set of arguments for constructing a ClusterUpdater resource.
type ClusterUpdaterArgs struct {
	// - applyOptions - Apply holds cluster apply options.
	Apply ClusterUpdaterApplyPtrInput
	// - String - ClusterName is the target cluster name.
	ClusterName pulumi.StringInput
	// - Map(String) - Keepers contains arbitrary strings used to update the resource when one changes.
	Keepers pulumi.StringMapInput
	// - rollingUpdateOptions - RollingUpdate holds cluster rolling update options.
	RollingUpdate ClusterUpdaterRollingUpdatePtrInput
	// - validateOptions - Validate holds cluster validation options.
	Validate ClusterUpdaterValidatePtrInput
}

func (ClusterUpdaterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterUpdaterArgs)(nil)).Elem()
}

type ClusterUpdaterInput interface {
	pulumi.Input

	ToClusterUpdaterOutput() ClusterUpdaterOutput
	ToClusterUpdaterOutputWithContext(ctx context.Context) ClusterUpdaterOutput
}

func (*ClusterUpdater) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterUpdater)(nil)).Elem()
}

func (i *ClusterUpdater) ToClusterUpdaterOutput() ClusterUpdaterOutput {
	return i.ToClusterUpdaterOutputWithContext(context.Background())
}

func (i *ClusterUpdater) ToClusterUpdaterOutputWithContext(ctx context.Context) ClusterUpdaterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterUpdaterOutput)
}

// ClusterUpdaterArrayInput is an input type that accepts ClusterUpdaterArray and ClusterUpdaterArrayOutput values.
// You can construct a concrete instance of `ClusterUpdaterArrayInput` via:
//
//	ClusterUpdaterArray{ ClusterUpdaterArgs{...} }
type ClusterUpdaterArrayInput interface {
	pulumi.Input

	ToClusterUpdaterArrayOutput() ClusterUpdaterArrayOutput
	ToClusterUpdaterArrayOutputWithContext(context.Context) ClusterUpdaterArrayOutput
}

type ClusterUpdaterArray []ClusterUpdaterInput

func (ClusterUpdaterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ClusterUpdater)(nil)).Elem()
}

func (i ClusterUpdaterArray) ToClusterUpdaterArrayOutput() ClusterUpdaterArrayOutput {
	return i.ToClusterUpdaterArrayOutputWithContext(context.Background())
}

func (i ClusterUpdaterArray) ToClusterUpdaterArrayOutputWithContext(ctx context.Context) ClusterUpdaterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterUpdaterArrayOutput)
}

// ClusterUpdaterMapInput is an input type that accepts ClusterUpdaterMap and ClusterUpdaterMapOutput values.
// You can construct a concrete instance of `ClusterUpdaterMapInput` via:
//
//	ClusterUpdaterMap{ "key": ClusterUpdaterArgs{...} }
type ClusterUpdaterMapInput interface {
	pulumi.Input

	ToClusterUpdaterMapOutput() ClusterUpdaterMapOutput
	ToClusterUpdaterMapOutputWithContext(context.Context) ClusterUpdaterMapOutput
}

type ClusterUpdaterMap map[string]ClusterUpdaterInput

func (ClusterUpdaterMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ClusterUpdater)(nil)).Elem()
}

func (i ClusterUpdaterMap) ToClusterUpdaterMapOutput() ClusterUpdaterMapOutput {
	return i.ToClusterUpdaterMapOutputWithContext(context.Background())
}

func (i ClusterUpdaterMap) ToClusterUpdaterMapOutputWithContext(ctx context.Context) ClusterUpdaterMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterUpdaterMapOutput)
}

type ClusterUpdaterOutput struct{ *pulumi.OutputState }

func (ClusterUpdaterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterUpdater)(nil)).Elem()
}

func (o ClusterUpdaterOutput) ToClusterUpdaterOutput() ClusterUpdaterOutput {
	return o
}

func (o ClusterUpdaterOutput) ToClusterUpdaterOutputWithContext(ctx context.Context) ClusterUpdaterOutput {
	return o
}

// - applyOptions - Apply holds cluster apply options.
func (o ClusterUpdaterOutput) Apply() ClusterUpdaterApplyPtrOutput {
	return o.ApplyT(func(v *ClusterUpdater) ClusterUpdaterApplyPtrOutput { return v.Apply }).(ClusterUpdaterApplyPtrOutput)
}

// - String - ClusterName is the target cluster name.
func (o ClusterUpdaterOutput) ClusterName() pulumi.StringOutput {
	return o.ApplyT(func(v *ClusterUpdater) pulumi.StringOutput { return v.ClusterName }).(pulumi.StringOutput)
}

// - Map(String) - Keepers contains arbitrary strings used to update the resource when one changes.
func (o ClusterUpdaterOutput) Keepers() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ClusterUpdater) pulumi.StringMapOutput { return v.Keepers }).(pulumi.StringMapOutput)
}

// - String - ProviderVersion is set to the currently running provider version, this will trigger cluster updater on version changes.
func (o ClusterUpdaterOutput) ProviderVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *ClusterUpdater) pulumi.StringOutput { return v.ProviderVersion }).(pulumi.StringOutput)
}

// - Int - Revision is incremented every time the resource changes, this is useful for triggering cluster updater.
func (o ClusterUpdaterOutput) Revision() pulumi.IntOutput {
	return o.ApplyT(func(v *ClusterUpdater) pulumi.IntOutput { return v.Revision }).(pulumi.IntOutput)
}

// - rollingUpdateOptions - RollingUpdate holds cluster rolling update options.
func (o ClusterUpdaterOutput) RollingUpdate() ClusterUpdaterRollingUpdatePtrOutput {
	return o.ApplyT(func(v *ClusterUpdater) ClusterUpdaterRollingUpdatePtrOutput { return v.RollingUpdate }).(ClusterUpdaterRollingUpdatePtrOutput)
}

// - validateOptions - Validate holds cluster validation options.
func (o ClusterUpdaterOutput) Validate() ClusterUpdaterValidatePtrOutput {
	return o.ApplyT(func(v *ClusterUpdater) ClusterUpdaterValidatePtrOutput { return v.Validate }).(ClusterUpdaterValidatePtrOutput)
}

type ClusterUpdaterArrayOutput struct{ *pulumi.OutputState }

func (ClusterUpdaterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ClusterUpdater)(nil)).Elem()
}

func (o ClusterUpdaterArrayOutput) ToClusterUpdaterArrayOutput() ClusterUpdaterArrayOutput {
	return o
}

func (o ClusterUpdaterArrayOutput) ToClusterUpdaterArrayOutputWithContext(ctx context.Context) ClusterUpdaterArrayOutput {
	return o
}

func (o ClusterUpdaterArrayOutput) Index(i pulumi.IntInput) ClusterUpdaterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ClusterUpdater {
		return vs[0].([]*ClusterUpdater)[vs[1].(int)]
	}).(ClusterUpdaterOutput)
}

type ClusterUpdaterMapOutput struct{ *pulumi.OutputState }

func (ClusterUpdaterMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ClusterUpdater)(nil)).Elem()
}

func (o ClusterUpdaterMapOutput) ToClusterUpdaterMapOutput() ClusterUpdaterMapOutput {
	return o
}

func (o ClusterUpdaterMapOutput) ToClusterUpdaterMapOutputWithContext(ctx context.Context) ClusterUpdaterMapOutput {
	return o
}

func (o ClusterUpdaterMapOutput) MapIndex(k pulumi.StringInput) ClusterUpdaterOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ClusterUpdater {
		return vs[0].(map[string]*ClusterUpdater)[vs[1].(string)]
	}).(ClusterUpdaterOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterUpdaterInput)(nil)).Elem(), &ClusterUpdater{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterUpdaterArrayInput)(nil)).Elem(), ClusterUpdaterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterUpdaterMapInput)(nil)).Elem(), ClusterUpdaterMap{})
	pulumi.RegisterOutputType(ClusterUpdaterOutput{})
	pulumi.RegisterOutputType(ClusterUpdaterArrayOutput{})
	pulumi.RegisterOutputType(ClusterUpdaterMapOutput{})
}
