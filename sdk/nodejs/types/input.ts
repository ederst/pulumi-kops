// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface ClusterAddon {
    manifest: pulumi.Input<string>;
}

export interface ClusterApi {
    dns?: pulumi.Input<inputs.ClusterApiDns>;
    loadBalancer?: pulumi.Input<inputs.ClusterApiLoadBalancer>;
}

export interface ClusterApiDns {
}

export interface ClusterApiLoadBalancer {
    accessLog?: pulumi.Input<inputs.ClusterApiLoadBalancerAccessLog>;
    additionalSecurityGroups?: pulumi.Input<pulumi.Input<string>[]>;
    class?: pulumi.Input<string>;
    crossZoneLoadBalancing?: pulumi.Input<boolean>;
    idleTimeoutSeconds?: pulumi.Input<number>;
    securityGroupOverride?: pulumi.Input<string>;
    sslCertificate?: pulumi.Input<string>;
    sslPolicy?: pulumi.Input<string>;
    subnets?: pulumi.Input<pulumi.Input<inputs.ClusterApiLoadBalancerSubnet>[]>;
    type: pulumi.Input<string>;
    useForInternalApi?: pulumi.Input<boolean>;
}

export interface ClusterApiLoadBalancerAccessLog {
    bucket?: pulumi.Input<string>;
    bucketPrefix?: pulumi.Input<string>;
    interval?: pulumi.Input<number>;
}

export interface ClusterApiLoadBalancerSubnet {
    allocationId?: pulumi.Input<string>;
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name?: pulumi.Input<string>;
    privateIpv4Address?: pulumi.Input<string>;
}

export interface ClusterAssets {
    containerProxy?: pulumi.Input<string>;
    containerRegistry?: pulumi.Input<string>;
    fileRepository?: pulumi.Input<string>;
}

export interface ClusterAuthentication {
    aws?: pulumi.Input<inputs.ClusterAuthenticationAws>;
    kopeio?: pulumi.Input<inputs.ClusterAuthenticationKopeio>;
}

export interface ClusterAuthenticationAws {
    backendMode?: pulumi.Input<string>;
    clusterId?: pulumi.Input<string>;
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    identityMappings?: pulumi.Input<pulumi.Input<inputs.ClusterAuthenticationAwsIdentityMapping>[]>;
    image?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface ClusterAuthenticationAwsIdentityMapping {
    arn?: pulumi.Input<string>;
    groups?: pulumi.Input<pulumi.Input<string>[]>;
    username?: pulumi.Input<string>;
}

export interface ClusterAuthenticationKopeio {
}

export interface ClusterAuthorization {
    alwaysAllow?: pulumi.Input<inputs.ClusterAuthorizationAlwaysAllow>;
    rbac?: pulumi.Input<inputs.ClusterAuthorizationRbac>;
}

export interface ClusterAuthorizationAlwaysAllow {
}

export interface ClusterAuthorizationRbac {
}

export interface ClusterAwsLoadBalancerController {
    enableShield?: pulumi.Input<boolean>;
    enableWaFv2?: pulumi.Input<boolean>;
    enableWaf?: pulumi.Input<boolean>;
    enabled?: pulumi.Input<boolean>;
    version?: pulumi.Input<string>;
}

export interface ClusterCertManager {
    defaultIssuer?: pulumi.Input<string>;
    enabled: pulumi.Input<boolean>;
    hostedZoneIds?: pulumi.Input<pulumi.Input<string>[]>;
    image?: pulumi.Input<string>;
    managed: pulumi.Input<boolean>;
    nameservers?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterCloudConfig {
    awsEbsCsiDriver?: pulumi.Input<inputs.ClusterCloudConfigAwsEbsCsiDriver>;
    disableSecurityGroupIngress?: pulumi.Input<boolean>;
    elbSecurityGroup?: pulumi.Input<string>;
    gceServiceAccount?: pulumi.Input<string>;
    gcpPdCsiDriver?: pulumi.Input<inputs.ClusterCloudConfigGcpPdCsiDriver>;
    manageStorageClasses?: pulumi.Input<boolean>;
    multizone?: pulumi.Input<boolean>;
    nodeInstancePrefix?: pulumi.Input<string>;
    nodeIpFamilies?: pulumi.Input<pulumi.Input<string>[]>;
    nodeTags?: pulumi.Input<string>;
    spotinstOrientation?: pulumi.Input<string>;
    spotinstProduct?: pulumi.Input<string>;
}

export interface ClusterCloudConfigAwsEbsCsiDriver {
    enabled?: pulumi.Input<boolean>;
    managed?: pulumi.Input<boolean>;
    podAnnotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    version?: pulumi.Input<string>;
    volumeAttachLimit?: pulumi.Input<number>;
}

export interface ClusterCloudConfigGcpPdCsiDriver {
    enabled?: pulumi.Input<boolean>;
}

export interface ClusterCloudProvider {
    aws?: pulumi.Input<inputs.ClusterCloudProviderAws>;
    azure?: pulumi.Input<inputs.ClusterCloudProviderAzure>;
    do?: pulumi.Input<inputs.ClusterCloudProviderDo>;
    gce?: pulumi.Input<inputs.ClusterCloudProviderGce>;
    hetzner?: pulumi.Input<inputs.ClusterCloudProviderHetzner>;
    openstack?: pulumi.Input<inputs.ClusterCloudProviderOpenstack>;
}

export interface ClusterCloudProviderAws {
}

export interface ClusterCloudProviderAzure {
    adminUser?: pulumi.Input<string>;
    resourceGroupName?: pulumi.Input<string>;
    routeTableName?: pulumi.Input<string>;
    subscriptionId?: pulumi.Input<string>;
    tenantId?: pulumi.Input<string>;
}

export interface ClusterCloudProviderDo {
}

export interface ClusterCloudProviderGce {
}

export interface ClusterCloudProviderHetzner {
}

export interface ClusterCloudProviderOpenstack {
    blockStorage?: pulumi.Input<inputs.ClusterCloudProviderOpenstackBlockStorage>;
    insecureSkipVerify?: pulumi.Input<boolean>;
    loadbalancer?: pulumi.Input<inputs.ClusterCloudProviderOpenstackLoadbalancer>;
    metadata?: pulumi.Input<inputs.ClusterCloudProviderOpenstackMetadata>;
    monitor?: pulumi.Input<inputs.ClusterCloudProviderOpenstackMonitor>;
    network?: pulumi.Input<inputs.ClusterCloudProviderOpenstackNetwork>;
    router?: pulumi.Input<inputs.ClusterCloudProviderOpenstackRouter>;
}

export interface ClusterCloudProviderOpenstackBlockStorage {
    createStorageClass?: pulumi.Input<boolean>;
    csiPluginImage?: pulumi.Input<string>;
    csiTopologySupport?: pulumi.Input<boolean>;
    ignoreAz?: pulumi.Input<boolean>;
    overrideAz?: pulumi.Input<string>;
    version?: pulumi.Input<string>;
}

export interface ClusterCloudProviderOpenstackLoadbalancer {
    enableIngressHostname?: pulumi.Input<boolean>;
    floatingNetwork?: pulumi.Input<string>;
    floatingNetworkId?: pulumi.Input<string>;
    floatingSubnet?: pulumi.Input<string>;
    ingressHostnameSuffix?: pulumi.Input<string>;
    manageSecGroups?: pulumi.Input<boolean>;
    method?: pulumi.Input<string>;
    provider?: pulumi.Input<string>;
    subnetId?: pulumi.Input<string>;
    useOctavia?: pulumi.Input<boolean>;
}

export interface ClusterCloudProviderOpenstackMetadata {
    configDrive?: pulumi.Input<boolean>;
}

export interface ClusterCloudProviderOpenstackMonitor {
    delay?: pulumi.Input<string>;
    maxRetries?: pulumi.Input<number>;
    timeout?: pulumi.Input<string>;
}

export interface ClusterCloudProviderOpenstackNetwork {
    availabilityZoneHints?: pulumi.Input<pulumi.Input<string>[]>;
    internalNetworkNames?: pulumi.Input<pulumi.Input<string>[]>;
    ipv6SupportDisabled?: pulumi.Input<boolean>;
    publicNetworkNames?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterCloudProviderOpenstackRouter {
    availabilityZoneHints?: pulumi.Input<pulumi.Input<string>[]>;
    dnsServers?: pulumi.Input<string>;
    externalNetwork?: pulumi.Input<string>;
    externalSubnet?: pulumi.Input<string>;
}

export interface ClusterClusterAutoscaler {
    awsUseStaticInstanceList?: pulumi.Input<boolean>;
    balanceSimilarNodeGroups?: pulumi.Input<boolean>;
    cordonNodeBeforeTerminating?: pulumi.Input<boolean>;
    cpuRequest?: pulumi.Input<string>;
    enabled?: pulumi.Input<boolean>;
    expander?: pulumi.Input<string>;
    image?: pulumi.Input<string>;
    maxNodeProvisionTime?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
    newPodScaleUpDelay?: pulumi.Input<string>;
    podAnnotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    scaleDownDelayAfterAdd?: pulumi.Input<string>;
    scaleDownUnneededTime?: pulumi.Input<string>;
    scaleDownUnreadyTime?: pulumi.Input<string>;
    scaleDownUtilizationThreshold?: pulumi.Input<string>;
    skipNodesWithLocalStorage: pulumi.Input<boolean>;
    skipNodesWithSystemPods: pulumi.Input<boolean>;
}

export interface ClusterContainerd {
    address?: pulumi.Input<string>;
    configOverride?: pulumi.Input<string>;
    logLevel?: pulumi.Input<string>;
    nvidiaGpu?: pulumi.Input<inputs.ClusterContainerdNvidiaGpu>;
    packages?: pulumi.Input<inputs.ClusterContainerdPackages>;
    registryMirrors?: pulumi.Input<pulumi.Input<inputs.ClusterContainerdRegistryMirror>[]>;
    root?: pulumi.Input<string>;
    runc?: pulumi.Input<inputs.ClusterContainerdRunc>;
    skipInstall?: pulumi.Input<boolean>;
    state?: pulumi.Input<string>;
    version?: pulumi.Input<string>;
}

export interface ClusterContainerdNvidiaGpu {
    driverPackage?: pulumi.Input<string>;
    enabled?: pulumi.Input<boolean>;
}

export interface ClusterContainerdPackages {
    hashAmd64?: pulumi.Input<string>;
    hashArm64?: pulumi.Input<string>;
    urlAmd64?: pulumi.Input<string>;
    urlArm64?: pulumi.Input<string>;
}

export interface ClusterContainerdRegistryMirror {
    key: pulumi.Input<string>;
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterContainerdRunc {
    packages?: pulumi.Input<inputs.ClusterContainerdRuncPackages>;
    version?: pulumi.Input<string>;
}

export interface ClusterContainerdRuncPackages {
    hashAmd64?: pulumi.Input<string>;
    hashArm64?: pulumi.Input<string>;
    urlAmd64?: pulumi.Input<string>;
    urlArm64?: pulumi.Input<string>;
}

export interface ClusterDocker {
    authorizationPlugins?: pulumi.Input<pulumi.Input<string>[]>;
    bridge?: pulumi.Input<string>;
    bridgeIp?: pulumi.Input<string>;
    dataRoot?: pulumi.Input<string>;
    defaultRuntime?: pulumi.Input<string>;
    defaultUlimits?: pulumi.Input<pulumi.Input<string>[]>;
    dns?: pulumi.Input<pulumi.Input<string>[]>;
    execOpts?: pulumi.Input<pulumi.Input<string>[]>;
    execRoot?: pulumi.Input<string>;
    experimental?: pulumi.Input<boolean>;
    healthCheck?: pulumi.Input<boolean>;
    hosts?: pulumi.Input<pulumi.Input<string>[]>;
    insecureRegistries?: pulumi.Input<pulumi.Input<string>[]>;
    insecureRegistry?: pulumi.Input<string>;
    ipMasq?: pulumi.Input<boolean>;
    ipTables?: pulumi.Input<boolean>;
    liveRestore?: pulumi.Input<boolean>;
    logDriver?: pulumi.Input<string>;
    logLevel?: pulumi.Input<string>;
    logOpts?: pulumi.Input<pulumi.Input<string>[]>;
    maxConcurrentDownloads?: pulumi.Input<number>;
    maxConcurrentUploads?: pulumi.Input<number>;
    maxDownloadAttempts?: pulumi.Input<number>;
    metricsAddress?: pulumi.Input<string>;
    mtu?: pulumi.Input<number>;
    packages?: pulumi.Input<inputs.ClusterDockerPackages>;
    registryMirrors?: pulumi.Input<pulumi.Input<string>[]>;
    runtimes?: pulumi.Input<pulumi.Input<string>[]>;
    selinuxEnabled?: pulumi.Input<boolean>;
    skipInstall?: pulumi.Input<boolean>;
    storage?: pulumi.Input<string>;
    storageOpts?: pulumi.Input<pulumi.Input<string>[]>;
    userNamespaceRemap?: pulumi.Input<string>;
    version?: pulumi.Input<string>;
}

export interface ClusterDockerPackages {
    hashAmd64?: pulumi.Input<string>;
    hashArm64?: pulumi.Input<string>;
    urlAmd64?: pulumi.Input<string>;
    urlArm64?: pulumi.Input<string>;
}

export interface ClusterEgressProxy {
    httpProxy: pulumi.Input<inputs.ClusterEgressProxyHttpProxy>;
    proxyExcludes?: pulumi.Input<string>;
}

export interface ClusterEgressProxyHttpProxy {
    host: pulumi.Input<string>;
    port: pulumi.Input<number>;
}

export interface ClusterEtcdCluster {
    backups?: pulumi.Input<inputs.ClusterEtcdClusterBackups>;
    cpuRequest?: pulumi.Input<string>;
    heartbeatInterval?: pulumi.Input<string>;
    image?: pulumi.Input<string>;
    leaderElectionTimeout?: pulumi.Input<string>;
    manager?: pulumi.Input<inputs.ClusterEtcdClusterManager>;
    members: pulumi.Input<pulumi.Input<inputs.ClusterEtcdClusterMember>[]>;
    memoryRequest?: pulumi.Input<string>;
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name: pulumi.Input<string>;
    provider?: pulumi.Input<string>;
    version?: pulumi.Input<string>;
}

export interface ClusterEtcdClusterBackups {
    backupStore: pulumi.Input<string>;
    image: pulumi.Input<string>;
}

export interface ClusterEtcdClusterManager {
    backupInterval?: pulumi.Input<string>;
    discoveryPollInterval?: pulumi.Input<string>;
    envs?: pulumi.Input<pulumi.Input<inputs.ClusterEtcdClusterManagerEnv>[]>;
    image?: pulumi.Input<string>;
    logLevel?: pulumi.Input<number>;
}

export interface ClusterEtcdClusterManagerEnv {
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface ClusterEtcdClusterMember {
    encryptedVolume?: pulumi.Input<boolean>;
    instanceGroup: pulumi.Input<string>;
    kmsKeyId?: pulumi.Input<string>;
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name: pulumi.Input<string>;
    volumeIops?: pulumi.Input<number>;
    volumeSize?: pulumi.Input<number>;
    volumeThroughput?: pulumi.Input<number>;
    volumeType?: pulumi.Input<string>;
}

export interface ClusterExternalCloudControllerManager {
    allocateNodeCidrs?: pulumi.Input<boolean>;
    allowUntaggedCloud?: pulumi.Input<boolean>;
    cidrAllocatorType?: pulumi.Input<string>;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    cloudProvider?: pulumi.Input<string>;
    clusterCidr?: pulumi.Input<string>;
    clusterName?: pulumi.Input<string>;
    configureCloudRoutes?: pulumi.Input<boolean>;
    controllers?: pulumi.Input<pulumi.Input<string>[]>;
    cpuRequest?: pulumi.Input<string>;
    enableLeaderMigration?: pulumi.Input<boolean>;
    image?: pulumi.Input<string>;
    leaderElection?: pulumi.Input<inputs.ClusterExternalCloudControllerManagerLeaderElection>;
    logLevel?: pulumi.Input<number>;
    master?: pulumi.Input<string>;
    useServiceAccountCredentials?: pulumi.Input<boolean>;
}

export interface ClusterExternalCloudControllerManagerLeaderElection {
    leaderElect?: pulumi.Input<boolean>;
    leaderElectLeaseDuration?: pulumi.Input<string>;
    leaderElectRenewDeadlineDuration?: pulumi.Input<string>;
    leaderElectResourceLock?: pulumi.Input<string>;
    leaderElectResourceName?: pulumi.Input<string>;
    leaderElectResourceNamespace?: pulumi.Input<string>;
    leaderElectRetryPeriod?: pulumi.Input<string>;
}

export interface ClusterExternalDns {
    provider?: pulumi.Input<string>;
    watchIngress?: pulumi.Input<boolean>;
    watchNamespace?: pulumi.Input<string>;
}

export interface ClusterExternalPolicy {
    key: pulumi.Input<string>;
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterFileAsset {
    content: pulumi.Input<string>;
    isBase64?: pulumi.Input<boolean>;
    mode?: pulumi.Input<string>;
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name: pulumi.Input<string>;
    path: pulumi.Input<string>;
    roles?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterHook {
    befores?: pulumi.Input<pulumi.Input<string>[]>;
    enabled?: pulumi.Input<boolean>;
    execContainer?: pulumi.Input<inputs.ClusterHookExecContainer>;
    manifest?: pulumi.Input<string>;
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name: pulumi.Input<string>;
    requires?: pulumi.Input<pulumi.Input<string>[]>;
    roles?: pulumi.Input<pulumi.Input<string>[]>;
    useRawManifest?: pulumi.Input<boolean>;
}

export interface ClusterHookExecContainer {
    commands?: pulumi.Input<pulumi.Input<string>[]>;
    environment?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    image: pulumi.Input<string>;
}

export interface ClusterIam {
    allowContainerRegistry?: pulumi.Input<boolean>;
    legacy?: pulumi.Input<boolean>;
    permissionsBoundary?: pulumi.Input<string>;
    serviceAccountExternalPermissions?: pulumi.Input<pulumi.Input<inputs.ClusterIamServiceAccountExternalPermission>[]>;
    useServiceAccountExternalPermissions?: pulumi.Input<boolean>;
}

export interface ClusterIamServiceAccountExternalPermission {
    aws?: pulumi.Input<inputs.ClusterIamServiceAccountExternalPermissionAws>;
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name?: pulumi.Input<string>;
    namespace?: pulumi.Input<string>;
}

export interface ClusterIamServiceAccountExternalPermissionAws {
    inlinePolicy?: pulumi.Input<string>;
    policyArNs?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterKarpenter {
    enabled?: pulumi.Input<boolean>;
}

export interface ClusterKubeApiServer {
    address?: pulumi.Input<string>;
    admissionControlConfigFile?: pulumi.Input<string>;
    admissionControls?: pulumi.Input<pulumi.Input<string>[]>;
    advertiseAddress?: pulumi.Input<string>;
    allowPrivileged?: pulumi.Input<boolean>;
    anonymousAuth?: pulumi.Input<inputs.ClusterKubeApiServerAnonymousAuth>;
    apiAudiences?: pulumi.Input<pulumi.Input<string>[]>;
    apiServerCount?: pulumi.Input<number>;
    appendAdmissionPlugins?: pulumi.Input<pulumi.Input<string>[]>;
    auditDynamicConfiguration?: pulumi.Input<boolean>;
    auditLogFormat?: pulumi.Input<string>;
    auditLogMaxAge?: pulumi.Input<number>;
    auditLogMaxBackups?: pulumi.Input<number>;
    auditLogMaxSize?: pulumi.Input<number>;
    auditLogPath?: pulumi.Input<string>;
    auditPolicyFile?: pulumi.Input<string>;
    auditWebhookBatchBufferSize?: pulumi.Input<number>;
    auditWebhookBatchMaxSize?: pulumi.Input<number>;
    auditWebhookBatchMaxWait?: pulumi.Input<string>;
    auditWebhookBatchThrottleBurst?: pulumi.Input<number>;
    auditWebhookBatchThrottleEnable?: pulumi.Input<boolean>;
    auditWebhookBatchThrottleQps?: pulumi.Input<string>;
    auditWebhookConfigFile?: pulumi.Input<string>;
    auditWebhookInitialBackoff?: pulumi.Input<string>;
    auditWebhookMode?: pulumi.Input<string>;
    authenticationTokenWebhookCacheTtl?: pulumi.Input<string>;
    authenticationTokenWebhookConfigFile?: pulumi.Input<string>;
    authorizationMode?: pulumi.Input<string>;
    authorizationRbacSuperUser?: pulumi.Input<string>;
    authorizationWebhookCacheAuthorizedTtl?: pulumi.Input<string>;
    authorizationWebhookCacheUnauthorizedTtl?: pulumi.Input<string>;
    authorizationWebhookConfigFile?: pulumi.Input<string>;
    basicAuthFile?: pulumi.Input<string>;
    bindAddress?: pulumi.Input<string>;
    clientCaFile?: pulumi.Input<string>;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    cloudProvider?: pulumi.Input<string>;
    corsAllowedOrigins?: pulumi.Input<pulumi.Input<string>[]>;
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    defaultNotReadyTolerationSeconds?: pulumi.Input<number>;
    defaultUnreachableTolerationSeconds?: pulumi.Input<number>;
    disableAdmissionPlugins?: pulumi.Input<pulumi.Input<string>[]>;
    disableBasicAuth?: pulumi.Input<boolean>;
    enableAdmissionPlugins?: pulumi.Input<pulumi.Input<string>[]>;
    enableAggregatorRouting?: pulumi.Input<boolean>;
    enableBootstrapAuthToken?: pulumi.Input<boolean>;
    enableProfiling?: pulumi.Input<boolean>;
    encryptionProviderConfig?: pulumi.Input<string>;
    etcdCaFile?: pulumi.Input<string>;
    etcdCertFile?: pulumi.Input<string>;
    etcdKeyFile?: pulumi.Input<string>;
    etcdQuorumRead?: pulumi.Input<boolean>;
    etcdServers?: pulumi.Input<pulumi.Input<string>[]>;
    etcdServersOverrides?: pulumi.Input<pulumi.Input<string>[]>;
    eventTtl?: pulumi.Input<string>;
    experimentalEncryptionProviderConfig?: pulumi.Input<string>;
    featureGates?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    http2MaxStreamsPerConnection?: pulumi.Input<number>;
    image?: pulumi.Input<string>;
    insecureBindAddress?: pulumi.Input<string>;
    insecurePort?: pulumi.Input<number>;
    kubeletCertificateAuthority?: pulumi.Input<string>;
    kubeletClientCertificate?: pulumi.Input<string>;
    kubeletClientKey?: pulumi.Input<string>;
    kubeletPreferredAddressTypes?: pulumi.Input<pulumi.Input<string>[]>;
    logFormat?: pulumi.Input<string>;
    logLevel?: pulumi.Input<number>;
    maxMutatingRequestsInflight?: pulumi.Input<number>;
    maxRequestsInflight?: pulumi.Input<number>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
    minRequestTimeout?: pulumi.Input<number>;
    oidcCaFile?: pulumi.Input<string>;
    oidcClientId?: pulumi.Input<string>;
    oidcGroupsClaim?: pulumi.Input<string>;
    oidcGroupsPrefix?: pulumi.Input<string>;
    oidcIssuerUrl?: pulumi.Input<string>;
    oidcRequiredClaims?: pulumi.Input<pulumi.Input<string>[]>;
    oidcUsernameClaim?: pulumi.Input<string>;
    oidcUsernamePrefix?: pulumi.Input<string>;
    proxyClientCertFile?: pulumi.Input<string>;
    proxyClientKeyFile?: pulumi.Input<string>;
    requestTimeout?: pulumi.Input<string>;
    requestheaderAllowedNames?: pulumi.Input<pulumi.Input<string>[]>;
    requestheaderClientCaFile?: pulumi.Input<string>;
    requestheaderExtraHeaderPrefixes?: pulumi.Input<pulumi.Input<string>[]>;
    requestheaderGroupHeaders?: pulumi.Input<pulumi.Input<string>[]>;
    requestheaderUsernameHeaders?: pulumi.Input<pulumi.Input<string>[]>;
    runtimeConfig?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    securePort?: pulumi.Input<number>;
    serviceAccountIssuer?: pulumi.Input<string>;
    serviceAccountJwksuri?: pulumi.Input<string>;
    serviceAccountKeyFiles?: pulumi.Input<pulumi.Input<string>[]>;
    serviceAccountSigningKeyFile?: pulumi.Input<string>;
    /**
     * - String - ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services.
     */
    serviceClusterIpRange?: pulumi.Input<string>;
    serviceNodePortRange?: pulumi.Input<string>;
    storageBackend?: pulumi.Input<string>;
    targetRamMb?: pulumi.Input<number>;
    tlsCertFile?: pulumi.Input<string>;
    tlsCipherSuites?: pulumi.Input<pulumi.Input<string>[]>;
    tlsMinVersion?: pulumi.Input<string>;
    tlsPrivateKeyFile?: pulumi.Input<string>;
    tokenAuthFile?: pulumi.Input<string>;
}

export interface ClusterKubeApiServerAnonymousAuth {
    value?: pulumi.Input<boolean>;
}

export interface ClusterKubeControllerManager {
    allocateNodeCidrs?: pulumi.Input<boolean>;
    attachDetachReconcileSyncPeriod?: pulumi.Input<string>;
    authenticationKubeconfig?: pulumi.Input<string>;
    authorizationAlwaysAllowPaths?: pulumi.Input<pulumi.Input<string>[]>;
    authorizationKubeconfig?: pulumi.Input<string>;
    cidrAllocatorType?: pulumi.Input<string>;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    cloudProvider?: pulumi.Input<string>;
    clusterCidr?: pulumi.Input<string>;
    clusterName?: pulumi.Input<string>;
    concurrentDeploymentSyncs?: pulumi.Input<number>;
    concurrentEndpointSyncs?: pulumi.Input<number>;
    concurrentNamespaceSyncs?: pulumi.Input<number>;
    concurrentRcSyncs?: pulumi.Input<number>;
    concurrentReplicasetSyncs?: pulumi.Input<number>;
    concurrentResourceQuotaSyncs?: pulumi.Input<number>;
    concurrentServiceSyncs?: pulumi.Input<number>;
    concurrentServiceaccountTokenSyncs?: pulumi.Input<number>;
    configureCloudRoutes?: pulumi.Input<boolean>;
    controllers?: pulumi.Input<pulumi.Input<string>[]>;
    disableAttachDetachReconcileSync?: pulumi.Input<boolean>;
    enableLeaderMigration?: pulumi.Input<boolean>;
    enableProfiling?: pulumi.Input<boolean>;
    experimentalClusterSigningDuration?: pulumi.Input<string>;
    externalCloudVolumePlugin?: pulumi.Input<string>;
    featureGates?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    horizontalPodAutoscalerCpuInitializationPeriod?: pulumi.Input<string>;
    horizontalPodAutoscalerDownscaleDelay?: pulumi.Input<string>;
    horizontalPodAutoscalerDownscaleStabilization?: pulumi.Input<string>;
    horizontalPodAutoscalerInitialReadinessDelay?: pulumi.Input<string>;
    horizontalPodAutoscalerSyncPeriod?: pulumi.Input<string>;
    horizontalPodAutoscalerTolerance?: pulumi.Input<string>;
    horizontalPodAutoscalerUpscaleDelay?: pulumi.Input<string>;
    horizontalPodAutoscalerUseRestClients?: pulumi.Input<boolean>;
    image?: pulumi.Input<string>;
    kubeApiBurst?: pulumi.Input<number>;
    kubeApiQps?: pulumi.Input<string>;
    leaderElection?: pulumi.Input<inputs.ClusterKubeControllerManagerLeaderElection>;
    logFormat?: pulumi.Input<string>;
    logLevel?: pulumi.Input<number>;
    master?: pulumi.Input<string>;
    minResyncPeriod?: pulumi.Input<string>;
    nodeCidrMaskSize?: pulumi.Input<number>;
    nodeMonitorGracePeriod?: pulumi.Input<string>;
    nodeMonitorPeriod?: pulumi.Input<string>;
    podEvictionTimeout?: pulumi.Input<string>;
    rootCaFile?: pulumi.Input<string>;
    serviceAccountPrivateKeyFile?: pulumi.Input<string>;
    terminatedPodGcThreshold?: pulumi.Input<number>;
    tlsCertFile?: pulumi.Input<string>;
    tlsCipherSuites?: pulumi.Input<pulumi.Input<string>[]>;
    tlsMinVersion?: pulumi.Input<string>;
    tlsPrivateKeyFile?: pulumi.Input<string>;
    useServiceAccountCredentials?: pulumi.Input<boolean>;
}

export interface ClusterKubeControllerManagerLeaderElection {
    leaderElect?: pulumi.Input<boolean>;
    leaderElectLeaseDuration?: pulumi.Input<string>;
    leaderElectRenewDeadlineDuration?: pulumi.Input<string>;
    leaderElectResourceLock?: pulumi.Input<string>;
    leaderElectResourceName?: pulumi.Input<string>;
    leaderElectResourceNamespace?: pulumi.Input<string>;
    leaderElectRetryPeriod?: pulumi.Input<string>;
}

export interface ClusterKubeDns {
    affinity?: pulumi.Input<inputs.ClusterKubeDnsAffinity>;
    cacheMaxConcurrent?: pulumi.Input<number>;
    cacheMaxSize?: pulumi.Input<number>;
    coreDnsImage?: pulumi.Input<string>;
    cpaImage?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    domain?: pulumi.Input<string>;
    externalCoreFile?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
    nodeLocalDns?: pulumi.Input<inputs.ClusterKubeDnsNodeLocalDns>;
    provider?: pulumi.Input<string>;
    serverIp?: pulumi.Input<string>;
    stubDomains?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsStubDomain>[]>;
    tolerations?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsToleration>[]>;
    upstreamNameservers?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterKubeDnsAffinity {
    nodeAffinity?: pulumi.Input<inputs.ClusterKubeDnsAffinityNodeAffinity>;
    podAffinity?: pulumi.Input<inputs.ClusterKubeDnsAffinityPodAffinity>;
    podAntiAffinity?: pulumi.Input<inputs.ClusterKubeDnsAffinityPodAntiAffinity>;
}

export interface ClusterKubeDnsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
    requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
}

export interface ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: pulumi.Input<inputs.ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
    weight?: pulumi.Input<number>;
}

export interface ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression>[]>;
    matchFields?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField>[]>;
}

export interface ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    values?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    values?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm>[]>;
}

export interface ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression>[]>;
    matchFields?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField>[]>;
}

export interface ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    values?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    values?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterKubeDnsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
    requiredDuringSchedulingIgnoredDuringExecutions?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
}

export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: pulumi.Input<inputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
    weight?: pulumi.Input<number>;
}

export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: pulumi.Input<inputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
    namespaceSelector?: pulumi.Input<inputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>;
    namespaces?: pulumi.Input<pulumi.Input<string>[]>;
    topologyKey?: pulumi.Input<string>;
}

export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression>[]>;
    matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    values?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression>[]>;
    matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    values?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: pulumi.Input<inputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
    namespaceSelector?: pulumi.Input<inputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>;
    namespaces?: pulumi.Input<pulumi.Input<string>[]>;
    topologyKey?: pulumi.Input<string>;
}

export interface ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression>[]>;
    matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    values?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression>[]>;
    matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    values?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterKubeDnsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
    requiredDuringSchedulingIgnoredDuringExecutions?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
}

export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: pulumi.Input<inputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
    weight?: pulumi.Input<number>;
}

export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: pulumi.Input<inputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
    namespaceSelector?: pulumi.Input<inputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>;
    namespaces?: pulumi.Input<pulumi.Input<string>[]>;
    topologyKey?: pulumi.Input<string>;
}

export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression>[]>;
    matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    values?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression>[]>;
    matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    values?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: pulumi.Input<inputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
    namespaceSelector?: pulumi.Input<inputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>;
    namespaces?: pulumi.Input<pulumi.Input<string>[]>;
    topologyKey?: pulumi.Input<string>;
}

export interface ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression>[]>;
    matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    values?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: pulumi.Input<pulumi.Input<inputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression>[]>;
    matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    values?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterKubeDnsNodeLocalDns {
    cpuRequest?: pulumi.Input<string>;
    enabled?: pulumi.Input<boolean>;
    forwardToKubeDns?: pulumi.Input<boolean>;
    image?: pulumi.Input<string>;
    localIp?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
    podAnnotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface ClusterKubeDnsStubDomain {
    key: pulumi.Input<string>;
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterKubeDnsToleration {
    effect?: pulumi.Input<string>;
    key?: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    tolerationSeconds?: pulumi.Input<number>;
    value?: pulumi.Input<string>;
}

export interface ClusterKubeProxy {
    bindAddress?: pulumi.Input<string>;
    clusterCidr?: pulumi.Input<string>;
    conntrackMaxPerCore?: pulumi.Input<number>;
    conntrackMin?: pulumi.Input<number>;
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    enabled: pulumi.Input<boolean>;
    featureGates?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    hostnameOverride?: pulumi.Input<string>;
    image?: pulumi.Input<string>;
    ipVsExcludeCidrs?: pulumi.Input<pulumi.Input<string>[]>;
    ipVsMinSyncPeriod?: pulumi.Input<string>;
    ipVsScheduler?: pulumi.Input<string>;
    ipVsSyncPeriod?: pulumi.Input<string>;
    logLevel?: pulumi.Input<number>;
    master?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
    metricsBindAddress?: pulumi.Input<string>;
    proxyMode?: pulumi.Input<string>;
}

export interface ClusterKubeScheduler {
    authenticationKubeconfig?: pulumi.Input<string>;
    authorizationAlwaysAllowPaths?: pulumi.Input<pulumi.Input<string>[]>;
    authorizationKubeconfig?: pulumi.Input<string>;
    burst?: pulumi.Input<number>;
    enableProfiling?: pulumi.Input<boolean>;
    featureGates?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    image?: pulumi.Input<string>;
    leaderElection?: pulumi.Input<inputs.ClusterKubeSchedulerLeaderElection>;
    logFormat?: pulumi.Input<string>;
    logLevel?: pulumi.Input<number>;
    master?: pulumi.Input<string>;
    maxPersistentVolumes?: pulumi.Input<number>;
    qps?: pulumi.Input<string>;
    tlsCertFile?: pulumi.Input<string>;
    tlsPrivateKeyFile?: pulumi.Input<string>;
    usePolicyConfigMap?: pulumi.Input<boolean>;
}

export interface ClusterKubeSchedulerLeaderElection {
    leaderElect?: pulumi.Input<boolean>;
    leaderElectLeaseDuration?: pulumi.Input<string>;
    leaderElectRenewDeadlineDuration?: pulumi.Input<string>;
    leaderElectResourceLock?: pulumi.Input<string>;
    leaderElectResourceName?: pulumi.Input<string>;
    leaderElectResourceNamespace?: pulumi.Input<string>;
    leaderElectRetryPeriod?: pulumi.Input<string>;
}

export interface ClusterKubelet {
    allowPrivileged?: pulumi.Input<boolean>;
    allowedUnsafeSysctls?: pulumi.Input<pulumi.Input<string>[]>;
    anonymousAuth?: pulumi.Input<inputs.ClusterKubeletAnonymousAuth>;
    apiServers?: pulumi.Input<string>;
    authenticationTokenWebhook?: pulumi.Input<boolean>;
    authenticationTokenWebhookCacheTtl?: pulumi.Input<string>;
    authorizationMode?: pulumi.Input<string>;
    babysitDaemons?: pulumi.Input<boolean>;
    bootstrapKubeconfig?: pulumi.Input<string>;
    cgroupDriver?: pulumi.Input<string>;
    cgroupRoot?: pulumi.Input<string>;
    clientCaFile?: pulumi.Input<string>;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    cloudProvider?: pulumi.Input<string>;
    clusterDns?: pulumi.Input<string>;
    clusterDomain?: pulumi.Input<string>;
    configureCbr0?: pulumi.Input<boolean>;
    containerLogMaxFiles?: pulumi.Input<number>;
    containerLogMaxSize?: pulumi.Input<string>;
    cpuCfsQuota?: pulumi.Input<inputs.ClusterKubeletCpuCfsQuota>;
    cpuCfsQuotaPeriod?: pulumi.Input<string>;
    cpuManagerPolicy?: pulumi.Input<string>;
    dockerDisableSharedPid?: pulumi.Input<boolean>;
    enableCadvisorJsonEndpoints?: pulumi.Input<boolean>;
    enableCustomMetrics?: pulumi.Input<boolean>;
    enableDebuggingHandlers?: pulumi.Input<boolean>;
    enforceNodeAllocatable?: pulumi.Input<string>;
    eventBurst?: pulumi.Input<number>;
    eventQps?: pulumi.Input<number>;
    evictionHard?: pulumi.Input<string>;
    evictionMaxPodGracePeriod?: pulumi.Input<number>;
    evictionMinimumReclaim?: pulumi.Input<string>;
    evictionPressureTransitionPeriod?: pulumi.Input<string>;
    evictionSoft?: pulumi.Input<string>;
    evictionSoftGracePeriod?: pulumi.Input<string>;
    experimentalAllowedUnsafeSysctls?: pulumi.Input<pulumi.Input<string>[]>;
    failSwapOn?: pulumi.Input<boolean>;
    featureGates?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    hairpinMode?: pulumi.Input<string>;
    hostnameOverride?: pulumi.Input<string>;
    housekeepingInterval?: pulumi.Input<string>;
    imageGcHighThresholdPercent?: pulumi.Input<number>;
    imageGcLowThresholdPercent?: pulumi.Input<number>;
    imagePullProgressDeadline?: pulumi.Input<string>;
    kernelMemcgNotification?: pulumi.Input<boolean>;
    kubeReserved?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    kubeReservedCgroup?: pulumi.Input<string>;
    kubeconfigPath?: pulumi.Input<string>;
    kubeletCgroups?: pulumi.Input<string>;
    logFormat?: pulumi.Input<string>;
    logLevel?: pulumi.Input<number>;
    maxPods?: pulumi.Input<number>;
    networkPluginMtu?: pulumi.Input<number>;
    networkPluginName?: pulumi.Input<string>;
    nodeLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    nodeStatusUpdateFrequency?: pulumi.Input<string>;
    /**
     * - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
     */
    nonMasqueradeCidr?: pulumi.Input<string>;
    nvidiaGpUs?: pulumi.Input<number>;
    /**
     * - String - PodCIDR is the CIDR from which we allocate IPs for pods.
     */
    podCidr?: pulumi.Input<string>;
    podInfraContainerImage?: pulumi.Input<string>;
    podManifestPath?: pulumi.Input<string>;
    podPidsLimit?: pulumi.Input<number>;
    protectKernelDefaults?: pulumi.Input<boolean>;
    readOnlyPort?: pulumi.Input<number>;
    reconcileCidr?: pulumi.Input<boolean>;
    registerNode?: pulumi.Input<boolean>;
    registerSchedulable?: pulumi.Input<boolean>;
    registryBurst?: pulumi.Input<number>;
    registryPullQps?: pulumi.Input<number>;
    requireKubeconfig?: pulumi.Input<boolean>;
    resolverConfig?: pulumi.Input<string>;
    rootDir?: pulumi.Input<string>;
    rotateCertificates?: pulumi.Input<boolean>;
    runtimeCgroups?: pulumi.Input<string>;
    runtimeRequestTimeout?: pulumi.Input<string>;
    seccompProfileRoot?: pulumi.Input<string>;
    serializeImagePulls?: pulumi.Input<boolean>;
    shutdownGracePeriod?: pulumi.Input<string>;
    shutdownGracePeriodCriticalPods?: pulumi.Input<string>;
    streamingConnectionIdleTimeout?: pulumi.Input<string>;
    systemCgroups?: pulumi.Input<string>;
    systemReserved?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    systemReservedCgroup?: pulumi.Input<string>;
    taints?: pulumi.Input<pulumi.Input<string>[]>;
    tlsCertFile?: pulumi.Input<string>;
    tlsCipherSuites?: pulumi.Input<pulumi.Input<string>[]>;
    tlsMinVersion?: pulumi.Input<string>;
    tlsPrivateKeyFile?: pulumi.Input<string>;
    topologyManagerPolicy?: pulumi.Input<string>;
    volumePluginDirectory?: pulumi.Input<string>;
    volumeStatsAggPeriod?: pulumi.Input<string>;
}

export interface ClusterKubeletAnonymousAuth {
    value?: pulumi.Input<boolean>;
}

export interface ClusterKubeletCpuCfsQuota {
    value?: pulumi.Input<boolean>;
}

export interface ClusterMasterKubelet {
    allowPrivileged?: pulumi.Input<boolean>;
    allowedUnsafeSysctls?: pulumi.Input<pulumi.Input<string>[]>;
    anonymousAuth?: pulumi.Input<inputs.ClusterMasterKubeletAnonymousAuth>;
    apiServers?: pulumi.Input<string>;
    authenticationTokenWebhook?: pulumi.Input<boolean>;
    authenticationTokenWebhookCacheTtl?: pulumi.Input<string>;
    authorizationMode?: pulumi.Input<string>;
    babysitDaemons?: pulumi.Input<boolean>;
    bootstrapKubeconfig?: pulumi.Input<string>;
    cgroupDriver?: pulumi.Input<string>;
    cgroupRoot?: pulumi.Input<string>;
    clientCaFile?: pulumi.Input<string>;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    cloudProvider?: pulumi.Input<string>;
    clusterDns?: pulumi.Input<string>;
    clusterDomain?: pulumi.Input<string>;
    configureCbr0?: pulumi.Input<boolean>;
    containerLogMaxFiles?: pulumi.Input<number>;
    containerLogMaxSize?: pulumi.Input<string>;
    cpuCfsQuota?: pulumi.Input<inputs.ClusterMasterKubeletCpuCfsQuota>;
    cpuCfsQuotaPeriod?: pulumi.Input<string>;
    cpuManagerPolicy?: pulumi.Input<string>;
    dockerDisableSharedPid?: pulumi.Input<boolean>;
    enableCadvisorJsonEndpoints?: pulumi.Input<boolean>;
    enableCustomMetrics?: pulumi.Input<boolean>;
    enableDebuggingHandlers?: pulumi.Input<boolean>;
    enforceNodeAllocatable?: pulumi.Input<string>;
    eventBurst?: pulumi.Input<number>;
    eventQps?: pulumi.Input<number>;
    evictionHard?: pulumi.Input<string>;
    evictionMaxPodGracePeriod?: pulumi.Input<number>;
    evictionMinimumReclaim?: pulumi.Input<string>;
    evictionPressureTransitionPeriod?: pulumi.Input<string>;
    evictionSoft?: pulumi.Input<string>;
    evictionSoftGracePeriod?: pulumi.Input<string>;
    experimentalAllowedUnsafeSysctls?: pulumi.Input<pulumi.Input<string>[]>;
    failSwapOn?: pulumi.Input<boolean>;
    featureGates?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    hairpinMode?: pulumi.Input<string>;
    hostnameOverride?: pulumi.Input<string>;
    housekeepingInterval?: pulumi.Input<string>;
    imageGcHighThresholdPercent?: pulumi.Input<number>;
    imageGcLowThresholdPercent?: pulumi.Input<number>;
    imagePullProgressDeadline?: pulumi.Input<string>;
    kernelMemcgNotification?: pulumi.Input<boolean>;
    kubeReserved?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    kubeReservedCgroup?: pulumi.Input<string>;
    kubeconfigPath?: pulumi.Input<string>;
    kubeletCgroups?: pulumi.Input<string>;
    logFormat?: pulumi.Input<string>;
    logLevel?: pulumi.Input<number>;
    maxPods?: pulumi.Input<number>;
    networkPluginMtu?: pulumi.Input<number>;
    networkPluginName?: pulumi.Input<string>;
    nodeLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    nodeStatusUpdateFrequency?: pulumi.Input<string>;
    /**
     * - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
     */
    nonMasqueradeCidr?: pulumi.Input<string>;
    nvidiaGpUs?: pulumi.Input<number>;
    /**
     * - String - PodCIDR is the CIDR from which we allocate IPs for pods.
     */
    podCidr?: pulumi.Input<string>;
    podInfraContainerImage?: pulumi.Input<string>;
    podManifestPath?: pulumi.Input<string>;
    podPidsLimit?: pulumi.Input<number>;
    protectKernelDefaults?: pulumi.Input<boolean>;
    readOnlyPort?: pulumi.Input<number>;
    reconcileCidr?: pulumi.Input<boolean>;
    registerNode?: pulumi.Input<boolean>;
    registerSchedulable?: pulumi.Input<boolean>;
    registryBurst?: pulumi.Input<number>;
    registryPullQps?: pulumi.Input<number>;
    requireKubeconfig?: pulumi.Input<boolean>;
    resolverConfig?: pulumi.Input<string>;
    rootDir?: pulumi.Input<string>;
    rotateCertificates?: pulumi.Input<boolean>;
    runtimeCgroups?: pulumi.Input<string>;
    runtimeRequestTimeout?: pulumi.Input<string>;
    seccompProfileRoot?: pulumi.Input<string>;
    serializeImagePulls?: pulumi.Input<boolean>;
    shutdownGracePeriod?: pulumi.Input<string>;
    shutdownGracePeriodCriticalPods?: pulumi.Input<string>;
    streamingConnectionIdleTimeout?: pulumi.Input<string>;
    systemCgroups?: pulumi.Input<string>;
    systemReserved?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    systemReservedCgroup?: pulumi.Input<string>;
    taints?: pulumi.Input<pulumi.Input<string>[]>;
    tlsCertFile?: pulumi.Input<string>;
    tlsCipherSuites?: pulumi.Input<pulumi.Input<string>[]>;
    tlsMinVersion?: pulumi.Input<string>;
    tlsPrivateKeyFile?: pulumi.Input<string>;
    topologyManagerPolicy?: pulumi.Input<string>;
    volumePluginDirectory?: pulumi.Input<string>;
    volumeStatsAggPeriod?: pulumi.Input<string>;
}

export interface ClusterMasterKubeletAnonymousAuth {
    value?: pulumi.Input<boolean>;
}

export interface ClusterMasterKubeletCpuCfsQuota {
    value?: pulumi.Input<boolean>;
}

export interface ClusterMetricsServer {
    enabled?: pulumi.Input<boolean>;
    image?: pulumi.Input<string>;
    insecure: pulumi.Input<boolean>;
}

export interface ClusterNetworking {
    amazonVpc?: pulumi.Input<inputs.ClusterNetworkingAmazonVpc>;
    calico?: pulumi.Input<inputs.ClusterNetworkingCalico>;
    canal?: pulumi.Input<inputs.ClusterNetworkingCanal>;
    cilium?: pulumi.Input<inputs.ClusterNetworkingCilium>;
    classic?: pulumi.Input<inputs.ClusterNetworkingClassic>;
    cni?: pulumi.Input<inputs.ClusterNetworkingCni>;
    external?: pulumi.Input<inputs.ClusterNetworkingExternal>;
    flannel?: pulumi.Input<inputs.ClusterNetworkingFlannel>;
    gce?: pulumi.Input<inputs.ClusterNetworkingGce>;
    kopeio?: pulumi.Input<inputs.ClusterNetworkingKopeio>;
    kubenet?: pulumi.Input<inputs.ClusterNetworkingKubenet>;
    kuberouter?: pulumi.Input<inputs.ClusterNetworkingKuberouter>;
    lyftVpc?: pulumi.Input<inputs.ClusterNetworkingLyftVpc>;
    romana?: pulumi.Input<inputs.ClusterNetworkingRomana>;
    weave?: pulumi.Input<inputs.ClusterNetworkingWeave>;
}

export interface ClusterNetworkingAmazonVpc {
    envs?: pulumi.Input<pulumi.Input<inputs.ClusterNetworkingAmazonVpcEnv>[]>;
    image?: pulumi.Input<string>;
    initImage?: pulumi.Input<string>;
}

export interface ClusterNetworkingAmazonVpcEnv {
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface ClusterNetworkingCalico {
    allowIpForwarding?: pulumi.Input<boolean>;
    awsSrcDstCheck?: pulumi.Input<string>;
    bpfEnabled?: pulumi.Input<boolean>;
    bpfExternalServiceMode?: pulumi.Input<string>;
    bpfKubeProxyIptablesCleanupEnabled?: pulumi.Input<boolean>;
    bpfLogLevel?: pulumi.Input<string>;
    chainInsertMode?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    crossSubnet?: pulumi.Input<boolean>;
    encapsulationMode?: pulumi.Input<string>;
    ipIpMode?: pulumi.Input<string>;
    iptablesBackend?: pulumi.Input<string>;
    ipv4AutoDetectionMethod?: pulumi.Input<string>;
    ipv6AutoDetectionMethod?: pulumi.Input<string>;
    logSeverityScreen?: pulumi.Input<string>;
    mtu?: pulumi.Input<number>;
    prometheusGoMetricsEnabled?: pulumi.Input<boolean>;
    prometheusMetricsEnabled?: pulumi.Input<boolean>;
    prometheusMetricsPort?: pulumi.Input<number>;
    prometheusProcessMetricsEnabled?: pulumi.Input<boolean>;
    registry?: pulumi.Input<string>;
    typhaPrometheusMetricsEnabled?: pulumi.Input<boolean>;
    typhaPrometheusMetricsPort?: pulumi.Input<number>;
    typhaReplicas?: pulumi.Input<number>;
    version?: pulumi.Input<string>;
    vxlanMode?: pulumi.Input<string>;
    wireguardEnabled?: pulumi.Input<boolean>;
}

export interface ClusterNetworkingCanal {
    chainInsertMode?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    defaultEndpointToHostAction?: pulumi.Input<string>;
    flanneldIptablesForwardRules?: pulumi.Input<boolean>;
    iptablesBackend?: pulumi.Input<string>;
    logSeveritySys?: pulumi.Input<string>;
    mtu?: pulumi.Input<number>;
    prometheusGoMetricsEnabled?: pulumi.Input<boolean>;
    prometheusMetricsEnabled?: pulumi.Input<boolean>;
    prometheusMetricsPort?: pulumi.Input<number>;
    prometheusProcessMetricsEnabled?: pulumi.Input<boolean>;
    typhaPrometheusMetricsEnabled?: pulumi.Input<boolean>;
    typhaPrometheusMetricsPort?: pulumi.Input<number>;
    typhaReplicas?: pulumi.Input<number>;
}

export interface ClusterNetworkingCilium {
    agentPodAnnotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    agentPrometheusPort?: pulumi.Input<number>;
    autoDirectNodeRoutes?: pulumi.Input<boolean>;
    bpfNeighGlobalMax?: pulumi.Input<number>;
    bpfPolicyMapMax?: pulumi.Input<number>;
    bpfctGlobalAnyMax?: pulumi.Input<number>;
    bpfctGlobalTcpMax?: pulumi.Input<number>;
    bpflbAlgorithm?: pulumi.Input<string>;
    bpflbMaglevTableSize?: pulumi.Input<string>;
    bpflbMapMax?: pulumi.Input<number>;
    bpflbSockHostNsOnly?: pulumi.Input<boolean>;
    bpfnatGlobalMax?: pulumi.Input<number>;
    chainingMode?: pulumi.Input<string>;
    clusterName?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    debug?: pulumi.Input<boolean>;
    disableCnpStatusUpdates?: pulumi.Input<boolean>;
    disableEndpointCrd?: pulumi.Input<boolean>;
    enableBpfMasquerade?: pulumi.Input<boolean>;
    enableEncryption?: pulumi.Input<boolean>;
    enableEndpointHealthChecking?: pulumi.Input<boolean>;
    enableHostReachableServices?: pulumi.Input<boolean>;
    enableL7Proxy?: pulumi.Input<boolean>;
    enableNodePort?: pulumi.Input<boolean>;
    enablePolicy?: pulumi.Input<string>;
    enablePrometheusMetrics?: pulumi.Input<boolean>;
    enableRemoteNodeIdentity: pulumi.Input<boolean>;
    enableServiceTopology?: pulumi.Input<boolean>;
    encryptionType?: pulumi.Input<string>;
    etcdManaged?: pulumi.Input<boolean>;
    hubble?: pulumi.Input<inputs.ClusterNetworkingCiliumHubble>;
    identityAllocationMode?: pulumi.Input<string>;
    identityChangeGracePeriod?: pulumi.Input<string>;
    installIptablesRules?: pulumi.Input<boolean>;
    ipam?: pulumi.Input<string>;
    masquerade?: pulumi.Input<boolean>;
    memoryRequest?: pulumi.Input<string>;
    metrics?: pulumi.Input<pulumi.Input<string>[]>;
    monitorAggregation?: pulumi.Input<string>;
    preallocateBpfMaps: pulumi.Input<boolean>;
    sidecarIstioProxyImage?: pulumi.Input<string>;
    toFqdnsDnsRejectResponseCode?: pulumi.Input<string>;
    toFqdnsEnablePoller?: pulumi.Input<boolean>;
    tunnel?: pulumi.Input<string>;
    version?: pulumi.Input<string>;
}

export interface ClusterNetworkingCiliumHubble {
    enabled?: pulumi.Input<boolean>;
    metrics?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterNetworkingClassic {
}

export interface ClusterNetworkingCni {
    usesSecondaryIp?: pulumi.Input<boolean>;
}

export interface ClusterNetworkingExternal {
}

export interface ClusterNetworkingFlannel {
    backend?: pulumi.Input<string>;
    iptablesResyncSeconds?: pulumi.Input<number>;
}

export interface ClusterNetworkingGce {
}

export interface ClusterNetworkingKopeio {
}

export interface ClusterNetworkingKubenet {
}

export interface ClusterNetworkingKuberouter {
}

export interface ClusterNetworkingLyftVpc {
    subnetTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface ClusterNetworkingRomana {
    daemonServiceIp?: pulumi.Input<string>;
    etcdServiceIp?: pulumi.Input<string>;
}

export interface ClusterNetworkingWeave {
    connLimit?: pulumi.Input<number>;
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
    mtu?: pulumi.Input<number>;
    netExtraArgs?: pulumi.Input<string>;
    noMasqLocal?: pulumi.Input<number>;
    npcCpuLimit?: pulumi.Input<string>;
    npcCpuRequest?: pulumi.Input<string>;
    npcExtraArgs?: pulumi.Input<string>;
    npcMemoryLimit?: pulumi.Input<string>;
    npcMemoryRequest?: pulumi.Input<string>;
    version?: pulumi.Input<string>;
}

export interface ClusterNodeAuthorization {
    nodeAuthorizer?: pulumi.Input<inputs.ClusterNodeAuthorizationNodeAuthorizer>;
}

export interface ClusterNodeAuthorizationNodeAuthorizer {
    authorizer?: pulumi.Input<string>;
    features?: pulumi.Input<pulumi.Input<string>[]>;
    image?: pulumi.Input<string>;
    interval?: pulumi.Input<string>;
    nodeUrl?: pulumi.Input<string>;
    port?: pulumi.Input<number>;
    timeout?: pulumi.Input<string>;
    tokenTtl?: pulumi.Input<string>;
}

export interface ClusterNodeProblemDetector {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    enabled?: pulumi.Input<boolean>;
    image?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface ClusterNodeTerminationHandler {
    cpuRequest?: pulumi.Input<string>;
    enablePrometheusMetrics?: pulumi.Input<boolean>;
    enableRebalanceDraining?: pulumi.Input<boolean>;
    enableRebalanceMonitoring?: pulumi.Input<boolean>;
    enableScheduledEventDraining?: pulumi.Input<boolean>;
    enableSpotInterruptionDraining: pulumi.Input<boolean>;
    enableSqsTerminationDraining?: pulumi.Input<boolean>;
    enabled: pulumi.Input<boolean>;
    excludeFromLoadBalancers?: pulumi.Input<boolean>;
    managedAsgTag?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
    version?: pulumi.Input<string>;
}

export interface ClusterNtp {
    managed?: pulumi.Input<boolean>;
}

export interface ClusterPodIdentityWebhook {
    enabled?: pulumi.Input<boolean>;
    replicas?: pulumi.Input<number>;
}

export interface ClusterRollingUpdate {
    drainAndTerminate?: pulumi.Input<boolean>;
    maxSurge?: pulumi.Input<string>;
    maxUnavailable?: pulumi.Input<string>;
}

export interface ClusterSecrets {
    clusterCaCert?: pulumi.Input<string>;
    clusterCaKey?: pulumi.Input<string>;
    dockerConfig?: pulumi.Input<string>;
}

export interface ClusterServiceAccountIssuerDiscovery {
    additionalAudiences?: pulumi.Input<pulumi.Input<string>[]>;
    discoveryStore?: pulumi.Input<string>;
    enableAwsOidcProvider?: pulumi.Input<boolean>;
}

export interface ClusterSnapshotController {
    enabled?: pulumi.Input<boolean>;
    installDefaultClass?: pulumi.Input<boolean>;
}

export interface ClusterSubnet {
    additionalRoutes?: pulumi.Input<pulumi.Input<inputs.ClusterSubnetAdditionalRoute>[]>;
    cidr?: pulumi.Input<string>;
    egress?: pulumi.Input<string>;
    ipv6Cidr?: pulumi.Input<string>;
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name: pulumi.Input<string>;
    providerId: pulumi.Input<string>;
    publicIp?: pulumi.Input<string>;
    region?: pulumi.Input<string>;
    type: pulumi.Input<string>;
    zone: pulumi.Input<string>;
}

export interface ClusterSubnetAdditionalRoute {
    cidr?: pulumi.Input<string>;
    target?: pulumi.Input<string>;
}

export interface ClusterTagSubnets {
    value?: pulumi.Input<boolean>;
}

export interface ClusterTopology {
    bastion?: pulumi.Input<inputs.ClusterTopologyBastion>;
    dns: pulumi.Input<inputs.ClusterTopologyDns>;
    masters: pulumi.Input<string>;
    nodes: pulumi.Input<string>;
}

export interface ClusterTopologyBastion {
    bastionPublicName: pulumi.Input<string>;
    idleTimeoutSeconds?: pulumi.Input<number>;
    loadBalancer?: pulumi.Input<inputs.ClusterTopologyBastionLoadBalancer>;
}

export interface ClusterTopologyBastionLoadBalancer {
    additionalSecurityGroups: pulumi.Input<pulumi.Input<string>[]>;
    type?: pulumi.Input<string>;
}

export interface ClusterTopologyDns {
    type: pulumi.Input<string>;
}

export interface ClusterUpdaterApply {
    allowKopsDowngrade?: pulumi.Input<boolean>;
    lifecycleOverrides?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    skip?: pulumi.Input<boolean>;
}

export interface ClusterUpdaterRollingUpdate {
    bastionInterval?: pulumi.Input<string>;
    cloudOnly?: pulumi.Input<boolean>;
    failOnDrainError?: pulumi.Input<boolean>;
    failOnValidate?: pulumi.Input<boolean>;
    force?: pulumi.Input<boolean>;
    masterInterval?: pulumi.Input<string>;
    nodeInterval?: pulumi.Input<string>;
    postDrainDelay?: pulumi.Input<string>;
    skip?: pulumi.Input<boolean>;
    validateCount?: pulumi.Input<number>;
    validationTimeout?: pulumi.Input<string>;
}

export interface ClusterUpdaterValidate {
    pollInterval?: pulumi.Input<string>;
    skip?: pulumi.Input<boolean>;
    timeout?: pulumi.Input<string>;
}

export interface ClusterWarmPool {
    enableLifecycleHook?: pulumi.Input<boolean>;
    maxSize?: pulumi.Input<number>;
    minSize?: pulumi.Input<number>;
}

export interface GetClusterExternalPolicy {
    key: string;
    values: string[];
}

export interface GetClusterExternalPolicyArgs {
    key: pulumi.Input<string>;
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface GetClusterTagSubnets {
    value?: boolean;
}

export interface GetClusterTagSubnetsArgs {
    value?: pulumi.Input<boolean>;
}

export interface InstanceGroupAdditionalUserData {
    content: pulumi.Input<string>;
    /**
     * - (Force new) - String - Name defines the instance group name.
     */
    name: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface InstanceGroupContainerd {
    address?: pulumi.Input<string>;
    configOverride?: pulumi.Input<string>;
    logLevel?: pulumi.Input<string>;
    nvidiaGpu?: pulumi.Input<inputs.InstanceGroupContainerdNvidiaGpu>;
    /**
     * - List(String) - Packages specifies additional packages to be installed.
     */
    packages?: pulumi.Input<inputs.InstanceGroupContainerdPackages>;
    registryMirrors?: pulumi.Input<pulumi.Input<inputs.InstanceGroupContainerdRegistryMirror>[]>;
    root?: pulumi.Input<string>;
    runc?: pulumi.Input<inputs.InstanceGroupContainerdRunc>;
    skipInstall?: pulumi.Input<boolean>;
    state?: pulumi.Input<string>;
    version?: pulumi.Input<string>;
}

export interface InstanceGroupContainerdNvidiaGpu {
    driverPackage?: pulumi.Input<string>;
    enabled?: pulumi.Input<boolean>;
}

export interface InstanceGroupContainerdPackages {
    hashAmd64?: pulumi.Input<string>;
    hashArm64?: pulumi.Input<string>;
    urlAmd64?: pulumi.Input<string>;
    urlArm64?: pulumi.Input<string>;
}

export interface InstanceGroupContainerdRegistryMirror {
    key: pulumi.Input<string>;
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface InstanceGroupContainerdRunc {
    /**
     * - List(String) - Packages specifies additional packages to be installed.
     */
    packages?: pulumi.Input<inputs.InstanceGroupContainerdRuncPackages>;
    version?: pulumi.Input<string>;
}

export interface InstanceGroupContainerdRuncPackages {
    hashAmd64?: pulumi.Input<string>;
    hashArm64?: pulumi.Input<string>;
    urlAmd64?: pulumi.Input<string>;
    urlArm64?: pulumi.Input<string>;
}

export interface InstanceGroupExternalLoadBalancer {
    loadBalancerName?: pulumi.Input<string>;
    targetGroupArn?: pulumi.Input<string>;
}

export interface InstanceGroupFileAsset {
    content: pulumi.Input<string>;
    isBase64?: pulumi.Input<boolean>;
    mode?: pulumi.Input<string>;
    /**
     * - (Force new) - String - Name defines the instance group name.
     */
    name: pulumi.Input<string>;
    path: pulumi.Input<string>;
    roles?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface InstanceGroupGuestAccelerator {
    acceleratorCount?: pulumi.Input<number>;
    acceleratorType?: pulumi.Input<string>;
}

export interface InstanceGroupHook {
    befores?: pulumi.Input<pulumi.Input<string>[]>;
    enabled?: pulumi.Input<boolean>;
    execContainer?: pulumi.Input<inputs.InstanceGroupHookExecContainer>;
    manifest?: pulumi.Input<string>;
    /**
     * - (Force new) - String - Name defines the instance group name.
     */
    name: pulumi.Input<string>;
    requires?: pulumi.Input<pulumi.Input<string>[]>;
    roles?: pulumi.Input<pulumi.Input<string>[]>;
    useRawManifest?: pulumi.Input<boolean>;
}

export interface InstanceGroupHookExecContainer {
    commands?: pulumi.Input<pulumi.Input<string>[]>;
    environment?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * - (Computed) - String - Image is the instance (ami etc) we should use.
     */
    image: pulumi.Input<string>;
}

export interface InstanceGroupIam {
    profile: pulumi.Input<string>;
}

export interface InstanceGroupInstanceMetadata {
    httpPutResponseHopLimit?: pulumi.Input<number>;
    httpTokens?: pulumi.Input<string>;
}

export interface InstanceGroupKubelet {
    allowPrivileged?: pulumi.Input<boolean>;
    allowedUnsafeSysctls?: pulumi.Input<pulumi.Input<string>[]>;
    anonymousAuth?: pulumi.Input<inputs.InstanceGroupKubeletAnonymousAuth>;
    apiServers?: pulumi.Input<string>;
    authenticationTokenWebhook?: pulumi.Input<boolean>;
    authenticationTokenWebhookCacheTtl?: pulumi.Input<string>;
    authorizationMode?: pulumi.Input<string>;
    babysitDaemons?: pulumi.Input<boolean>;
    bootstrapKubeconfig?: pulumi.Input<string>;
    cgroupDriver?: pulumi.Input<string>;
    cgroupRoot?: pulumi.Input<string>;
    clientCaFile?: pulumi.Input<string>;
    cloudProvider?: pulumi.Input<string>;
    clusterDns?: pulumi.Input<string>;
    clusterDomain?: pulumi.Input<string>;
    configureCbr0?: pulumi.Input<boolean>;
    containerLogMaxFiles?: pulumi.Input<number>;
    containerLogMaxSize?: pulumi.Input<string>;
    cpuCfsQuota?: pulumi.Input<inputs.InstanceGroupKubeletCpuCfsQuota>;
    cpuCfsQuotaPeriod?: pulumi.Input<string>;
    cpuManagerPolicy?: pulumi.Input<string>;
    dockerDisableSharedPid?: pulumi.Input<boolean>;
    enableCadvisorJsonEndpoints?: pulumi.Input<boolean>;
    enableCustomMetrics?: pulumi.Input<boolean>;
    enableDebuggingHandlers?: pulumi.Input<boolean>;
    enforceNodeAllocatable?: pulumi.Input<string>;
    eventBurst?: pulumi.Input<number>;
    eventQps?: pulumi.Input<number>;
    evictionHard?: pulumi.Input<string>;
    evictionMaxPodGracePeriod?: pulumi.Input<number>;
    evictionMinimumReclaim?: pulumi.Input<string>;
    evictionPressureTransitionPeriod?: pulumi.Input<string>;
    evictionSoft?: pulumi.Input<string>;
    evictionSoftGracePeriod?: pulumi.Input<string>;
    experimentalAllowedUnsafeSysctls?: pulumi.Input<pulumi.Input<string>[]>;
    failSwapOn?: pulumi.Input<boolean>;
    featureGates?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    hairpinMode?: pulumi.Input<string>;
    hostnameOverride?: pulumi.Input<string>;
    housekeepingInterval?: pulumi.Input<string>;
    imageGcHighThresholdPercent?: pulumi.Input<number>;
    imageGcLowThresholdPercent?: pulumi.Input<number>;
    imagePullProgressDeadline?: pulumi.Input<string>;
    kernelMemcgNotification?: pulumi.Input<boolean>;
    kubeReserved?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    kubeReservedCgroup?: pulumi.Input<string>;
    kubeconfigPath?: pulumi.Input<string>;
    kubeletCgroups?: pulumi.Input<string>;
    logFormat?: pulumi.Input<string>;
    logLevel?: pulumi.Input<number>;
    maxPods?: pulumi.Input<number>;
    networkPluginMtu?: pulumi.Input<number>;
    networkPluginName?: pulumi.Input<string>;
    /**
     * - Map(String) - NodeLabels indicates the kubernetes labels for nodes in this instance group.
     */
    nodeLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    nodeStatusUpdateFrequency?: pulumi.Input<string>;
    nonMasqueradeCidr?: pulumi.Input<string>;
    nvidiaGpUs?: pulumi.Input<number>;
    podCidr?: pulumi.Input<string>;
    podInfraContainerImage?: pulumi.Input<string>;
    podManifestPath?: pulumi.Input<string>;
    podPidsLimit?: pulumi.Input<number>;
    protectKernelDefaults?: pulumi.Input<boolean>;
    readOnlyPort?: pulumi.Input<number>;
    reconcileCidr?: pulumi.Input<boolean>;
    registerNode?: pulumi.Input<boolean>;
    registerSchedulable?: pulumi.Input<boolean>;
    registryBurst?: pulumi.Input<number>;
    registryPullQps?: pulumi.Input<number>;
    requireKubeconfig?: pulumi.Input<boolean>;
    resolverConfig?: pulumi.Input<string>;
    rootDir?: pulumi.Input<string>;
    rotateCertificates?: pulumi.Input<boolean>;
    runtimeCgroups?: pulumi.Input<string>;
    runtimeRequestTimeout?: pulumi.Input<string>;
    seccompProfileRoot?: pulumi.Input<string>;
    serializeImagePulls?: pulumi.Input<boolean>;
    shutdownGracePeriod?: pulumi.Input<string>;
    shutdownGracePeriodCriticalPods?: pulumi.Input<string>;
    streamingConnectionIdleTimeout?: pulumi.Input<string>;
    systemCgroups?: pulumi.Input<string>;
    systemReserved?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    systemReservedCgroup?: pulumi.Input<string>;
    /**
     * - List(String) - Taints indicates the kubernetes taints for nodes in this instance group.
     */
    taints?: pulumi.Input<pulumi.Input<string>[]>;
    tlsCertFile?: pulumi.Input<string>;
    tlsCipherSuites?: pulumi.Input<pulumi.Input<string>[]>;
    tlsMinVersion?: pulumi.Input<string>;
    tlsPrivateKeyFile?: pulumi.Input<string>;
    topologyManagerPolicy?: pulumi.Input<string>;
    volumePluginDirectory?: pulumi.Input<string>;
    volumeStatsAggPeriod?: pulumi.Input<string>;
}

export interface InstanceGroupKubeletAnonymousAuth {
    value?: pulumi.Input<boolean>;
}

export interface InstanceGroupKubeletCpuCfsQuota {
    value?: pulumi.Input<boolean>;
}

export interface InstanceGroupMixedInstancesPolicy {
    instanceRequirements?: pulumi.Input<inputs.InstanceGroupMixedInstancesPolicyInstanceRequirements>;
    instances?: pulumi.Input<pulumi.Input<string>[]>;
    onDemandAboveBase?: pulumi.Input<inputs.InstanceGroupMixedInstancesPolicyOnDemandAboveBase>;
    onDemandAllocationStrategy?: pulumi.Input<string>;
    onDemandBase?: pulumi.Input<inputs.InstanceGroupMixedInstancesPolicyOnDemandBase>;
    spotAllocationStrategy?: pulumi.Input<string>;
    spotInstancePools?: pulumi.Input<number>;
}

export interface InstanceGroupMixedInstancesPolicyInstanceRequirements {
    cpu?: pulumi.Input<inputs.InstanceGroupMixedInstancesPolicyInstanceRequirementsCpu>;
    memory?: pulumi.Input<inputs.InstanceGroupMixedInstancesPolicyInstanceRequirementsMemory>;
}

export interface InstanceGroupMixedInstancesPolicyInstanceRequirementsCpu {
    max?: pulumi.Input<string>;
    min?: pulumi.Input<string>;
}

export interface InstanceGroupMixedInstancesPolicyInstanceRequirementsMemory {
    max?: pulumi.Input<string>;
    min?: pulumi.Input<string>;
}

export interface InstanceGroupMixedInstancesPolicyOnDemandAboveBase {
    value?: pulumi.Input<number>;
}

export interface InstanceGroupMixedInstancesPolicyOnDemandBase {
    value?: pulumi.Input<number>;
}

export interface InstanceGroupRollingUpdate {
    drainAndTerminate?: pulumi.Input<boolean>;
    maxSurge?: pulumi.Input<string>;
    maxUnavailable?: pulumi.Input<string>;
}

export interface InstanceGroupVolume {
    deleteOnTermination?: pulumi.Input<boolean>;
    device: pulumi.Input<string>;
    encrypted?: pulumi.Input<boolean>;
    iops?: pulumi.Input<number>;
    key?: pulumi.Input<string>;
    size?: pulumi.Input<number>;
    throughput?: pulumi.Input<number>;
    type?: pulumi.Input<string>;
}

export interface InstanceGroupVolumeMount {
    device: pulumi.Input<string>;
    filesystem: pulumi.Input<string>;
    formatOptions?: pulumi.Input<pulumi.Input<string>[]>;
    mountOptions?: pulumi.Input<pulumi.Input<string>[]>;
    path: pulumi.Input<string>;
}

export interface InstanceGroupWarmPool {
    enableLifecycleHook?: pulumi.Input<boolean>;
    /**
     * - Int - MaxSize is the maximum size of the pool.
     */
    maxSize?: pulumi.Input<number>;
    /**
     * - Int - MinSize is the minimum size of the pool.
     */
    minSize?: pulumi.Input<number>;
}

export interface ProviderAws {
    accessKey?: pulumi.Input<string>;
    assumeRole?: pulumi.Input<inputs.ProviderAwsAssumeRole>;
    profile?: pulumi.Input<string>;
    region?: pulumi.Input<string>;
    s3AccessKey?: pulumi.Input<string>;
    s3Endpoint?: pulumi.Input<string>;
    s3Region?: pulumi.Input<string>;
    s3SecretKey?: pulumi.Input<string>;
    secretKey?: pulumi.Input<string>;
    skipRegionCheck?: pulumi.Input<boolean>;
}

export interface ProviderAwsAssumeRole {
    roleArn?: pulumi.Input<string>;
}

export interface ProviderKlog {
    verbosity?: pulumi.Input<inputs.ProviderKlogVerbosity>;
}

export interface ProviderKlogVerbosity {
    value?: pulumi.Input<number>;
}

export interface ProviderOpenstack {
    applicationCredentialId?: pulumi.Input<string>;
    applicationCredentialSecret?: pulumi.Input<string>;
    authUrl?: pulumi.Input<string>;
    domainId?: pulumi.Input<string>;
    domainName?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    projectDomainId?: pulumi.Input<string>;
    projectDomainName?: pulumi.Input<string>;
    projectId?: pulumi.Input<string>;
    projectName?: pulumi.Input<string>;
    regionName?: pulumi.Input<string>;
    tenantId?: pulumi.Input<string>;
    tenantName?: pulumi.Input<string>;
    username?: pulumi.Input<string>;
}

export namespace config {
}
