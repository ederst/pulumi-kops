// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface ClusterAddon {
    manifest: string;
}

export interface ClusterApi {
    dns?: outputs.ClusterApiDns;
    loadBalancer?: outputs.ClusterApiLoadBalancer;
}

export interface ClusterApiDns {
}

export interface ClusterApiLoadBalancer {
    accessLog?: outputs.ClusterApiLoadBalancerAccessLog;
    additionalSecurityGroups?: string[];
    class?: string;
    crossZoneLoadBalancing?: boolean;
    idleTimeoutSeconds?: number;
    securityGroupOverride?: string;
    sslCertificate?: string;
    sslPolicy?: string;
    subnets?: outputs.ClusterApiLoadBalancerSubnet[];
    type: string;
    useForInternalApi?: boolean;
}

export interface ClusterApiLoadBalancerAccessLog {
    bucket?: string;
    bucketPrefix?: string;
    interval?: number;
}

export interface ClusterApiLoadBalancerSubnet {
    allocationId?: string;
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name?: string;
    privateIpv4Address?: string;
}

export interface ClusterAssets {
    containerProxy?: string;
    containerRegistry?: string;
    fileRepository?: string;
}

export interface ClusterAuthentication {
    aws?: outputs.ClusterAuthenticationAws;
    kopeio?: outputs.ClusterAuthenticationKopeio;
}

export interface ClusterAuthenticationAws {
    backendMode?: string;
    clusterId?: string;
    cpuLimit?: string;
    cpuRequest?: string;
    identityMappings?: outputs.ClusterAuthenticationAwsIdentityMapping[];
    image?: string;
    memoryLimit?: string;
    memoryRequest?: string;
}

export interface ClusterAuthenticationAwsIdentityMapping {
    arn?: string;
    groups?: string[];
    username?: string;
}

export interface ClusterAuthenticationKopeio {
}

export interface ClusterAuthorization {
    alwaysAllow?: outputs.ClusterAuthorizationAlwaysAllow;
    rbac?: outputs.ClusterAuthorizationRbac;
}

export interface ClusterAuthorizationAlwaysAllow {
}

export interface ClusterAuthorizationRbac {
}

export interface ClusterAwsLoadBalancerController {
    enableShield?: boolean;
    enableWaFv2?: boolean;
    enableWaf?: boolean;
    enabled?: boolean;
    version?: string;
}

export interface ClusterCertManager {
    defaultIssuer?: string;
    enabled: boolean;
    hostedZoneIds?: string[];
    image?: string;
    managed: boolean;
    nameservers?: string[];
}

export interface ClusterCloudConfig {
    awsEbsCsiDriver?: outputs.ClusterCloudConfigAwsEbsCsiDriver;
    disableSecurityGroupIngress?: boolean;
    elbSecurityGroup?: string;
    gceServiceAccount?: string;
    gcpPdCsiDriver?: outputs.ClusterCloudConfigGcpPdCsiDriver;
    manageStorageClasses?: boolean;
    multizone?: boolean;
    nodeInstancePrefix?: string;
    nodeIpFamilies?: string[];
    nodeTags?: string;
    spotinstOrientation?: string;
    spotinstProduct?: string;
}

export interface ClusterCloudConfigAwsEbsCsiDriver {
    enabled?: boolean;
    managed?: boolean;
    podAnnotations?: {[key: string]: string};
    version?: string;
    volumeAttachLimit?: number;
}

export interface ClusterCloudConfigGcpPdCsiDriver {
    enabled?: boolean;
}

export interface ClusterCloudProvider {
    aws?: outputs.ClusterCloudProviderAws;
    azure?: outputs.ClusterCloudProviderAzure;
    do?: outputs.ClusterCloudProviderDo;
    gce?: outputs.ClusterCloudProviderGce;
    hetzner?: outputs.ClusterCloudProviderHetzner;
    openstack?: outputs.ClusterCloudProviderOpenstack;
}

export interface ClusterCloudProviderAws {
}

export interface ClusterCloudProviderAzure {
    adminUser?: string;
    resourceGroupName?: string;
    routeTableName?: string;
    subscriptionId?: string;
    tenantId?: string;
}

export interface ClusterCloudProviderDo {
}

export interface ClusterCloudProviderGce {
}

export interface ClusterCloudProviderHetzner {
}

export interface ClusterCloudProviderOpenstack {
    blockStorage?: outputs.ClusterCloudProviderOpenstackBlockStorage;
    insecureSkipVerify?: boolean;
    loadbalancer?: outputs.ClusterCloudProviderOpenstackLoadbalancer;
    metadata?: outputs.ClusterCloudProviderOpenstackMetadata;
    monitor?: outputs.ClusterCloudProviderOpenstackMonitor;
    network?: outputs.ClusterCloudProviderOpenstackNetwork;
    router?: outputs.ClusterCloudProviderOpenstackRouter;
}

export interface ClusterCloudProviderOpenstackBlockStorage {
    createStorageClass?: boolean;
    csiPluginImage?: string;
    csiTopologySupport?: boolean;
    ignoreAz?: boolean;
    overrideAz?: string;
    version?: string;
}

export interface ClusterCloudProviderOpenstackLoadbalancer {
    enableIngressHostname?: boolean;
    floatingNetwork?: string;
    floatingNetworkId?: string;
    floatingSubnet?: string;
    ingressHostnameSuffix?: string;
    manageSecGroups?: boolean;
    method?: string;
    provider?: string;
    subnetId?: string;
    useOctavia?: boolean;
}

export interface ClusterCloudProviderOpenstackMetadata {
    configDrive?: boolean;
}

export interface ClusterCloudProviderOpenstackMonitor {
    delay?: string;
    maxRetries?: number;
    timeout?: string;
}

export interface ClusterCloudProviderOpenstackNetwork {
    availabilityZoneHints?: string[];
    internalNetworkNames?: string[];
    ipv6SupportDisabled?: boolean;
    publicNetworkNames?: string[];
}

export interface ClusterCloudProviderOpenstackRouter {
    availabilityZoneHints?: string[];
    dnsServers?: string;
    externalNetwork?: string;
    externalSubnet?: string;
}

export interface ClusterClusterAutoscaler {
    awsUseStaticInstanceList?: boolean;
    balanceSimilarNodeGroups?: boolean;
    cordonNodeBeforeTerminating?: boolean;
    cpuRequest?: string;
    enabled?: boolean;
    expander?: string;
    image?: string;
    maxNodeProvisionTime?: string;
    memoryRequest?: string;
    newPodScaleUpDelay?: string;
    podAnnotations?: {[key: string]: string};
    scaleDownDelayAfterAdd?: string;
    scaleDownUnneededTime?: string;
    scaleDownUnreadyTime?: string;
    scaleDownUtilizationThreshold?: string;
    skipNodesWithLocalStorage: boolean;
    skipNodesWithSystemPods: boolean;
}

export interface ClusterContainerd {
    address?: string;
    configOverride?: string;
    logLevel?: string;
    nvidiaGpu?: outputs.ClusterContainerdNvidiaGpu;
    packages?: outputs.ClusterContainerdPackages;
    registryMirrors?: outputs.ClusterContainerdRegistryMirror[];
    root?: string;
    runc?: outputs.ClusterContainerdRunc;
    skipInstall?: boolean;
    state?: string;
    version?: string;
}

export interface ClusterContainerdNvidiaGpu {
    driverPackage?: string;
    enabled?: boolean;
}

export interface ClusterContainerdPackages {
    hashAmd64?: string;
    hashArm64?: string;
    urlAmd64?: string;
    urlArm64?: string;
}

export interface ClusterContainerdRegistryMirror {
    key: string;
    values: string[];
}

export interface ClusterContainerdRunc {
    packages?: outputs.ClusterContainerdRuncPackages;
    version?: string;
}

export interface ClusterContainerdRuncPackages {
    hashAmd64?: string;
    hashArm64?: string;
    urlAmd64?: string;
    urlArm64?: string;
}

export interface ClusterDocker {
    authorizationPlugins?: string[];
    bridge?: string;
    bridgeIp?: string;
    dataRoot?: string;
    defaultRuntime?: string;
    defaultUlimits?: string[];
    dns?: string[];
    execOpts?: string[];
    execRoot?: string;
    experimental?: boolean;
    healthCheck?: boolean;
    hosts?: string[];
    insecureRegistries?: string[];
    insecureRegistry?: string;
    ipMasq?: boolean;
    ipTables?: boolean;
    liveRestore?: boolean;
    logDriver?: string;
    logLevel?: string;
    logOpts?: string[];
    maxConcurrentDownloads?: number;
    maxConcurrentUploads?: number;
    maxDownloadAttempts?: number;
    metricsAddress?: string;
    mtu?: number;
    packages?: outputs.ClusterDockerPackages;
    registryMirrors?: string[];
    runtimes?: string[];
    selinuxEnabled?: boolean;
    skipInstall?: boolean;
    storage?: string;
    storageOpts?: string[];
    userNamespaceRemap?: string;
    version?: string;
}

export interface ClusterDockerPackages {
    hashAmd64?: string;
    hashArm64?: string;
    urlAmd64?: string;
    urlArm64?: string;
}

export interface ClusterEgressProxy {
    httpProxy: outputs.ClusterEgressProxyHttpProxy;
    proxyExcludes?: string;
}

export interface ClusterEgressProxyHttpProxy {
    host: string;
    port: number;
}

export interface ClusterEtcdCluster {
    backups?: outputs.ClusterEtcdClusterBackups;
    cpuRequest?: string;
    heartbeatInterval?: string;
    image?: string;
    leaderElectionTimeout?: string;
    manager?: outputs.ClusterEtcdClusterManager;
    members: outputs.ClusterEtcdClusterMember[];
    memoryRequest?: string;
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name: string;
    provider?: string;
    version?: string;
}

export interface ClusterEtcdClusterBackups {
    backupStore: string;
    image: string;
}

export interface ClusterEtcdClusterManager {
    backupInterval?: string;
    discoveryPollInterval?: string;
    envs?: outputs.ClusterEtcdClusterManagerEnv[];
    image?: string;
    logLevel?: number;
}

export interface ClusterEtcdClusterManagerEnv {
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name: string;
    value?: string;
}

export interface ClusterEtcdClusterMember {
    encryptedVolume?: boolean;
    instanceGroup: string;
    kmsKeyId?: string;
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name: string;
    volumeIops?: number;
    volumeSize?: number;
    volumeThroughput?: number;
    volumeType?: string;
}

export interface ClusterExternalCloudControllerManager {
    allocateNodeCidrs?: boolean;
    allowUntaggedCloud?: boolean;
    cidrAllocatorType?: string;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    cloudProvider?: string;
    clusterCidr?: string;
    clusterName?: string;
    configureCloudRoutes?: boolean;
    controllers?: string[];
    cpuRequest?: string;
    enableLeaderMigration?: boolean;
    image?: string;
    leaderElection?: outputs.ClusterExternalCloudControllerManagerLeaderElection;
    logLevel?: number;
    master?: string;
    useServiceAccountCredentials?: boolean;
}

export interface ClusterExternalCloudControllerManagerLeaderElection {
    leaderElect?: boolean;
    leaderElectLeaseDuration?: string;
    leaderElectRenewDeadlineDuration?: string;
    leaderElectResourceLock?: string;
    leaderElectResourceName?: string;
    leaderElectResourceNamespace?: string;
    leaderElectRetryPeriod?: string;
}

export interface ClusterExternalDns {
    provider?: string;
    watchIngress?: boolean;
    watchNamespace?: string;
}

export interface ClusterExternalPolicy {
    key: string;
    values: string[];
}

export interface ClusterFileAsset {
    content: string;
    isBase64?: boolean;
    mode?: string;
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name: string;
    path: string;
    roles?: string[];
}

export interface ClusterHook {
    befores?: string[];
    enabled?: boolean;
    execContainer?: outputs.ClusterHookExecContainer;
    manifest?: string;
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name: string;
    requires?: string[];
    roles?: string[];
    useRawManifest?: boolean;
}

export interface ClusterHookExecContainer {
    commands?: string[];
    environment?: {[key: string]: string};
    image: string;
}

export interface ClusterIam {
    allowContainerRegistry?: boolean;
    legacy?: boolean;
    permissionsBoundary?: string;
    serviceAccountExternalPermissions?: outputs.ClusterIamServiceAccountExternalPermission[];
    useServiceAccountExternalPermissions?: boolean;
}

export interface ClusterIamServiceAccountExternalPermission {
    aws?: outputs.ClusterIamServiceAccountExternalPermissionAws;
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name?: string;
    namespace?: string;
}

export interface ClusterIamServiceAccountExternalPermissionAws {
    inlinePolicy?: string;
    policyArNs?: string[];
}

export interface ClusterKarpenter {
    enabled?: boolean;
}

export interface ClusterKubeApiServer {
    address?: string;
    admissionControlConfigFile?: string;
    admissionControls?: string[];
    advertiseAddress?: string;
    allowPrivileged?: boolean;
    anonymousAuth?: outputs.ClusterKubeApiServerAnonymousAuth;
    apiAudiences?: string[];
    apiServerCount?: number;
    appendAdmissionPlugins?: string[];
    auditDynamicConfiguration?: boolean;
    auditLogFormat?: string;
    auditLogMaxAge?: number;
    auditLogMaxBackups?: number;
    auditLogMaxSize?: number;
    auditLogPath?: string;
    auditPolicyFile?: string;
    auditWebhookBatchBufferSize?: number;
    auditWebhookBatchMaxSize?: number;
    auditWebhookBatchMaxWait?: string;
    auditWebhookBatchThrottleBurst?: number;
    auditWebhookBatchThrottleEnable?: boolean;
    auditWebhookBatchThrottleQps?: string;
    auditWebhookConfigFile?: string;
    auditWebhookInitialBackoff?: string;
    auditWebhookMode?: string;
    authenticationTokenWebhookCacheTtl?: string;
    authenticationTokenWebhookConfigFile?: string;
    authorizationMode?: string;
    authorizationRbacSuperUser?: string;
    authorizationWebhookCacheAuthorizedTtl?: string;
    authorizationWebhookCacheUnauthorizedTtl?: string;
    authorizationWebhookConfigFile?: string;
    basicAuthFile?: string;
    bindAddress?: string;
    clientCaFile?: string;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    cloudProvider?: string;
    corsAllowedOrigins?: string[];
    cpuLimit?: string;
    cpuRequest?: string;
    defaultNotReadyTolerationSeconds?: number;
    defaultUnreachableTolerationSeconds?: number;
    disableAdmissionPlugins?: string[];
    disableBasicAuth?: boolean;
    enableAdmissionPlugins?: string[];
    enableAggregatorRouting?: boolean;
    enableBootstrapAuthToken?: boolean;
    enableProfiling?: boolean;
    encryptionProviderConfig?: string;
    etcdCaFile?: string;
    etcdCertFile?: string;
    etcdKeyFile?: string;
    etcdQuorumRead?: boolean;
    etcdServers?: string[];
    etcdServersOverrides?: string[];
    eventTtl?: string;
    experimentalEncryptionProviderConfig?: string;
    featureGates?: {[key: string]: string};
    http2MaxStreamsPerConnection?: number;
    image?: string;
    insecureBindAddress?: string;
    insecurePort?: number;
    kubeletCertificateAuthority?: string;
    kubeletClientCertificate?: string;
    kubeletClientKey?: string;
    kubeletPreferredAddressTypes?: string[];
    logFormat?: string;
    logLevel?: number;
    maxMutatingRequestsInflight?: number;
    maxRequestsInflight?: number;
    memoryLimit?: string;
    memoryRequest?: string;
    minRequestTimeout?: number;
    oidcCaFile?: string;
    oidcClientId?: string;
    oidcGroupsClaim?: string;
    oidcGroupsPrefix?: string;
    oidcIssuerUrl?: string;
    oidcRequiredClaims?: string[];
    oidcUsernameClaim?: string;
    oidcUsernamePrefix?: string;
    proxyClientCertFile?: string;
    proxyClientKeyFile?: string;
    requestTimeout?: string;
    requestheaderAllowedNames?: string[];
    requestheaderClientCaFile?: string;
    requestheaderExtraHeaderPrefixes?: string[];
    requestheaderGroupHeaders?: string[];
    requestheaderUsernameHeaders?: string[];
    runtimeConfig?: {[key: string]: string};
    securePort?: number;
    serviceAccountIssuer?: string;
    serviceAccountJwksuri?: string;
    serviceAccountKeyFiles?: string[];
    serviceAccountSigningKeyFile?: string;
    /**
     * - String - ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services.
     */
    serviceClusterIpRange?: string;
    serviceNodePortRange?: string;
    storageBackend?: string;
    targetRamMb?: number;
    tlsCertFile?: string;
    tlsCipherSuites?: string[];
    tlsMinVersion?: string;
    tlsPrivateKeyFile?: string;
    tokenAuthFile?: string;
}

export interface ClusterKubeApiServerAnonymousAuth {
    value?: boolean;
}

export interface ClusterKubeControllerManager {
    allocateNodeCidrs?: boolean;
    attachDetachReconcileSyncPeriod?: string;
    authenticationKubeconfig?: string;
    authorizationAlwaysAllowPaths?: string[];
    authorizationKubeconfig?: string;
    cidrAllocatorType?: string;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    cloudProvider?: string;
    clusterCidr?: string;
    clusterName?: string;
    concurrentDeploymentSyncs?: number;
    concurrentEndpointSyncs?: number;
    concurrentNamespaceSyncs?: number;
    concurrentRcSyncs?: number;
    concurrentReplicasetSyncs?: number;
    concurrentResourceQuotaSyncs?: number;
    concurrentServiceSyncs?: number;
    concurrentServiceaccountTokenSyncs?: number;
    configureCloudRoutes?: boolean;
    controllers?: string[];
    disableAttachDetachReconcileSync?: boolean;
    enableLeaderMigration?: boolean;
    enableProfiling?: boolean;
    experimentalClusterSigningDuration?: string;
    externalCloudVolumePlugin?: string;
    featureGates?: {[key: string]: string};
    horizontalPodAutoscalerCpuInitializationPeriod?: string;
    horizontalPodAutoscalerDownscaleDelay?: string;
    horizontalPodAutoscalerDownscaleStabilization?: string;
    horizontalPodAutoscalerInitialReadinessDelay?: string;
    horizontalPodAutoscalerSyncPeriod?: string;
    horizontalPodAutoscalerTolerance?: string;
    horizontalPodAutoscalerUpscaleDelay?: string;
    horizontalPodAutoscalerUseRestClients?: boolean;
    image?: string;
    kubeApiBurst?: number;
    kubeApiQps?: string;
    leaderElection?: outputs.ClusterKubeControllerManagerLeaderElection;
    logFormat?: string;
    logLevel?: number;
    master?: string;
    minResyncPeriod?: string;
    nodeCidrMaskSize?: number;
    nodeMonitorGracePeriod?: string;
    nodeMonitorPeriod?: string;
    podEvictionTimeout?: string;
    rootCaFile?: string;
    serviceAccountPrivateKeyFile?: string;
    terminatedPodGcThreshold?: number;
    tlsCertFile?: string;
    tlsCipherSuites?: string[];
    tlsMinVersion?: string;
    tlsPrivateKeyFile?: string;
    useServiceAccountCredentials?: boolean;
}

export interface ClusterKubeControllerManagerLeaderElection {
    leaderElect?: boolean;
    leaderElectLeaseDuration?: string;
    leaderElectRenewDeadlineDuration?: string;
    leaderElectResourceLock?: string;
    leaderElectResourceName?: string;
    leaderElectResourceNamespace?: string;
    leaderElectRetryPeriod?: string;
}

export interface ClusterKubeDns {
    affinity?: outputs.ClusterKubeDnsAffinity;
    cacheMaxConcurrent?: number;
    cacheMaxSize?: number;
    coreDnsImage?: string;
    cpaImage?: string;
    cpuRequest?: string;
    domain?: string;
    externalCoreFile?: string;
    memoryLimit?: string;
    memoryRequest?: string;
    nodeLocalDns?: outputs.ClusterKubeDnsNodeLocalDns;
    provider?: string;
    serverIp?: string;
    stubDomains?: outputs.ClusterKubeDnsStubDomain[];
    tolerations?: outputs.ClusterKubeDnsToleration[];
    upstreamNameservers?: string[];
}

export interface ClusterKubeDnsAffinity {
    nodeAffinity?: outputs.ClusterKubeDnsAffinityNodeAffinity;
    podAffinity?: outputs.ClusterKubeDnsAffinityPodAffinity;
    podAntiAffinity?: outputs.ClusterKubeDnsAffinityPodAntiAffinity;
}

export interface ClusterKubeDnsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ClusterKubeDnsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ClusterKubeDnsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ClusterKubeDnsNodeLocalDns {
    cpuRequest?: string;
    enabled?: boolean;
    forwardToKubeDns?: boolean;
    image?: string;
    localIp?: string;
    memoryRequest?: string;
    podAnnotations?: {[key: string]: string};
}

export interface ClusterKubeDnsStubDomain {
    key: string;
    values: string[];
}

export interface ClusterKubeDnsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ClusterKubeProxy {
    bindAddress?: string;
    clusterCidr?: string;
    conntrackMaxPerCore?: number;
    conntrackMin?: number;
    cpuLimit?: string;
    cpuRequest?: string;
    enabled: boolean;
    featureGates?: {[key: string]: string};
    hostnameOverride?: string;
    image?: string;
    ipVsExcludeCidrs?: string[];
    ipVsMinSyncPeriod?: string;
    ipVsScheduler?: string;
    ipVsSyncPeriod?: string;
    logLevel?: number;
    master?: string;
    memoryLimit?: string;
    memoryRequest?: string;
    metricsBindAddress?: string;
    proxyMode?: string;
}

export interface ClusterKubeScheduler {
    authenticationKubeconfig?: string;
    authorizationAlwaysAllowPaths?: string[];
    authorizationKubeconfig?: string;
    burst?: number;
    enableProfiling?: boolean;
    featureGates?: {[key: string]: string};
    image?: string;
    leaderElection?: outputs.ClusterKubeSchedulerLeaderElection;
    logFormat?: string;
    logLevel?: number;
    master?: string;
    maxPersistentVolumes?: number;
    qps?: string;
    tlsCertFile?: string;
    tlsPrivateKeyFile?: string;
    usePolicyConfigMap?: boolean;
}

export interface ClusterKubeSchedulerLeaderElection {
    leaderElect?: boolean;
    leaderElectLeaseDuration?: string;
    leaderElectRenewDeadlineDuration?: string;
    leaderElectResourceLock?: string;
    leaderElectResourceName?: string;
    leaderElectResourceNamespace?: string;
    leaderElectRetryPeriod?: string;
}

export interface ClusterKubelet {
    allowPrivileged?: boolean;
    allowedUnsafeSysctls?: string[];
    anonymousAuth?: outputs.ClusterKubeletAnonymousAuth;
    apiServers?: string;
    authenticationTokenWebhook?: boolean;
    authenticationTokenWebhookCacheTtl?: string;
    authorizationMode?: string;
    babysitDaemons?: boolean;
    bootstrapKubeconfig?: string;
    cgroupDriver?: string;
    cgroupRoot?: string;
    clientCaFile?: string;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    cloudProvider?: string;
    clusterDns?: string;
    clusterDomain?: string;
    configureCbr0?: boolean;
    containerLogMaxFiles?: number;
    containerLogMaxSize?: string;
    cpuCfsQuota?: outputs.ClusterKubeletCpuCfsQuota;
    cpuCfsQuotaPeriod?: string;
    cpuManagerPolicy?: string;
    dockerDisableSharedPid?: boolean;
    enableCadvisorJsonEndpoints?: boolean;
    enableCustomMetrics?: boolean;
    enableDebuggingHandlers?: boolean;
    enforceNodeAllocatable?: string;
    eventBurst?: number;
    eventQps?: number;
    evictionHard?: string;
    evictionMaxPodGracePeriod?: number;
    evictionMinimumReclaim?: string;
    evictionPressureTransitionPeriod?: string;
    evictionSoft?: string;
    evictionSoftGracePeriod?: string;
    experimentalAllowedUnsafeSysctls?: string[];
    failSwapOn?: boolean;
    featureGates?: {[key: string]: string};
    hairpinMode?: string;
    hostnameOverride?: string;
    housekeepingInterval?: string;
    imageGcHighThresholdPercent?: number;
    imageGcLowThresholdPercent?: number;
    imagePullProgressDeadline?: string;
    kernelMemcgNotification?: boolean;
    kubeReserved?: {[key: string]: string};
    kubeReservedCgroup?: string;
    kubeconfigPath?: string;
    kubeletCgroups?: string;
    logFormat?: string;
    logLevel?: number;
    maxPods?: number;
    networkPluginMtu?: number;
    networkPluginName?: string;
    nodeLabels?: {[key: string]: string};
    nodeStatusUpdateFrequency?: string;
    /**
     * - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
     */
    nonMasqueradeCidr?: string;
    nvidiaGpUs?: number;
    /**
     * - String - PodCIDR is the CIDR from which we allocate IPs for pods.
     */
    podCidr?: string;
    podInfraContainerImage?: string;
    podManifestPath?: string;
    podPidsLimit?: number;
    protectKernelDefaults?: boolean;
    readOnlyPort?: number;
    reconcileCidr?: boolean;
    registerNode?: boolean;
    registerSchedulable?: boolean;
    registryBurst?: number;
    registryPullQps?: number;
    requireKubeconfig?: boolean;
    resolverConfig?: string;
    rootDir?: string;
    rotateCertificates?: boolean;
    runtimeCgroups?: string;
    runtimeRequestTimeout?: string;
    seccompProfileRoot?: string;
    serializeImagePulls?: boolean;
    shutdownGracePeriod?: string;
    shutdownGracePeriodCriticalPods?: string;
    streamingConnectionIdleTimeout?: string;
    systemCgroups?: string;
    systemReserved?: {[key: string]: string};
    systemReservedCgroup?: string;
    taints?: string[];
    tlsCertFile?: string;
    tlsCipherSuites?: string[];
    tlsMinVersion?: string;
    tlsPrivateKeyFile?: string;
    topologyManagerPolicy?: string;
    volumePluginDirectory?: string;
    volumeStatsAggPeriod?: string;
}

export interface ClusterKubeletAnonymousAuth {
    value?: boolean;
}

export interface ClusterKubeletCpuCfsQuota {
    value?: boolean;
}

export interface ClusterMasterKubelet {
    allowPrivileged?: boolean;
    allowedUnsafeSysctls?: string[];
    anonymousAuth?: outputs.ClusterMasterKubeletAnonymousAuth;
    apiServers?: string;
    authenticationTokenWebhook?: boolean;
    authenticationTokenWebhookCacheTtl?: string;
    authorizationMode?: string;
    babysitDaemons?: boolean;
    bootstrapKubeconfig?: string;
    cgroupDriver?: string;
    cgroupRoot?: string;
    clientCaFile?: string;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    cloudProvider?: string;
    clusterDns?: string;
    clusterDomain?: string;
    configureCbr0?: boolean;
    containerLogMaxFiles?: number;
    containerLogMaxSize?: string;
    cpuCfsQuota?: outputs.ClusterMasterKubeletCpuCfsQuota;
    cpuCfsQuotaPeriod?: string;
    cpuManagerPolicy?: string;
    dockerDisableSharedPid?: boolean;
    enableCadvisorJsonEndpoints?: boolean;
    enableCustomMetrics?: boolean;
    enableDebuggingHandlers?: boolean;
    enforceNodeAllocatable?: string;
    eventBurst?: number;
    eventQps?: number;
    evictionHard?: string;
    evictionMaxPodGracePeriod?: number;
    evictionMinimumReclaim?: string;
    evictionPressureTransitionPeriod?: string;
    evictionSoft?: string;
    evictionSoftGracePeriod?: string;
    experimentalAllowedUnsafeSysctls?: string[];
    failSwapOn?: boolean;
    featureGates?: {[key: string]: string};
    hairpinMode?: string;
    hostnameOverride?: string;
    housekeepingInterval?: string;
    imageGcHighThresholdPercent?: number;
    imageGcLowThresholdPercent?: number;
    imagePullProgressDeadline?: string;
    kernelMemcgNotification?: boolean;
    kubeReserved?: {[key: string]: string};
    kubeReservedCgroup?: string;
    kubeconfigPath?: string;
    kubeletCgroups?: string;
    logFormat?: string;
    logLevel?: number;
    maxPods?: number;
    networkPluginMtu?: number;
    networkPluginName?: string;
    nodeLabels?: {[key: string]: string};
    nodeStatusUpdateFrequency?: string;
    /**
     * - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
     */
    nonMasqueradeCidr?: string;
    nvidiaGpUs?: number;
    /**
     * - String - PodCIDR is the CIDR from which we allocate IPs for pods.
     */
    podCidr?: string;
    podInfraContainerImage?: string;
    podManifestPath?: string;
    podPidsLimit?: number;
    protectKernelDefaults?: boolean;
    readOnlyPort?: number;
    reconcileCidr?: boolean;
    registerNode?: boolean;
    registerSchedulable?: boolean;
    registryBurst?: number;
    registryPullQps?: number;
    requireKubeconfig?: boolean;
    resolverConfig?: string;
    rootDir?: string;
    rotateCertificates?: boolean;
    runtimeCgroups?: string;
    runtimeRequestTimeout?: string;
    seccompProfileRoot?: string;
    serializeImagePulls?: boolean;
    shutdownGracePeriod?: string;
    shutdownGracePeriodCriticalPods?: string;
    streamingConnectionIdleTimeout?: string;
    systemCgroups?: string;
    systemReserved?: {[key: string]: string};
    systemReservedCgroup?: string;
    taints?: string[];
    tlsCertFile?: string;
    tlsCipherSuites?: string[];
    tlsMinVersion?: string;
    tlsPrivateKeyFile?: string;
    topologyManagerPolicy?: string;
    volumePluginDirectory?: string;
    volumeStatsAggPeriod?: string;
}

export interface ClusterMasterKubeletAnonymousAuth {
    value?: boolean;
}

export interface ClusterMasterKubeletCpuCfsQuota {
    value?: boolean;
}

export interface ClusterMetricsServer {
    enabled?: boolean;
    image?: string;
    insecure: boolean;
}

export interface ClusterNetworking {
    amazonVpc?: outputs.ClusterNetworkingAmazonVpc;
    calico?: outputs.ClusterNetworkingCalico;
    canal?: outputs.ClusterNetworkingCanal;
    cilium?: outputs.ClusterNetworkingCilium;
    classic?: outputs.ClusterNetworkingClassic;
    cni?: outputs.ClusterNetworkingCni;
    external?: outputs.ClusterNetworkingExternal;
    flannel?: outputs.ClusterNetworkingFlannel;
    gce?: outputs.ClusterNetworkingGce;
    kopeio?: outputs.ClusterNetworkingKopeio;
    kubenet?: outputs.ClusterNetworkingKubenet;
    kuberouter?: outputs.ClusterNetworkingKuberouter;
    lyftVpc?: outputs.ClusterNetworkingLyftVpc;
    romana?: outputs.ClusterNetworkingRomana;
    weave?: outputs.ClusterNetworkingWeave;
}

export interface ClusterNetworkingAmazonVpc {
    envs?: outputs.ClusterNetworkingAmazonVpcEnv[];
    image?: string;
    initImage?: string;
}

export interface ClusterNetworkingAmazonVpcEnv {
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name: string;
    value?: string;
}

export interface ClusterNetworkingCalico {
    allowIpForwarding?: boolean;
    awsSrcDstCheck?: string;
    bpfEnabled?: boolean;
    bpfExternalServiceMode?: string;
    bpfKubeProxyIptablesCleanupEnabled?: boolean;
    bpfLogLevel?: string;
    chainInsertMode?: string;
    cpuRequest?: string;
    crossSubnet?: boolean;
    encapsulationMode?: string;
    ipIpMode?: string;
    iptablesBackend?: string;
    ipv4AutoDetectionMethod?: string;
    ipv6AutoDetectionMethod?: string;
    logSeverityScreen?: string;
    mtu?: number;
    prometheusGoMetricsEnabled?: boolean;
    prometheusMetricsEnabled?: boolean;
    prometheusMetricsPort?: number;
    prometheusProcessMetricsEnabled?: boolean;
    registry?: string;
    typhaPrometheusMetricsEnabled?: boolean;
    typhaPrometheusMetricsPort?: number;
    typhaReplicas?: number;
    version?: string;
    vxlanMode?: string;
    wireguardEnabled?: boolean;
}

export interface ClusterNetworkingCanal {
    chainInsertMode?: string;
    cpuRequest?: string;
    defaultEndpointToHostAction?: string;
    flanneldIptablesForwardRules?: boolean;
    iptablesBackend?: string;
    logSeveritySys?: string;
    mtu?: number;
    prometheusGoMetricsEnabled?: boolean;
    prometheusMetricsEnabled?: boolean;
    prometheusMetricsPort?: number;
    prometheusProcessMetricsEnabled?: boolean;
    typhaPrometheusMetricsEnabled?: boolean;
    typhaPrometheusMetricsPort?: number;
    typhaReplicas?: number;
}

export interface ClusterNetworkingCilium {
    agentPodAnnotations?: {[key: string]: string};
    agentPrometheusPort?: number;
    autoDirectNodeRoutes?: boolean;
    bpfNeighGlobalMax?: number;
    bpfPolicyMapMax?: number;
    bpfctGlobalAnyMax?: number;
    bpfctGlobalTcpMax?: number;
    bpflbAlgorithm?: string;
    bpflbMaglevTableSize?: string;
    bpflbMapMax?: number;
    bpflbSockHostNsOnly?: boolean;
    bpfnatGlobalMax?: number;
    chainingMode?: string;
    clusterName?: string;
    cpuRequest?: string;
    debug?: boolean;
    disableCnpStatusUpdates?: boolean;
    disableEndpointCrd?: boolean;
    enableBpfMasquerade?: boolean;
    enableEncryption?: boolean;
    enableEndpointHealthChecking?: boolean;
    enableHostReachableServices?: boolean;
    enableL7Proxy?: boolean;
    enableNodePort?: boolean;
    enablePolicy?: string;
    enablePrometheusMetrics?: boolean;
    enableRemoteNodeIdentity: boolean;
    enableServiceTopology?: boolean;
    encryptionType?: string;
    etcdManaged?: boolean;
    hubble?: outputs.ClusterNetworkingCiliumHubble;
    identityAllocationMode?: string;
    identityChangeGracePeriod?: string;
    installIptablesRules?: boolean;
    ipam?: string;
    masquerade?: boolean;
    memoryRequest?: string;
    metrics?: string[];
    monitorAggregation?: string;
    preallocateBpfMaps: boolean;
    sidecarIstioProxyImage?: string;
    toFqdnsDnsRejectResponseCode?: string;
    toFqdnsEnablePoller?: boolean;
    tunnel?: string;
    version?: string;
}

export interface ClusterNetworkingCiliumHubble {
    enabled?: boolean;
    metrics?: string[];
}

export interface ClusterNetworkingClassic {
}

export interface ClusterNetworkingCni {
    usesSecondaryIp?: boolean;
}

export interface ClusterNetworkingExternal {
}

export interface ClusterNetworkingFlannel {
    backend?: string;
    iptablesResyncSeconds?: number;
}

export interface ClusterNetworkingGce {
}

export interface ClusterNetworkingKopeio {
}

export interface ClusterNetworkingKubenet {
}

export interface ClusterNetworkingKuberouter {
}

export interface ClusterNetworkingLyftVpc {
    subnetTags?: {[key: string]: string};
}

export interface ClusterNetworkingRomana {
    daemonServiceIp?: string;
    etcdServiceIp?: string;
}

export interface ClusterNetworkingWeave {
    connLimit?: number;
    cpuLimit?: string;
    cpuRequest?: string;
    memoryLimit?: string;
    memoryRequest?: string;
    mtu?: number;
    netExtraArgs?: string;
    noMasqLocal?: number;
    npcCpuLimit?: string;
    npcCpuRequest?: string;
    npcExtraArgs?: string;
    npcMemoryLimit?: string;
    npcMemoryRequest?: string;
    version?: string;
}

export interface ClusterNodeAuthorization {
    nodeAuthorizer?: outputs.ClusterNodeAuthorizationNodeAuthorizer;
}

export interface ClusterNodeAuthorizationNodeAuthorizer {
    authorizer?: string;
    features?: string[];
    image?: string;
    interval?: string;
    nodeUrl?: string;
    port?: number;
    timeout?: string;
    tokenTtl?: string;
}

export interface ClusterNodeProblemDetector {
    cpuLimit?: string;
    cpuRequest?: string;
    enabled?: boolean;
    image?: string;
    memoryLimit?: string;
    memoryRequest?: string;
}

export interface ClusterNodeTerminationHandler {
    cpuRequest?: string;
    enablePrometheusMetrics?: boolean;
    enableRebalanceDraining?: boolean;
    enableRebalanceMonitoring?: boolean;
    enableScheduledEventDraining?: boolean;
    enableSpotInterruptionDraining: boolean;
    enableSqsTerminationDraining?: boolean;
    enabled: boolean;
    excludeFromLoadBalancers?: boolean;
    managedAsgTag?: string;
    memoryRequest?: string;
    version?: string;
}

export interface ClusterNtp {
    managed?: boolean;
}

export interface ClusterPodIdentityWebhook {
    enabled?: boolean;
    replicas?: number;
}

export interface ClusterRollingUpdate {
    drainAndTerminate?: boolean;
    maxSurge?: string;
    maxUnavailable?: string;
}

export interface ClusterSecrets {
    clusterCaCert: string;
    clusterCaKey: string;
    dockerConfig?: string;
}

export interface ClusterServiceAccountIssuerDiscovery {
    additionalAudiences?: string[];
    discoveryStore?: string;
    enableAwsOidcProvider?: boolean;
}

export interface ClusterSnapshotController {
    enabled?: boolean;
    installDefaultClass?: boolean;
}

export interface ClusterSubnet {
    additionalRoutes?: outputs.ClusterSubnetAdditionalRoute[];
    cidr: string;
    egress?: string;
    ipv6Cidr?: string;
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name: string;
    providerId: string;
    publicIp?: string;
    region?: string;
    type: string;
    zone: string;
}

export interface ClusterSubnetAdditionalRoute {
    cidr?: string;
    target?: string;
}

export interface ClusterTagSubnets {
    value?: boolean;
}

export interface ClusterTopology {
    bastion?: outputs.ClusterTopologyBastion;
    dns: outputs.ClusterTopologyDns;
    masters: string;
    nodes: string;
}

export interface ClusterTopologyBastion {
    bastionPublicName: string;
    idleTimeoutSeconds?: number;
    loadBalancer?: outputs.ClusterTopologyBastionLoadBalancer;
}

export interface ClusterTopologyBastionLoadBalancer {
    additionalSecurityGroups: string[];
    type?: string;
}

export interface ClusterTopologyDns {
    type: string;
}

export interface ClusterUpdaterApply {
    allowKopsDowngrade?: boolean;
    lifecycleOverrides?: {[key: string]: string};
    skip?: boolean;
}

export interface ClusterUpdaterRollingUpdate {
    bastionInterval?: string;
    cloudOnly?: boolean;
    failOnDrainError?: boolean;
    failOnValidate?: boolean;
    force?: boolean;
    masterInterval?: string;
    nodeInterval?: string;
    postDrainDelay?: string;
    skip?: boolean;
    validateCount?: number;
    validationTimeout?: string;
}

export interface ClusterUpdaterValidate {
    pollInterval?: string;
    skip?: boolean;
    timeout?: string;
}

export interface ClusterWarmPool {
    enableLifecycleHook?: boolean;
    maxSize?: number;
    minSize?: number;
}

export interface GetClusterAddon {
    manifest: string;
}

export interface GetClusterApi {
    dns: outputs.GetClusterApiDn[];
    loadBalancers: outputs.GetClusterApiLoadBalancer[];
}

export interface GetClusterApiDn {
}

export interface GetClusterApiLoadBalancer {
    accessLogs: outputs.GetClusterApiLoadBalancerAccessLog[];
    additionalSecurityGroups: string[];
    class: string;
    crossZoneLoadBalancing: boolean;
    idleTimeoutSeconds: number;
    securityGroupOverride: string;
    sslCertificate: string;
    sslPolicy: string;
    subnets: outputs.GetClusterApiLoadBalancerSubnet[];
    type: string;
    useForInternalApi: boolean;
}

export interface GetClusterApiLoadBalancerAccessLog {
    bucket: string;
    bucketPrefix: string;
    interval: number;
}

export interface GetClusterApiLoadBalancerSubnet {
    allocationId: string;
    /**
     * - String - Name defines the cluster name.
     */
    name: string;
    privateIpv4Address: string;
}

export interface GetClusterAsset {
    containerProxy: string;
    containerRegistry: string;
    fileRepository: string;
}

export interface GetClusterAuthentication {
    aws: outputs.GetClusterAuthenticationAw[];
    kopeios: outputs.GetClusterAuthenticationKopeio[];
}

export interface GetClusterAuthenticationAw {
    backendMode: string;
    clusterId: string;
    cpuLimit: string;
    cpuRequest: string;
    identityMappings: outputs.GetClusterAuthenticationAwIdentityMapping[];
    image: string;
    memoryLimit: string;
    memoryRequest: string;
}

export interface GetClusterAuthenticationAwIdentityMapping {
    arn: string;
    groups: string[];
    username: string;
}

export interface GetClusterAuthenticationKopeio {
}

export interface GetClusterAuthorization {
    alwaysAllows: outputs.GetClusterAuthorizationAlwaysAllow[];
    rbacs: outputs.GetClusterAuthorizationRbac[];
}

export interface GetClusterAuthorizationAlwaysAllow {
}

export interface GetClusterAuthorizationRbac {
}

export interface GetClusterAwsLoadBalancerController {
    enableShield: boolean;
    enableWaFv2: boolean;
    enableWaf: boolean;
    enabled: boolean;
    version: string;
}

export interface GetClusterCertManager {
    defaultIssuer: string;
    enabled: boolean;
    hostedZoneIds: string[];
    image: string;
    managed: boolean;
    nameservers: string[];
}

export interface GetClusterCloudConfig {
    awsEbsCsiDrivers: outputs.GetClusterCloudConfigAwsEbsCsiDriver[];
    disableSecurityGroupIngress: boolean;
    elbSecurityGroup: string;
    gceServiceAccount: string;
    gcpPdCsiDrivers: outputs.GetClusterCloudConfigGcpPdCsiDriver[];
    manageStorageClasses: boolean;
    multizone: boolean;
    nodeInstancePrefix: string;
    nodeIpFamilies: string[];
    nodeTags: string;
    spotinstOrientation: string;
    spotinstProduct: string;
}

export interface GetClusterCloudConfigAwsEbsCsiDriver {
    enabled: boolean;
    managed: boolean;
    podAnnotations: {[key: string]: string};
    version: string;
    volumeAttachLimit: number;
}

export interface GetClusterCloudConfigGcpPdCsiDriver {
    enabled: boolean;
}

export interface GetClusterCloudProvider {
    aws: outputs.GetClusterCloudProviderAw[];
    azures: outputs.GetClusterCloudProviderAzure[];
    dos: outputs.GetClusterCloudProviderDo[];
    gces: outputs.GetClusterCloudProviderGce[];
    hetzners: outputs.GetClusterCloudProviderHetzner[];
    openstacks: outputs.GetClusterCloudProviderOpenstack[];
}

export interface GetClusterCloudProviderAw {
}

export interface GetClusterCloudProviderAzure {
    adminUser: string;
    resourceGroupName: string;
    routeTableName: string;
    subscriptionId: string;
    tenantId: string;
}

export interface GetClusterCloudProviderDo {
}

export interface GetClusterCloudProviderGce {
}

export interface GetClusterCloudProviderHetzner {
}

export interface GetClusterCloudProviderOpenstack {
    blockStorages: outputs.GetClusterCloudProviderOpenstackBlockStorage[];
    insecureSkipVerify: boolean;
    loadbalancers: outputs.GetClusterCloudProviderOpenstackLoadbalancer[];
    metadatas: outputs.GetClusterCloudProviderOpenstackMetadata[];
    monitors: outputs.GetClusterCloudProviderOpenstackMonitor[];
    networks: outputs.GetClusterCloudProviderOpenstackNetwork[];
    routers: outputs.GetClusterCloudProviderOpenstackRouter[];
}

export interface GetClusterCloudProviderOpenstackBlockStorage {
    createStorageClass: boolean;
    csiPluginImage: string;
    csiTopologySupport: boolean;
    ignoreAz: boolean;
    overrideAz: string;
    version: string;
}

export interface GetClusterCloudProviderOpenstackLoadbalancer {
    enableIngressHostname: boolean;
    floatingNetwork: string;
    floatingNetworkId: string;
    floatingSubnet: string;
    ingressHostnameSuffix: string;
    manageSecGroups: boolean;
    method: string;
    provider: string;
    subnetId: string;
    useOctavia: boolean;
}

export interface GetClusterCloudProviderOpenstackMetadata {
    configDrive: boolean;
}

export interface GetClusterCloudProviderOpenstackMonitor {
    delay: string;
    maxRetries: number;
    timeout: string;
}

export interface GetClusterCloudProviderOpenstackNetwork {
    availabilityZoneHints: string[];
    internalNetworkNames: string[];
    ipv6SupportDisabled: boolean;
    publicNetworkNames: string[];
}

export interface GetClusterCloudProviderOpenstackRouter {
    availabilityZoneHints: string[];
    dnsServers: string;
    externalNetwork: string;
    externalSubnet: string;
}

export interface GetClusterClusterAutoscaler {
    awsUseStaticInstanceList: boolean;
    balanceSimilarNodeGroups: boolean;
    cordonNodeBeforeTerminating: boolean;
    cpuRequest: string;
    enabled: boolean;
    expander: string;
    image: string;
    maxNodeProvisionTime: string;
    memoryRequest: string;
    newPodScaleUpDelay: string;
    podAnnotations: {[key: string]: string};
    scaleDownDelayAfterAdd: string;
    scaleDownUnneededTime: string;
    scaleDownUnreadyTime: string;
    scaleDownUtilizationThreshold: string;
    skipNodesWithLocalStorage: boolean;
    skipNodesWithSystemPods: boolean;
}

export interface GetClusterContainerd {
    address: string;
    configOverride: string;
    logLevel: string;
    nvidiaGpus: outputs.GetClusterContainerdNvidiaGpus[];
    packages: outputs.GetClusterContainerdPackage[];
    registryMirrors: outputs.GetClusterContainerdRegistryMirror[];
    root: string;
    runcs: outputs.GetClusterContainerdRunc[];
    skipInstall: boolean;
    state: string;
    version: string;
}

export interface GetClusterContainerdNvidiaGpus {
    driverPackage: string;
    enabled: boolean;
}

export interface GetClusterContainerdPackage {
    hashAmd64: string;
    hashArm64: string;
    urlAmd64: string;
    urlArm64: string;
}

export interface GetClusterContainerdRegistryMirror {
    key: string;
    values: string[];
}

export interface GetClusterContainerdRunc {
    packages: outputs.GetClusterContainerdRuncPackage[];
    version: string;
}

export interface GetClusterContainerdRuncPackage {
    hashAmd64: string;
    hashArm64: string;
    urlAmd64: string;
    urlArm64: string;
}

export interface GetClusterDocker {
    authorizationPlugins: string[];
    bridge: string;
    bridgeIp: string;
    dataRoot: string;
    defaultRuntime: string;
    defaultUlimits: string[];
    dns: string[];
    execOpts: string[];
    execRoot: string;
    experimental: boolean;
    healthCheck: boolean;
    hosts: string[];
    insecureRegistries: string[];
    insecureRegistry: string;
    ipMasq: boolean;
    ipTables: boolean;
    liveRestore: boolean;
    logDriver: string;
    logLevel: string;
    logOpts: string[];
    maxConcurrentDownloads: number;
    maxConcurrentUploads: number;
    maxDownloadAttempts: number;
    metricsAddress: string;
    mtu: number;
    packages: outputs.GetClusterDockerPackage[];
    registryMirrors: string[];
    runtimes: string[];
    selinuxEnabled: boolean;
    skipInstall: boolean;
    storage: string;
    storageOpts: string[];
    userNamespaceRemap: string;
    version: string;
}

export interface GetClusterDockerPackage {
    hashAmd64: string;
    hashArm64: string;
    urlAmd64: string;
    urlArm64: string;
}

export interface GetClusterEgressProxy {
    httpProxies: outputs.GetClusterEgressProxyHttpProxy[];
    proxyExcludes: string;
}

export interface GetClusterEgressProxyHttpProxy {
    host: string;
    port: number;
}

export interface GetClusterEtcdCluster {
    backups: outputs.GetClusterEtcdClusterBackup[];
    cpuRequest: string;
    heartbeatInterval: string;
    image: string;
    leaderElectionTimeout: string;
    managers: outputs.GetClusterEtcdClusterManager[];
    members: outputs.GetClusterEtcdClusterMember[];
    memoryRequest: string;
    /**
     * - String - Name defines the cluster name.
     */
    name: string;
    provider: string;
    version: string;
}

export interface GetClusterEtcdClusterBackup {
    backupStore: string;
    image: string;
}

export interface GetClusterEtcdClusterManager {
    backupInterval: string;
    discoveryPollInterval: string;
    envs: outputs.GetClusterEtcdClusterManagerEnv[];
    image: string;
    logLevel: number;
}

export interface GetClusterEtcdClusterManagerEnv {
    /**
     * - String - Name defines the cluster name.
     */
    name: string;
    value: string;
}

export interface GetClusterEtcdClusterMember {
    encryptedVolume: boolean;
    instanceGroup: string;
    kmsKeyId: string;
    /**
     * - String - Name defines the cluster name.
     */
    name: string;
    volumeIops: number;
    volumeSize: number;
    volumeThroughput: number;
    volumeType: string;
}

export interface GetClusterExternalCloudControllerManager {
    allocateNodeCidrs: boolean;
    allowUntaggedCloud: boolean;
    cidrAllocatorType: string;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    cloudProvider: string;
    clusterCidr: string;
    clusterName: string;
    configureCloudRoutes: boolean;
    controllers: string[];
    cpuRequest: string;
    enableLeaderMigration: boolean;
    image: string;
    leaderElections: outputs.GetClusterExternalCloudControllerManagerLeaderElection[];
    logLevel: number;
    master: string;
    useServiceAccountCredentials: boolean;
}

export interface GetClusterExternalCloudControllerManagerLeaderElection {
    leaderElect: boolean;
    leaderElectLeaseDuration: string;
    leaderElectRenewDeadlineDuration: string;
    leaderElectResourceLock: string;
    leaderElectResourceName: string;
    leaderElectResourceNamespace: string;
    leaderElectRetryPeriod: string;
}

export interface GetClusterExternalDn {
    provider: string;
    watchIngress: boolean;
    watchNamespace: string;
}

export interface GetClusterExternalPolicy {
    key: string;
    values: string[];
}

export interface GetClusterFileAsset {
    content: string;
    isBase64: boolean;
    mode: string;
    /**
     * - String - Name defines the cluster name.
     */
    name: string;
    path: string;
    roles: string[];
}

export interface GetClusterHook {
    befores: string[];
    enabled: boolean;
    execContainers: outputs.GetClusterHookExecContainer[];
    manifest: string;
    /**
     * - String - Name defines the cluster name.
     */
    name: string;
    requires: string[];
    roles: string[];
    useRawManifest: boolean;
}

export interface GetClusterHookExecContainer {
    commands: string[];
    environment: {[key: string]: string};
    image: string;
}

export interface GetClusterIam {
    allowContainerRegistry: boolean;
    legacy: boolean;
    permissionsBoundary: string;
    serviceAccountExternalPermissions: outputs.GetClusterIamServiceAccountExternalPermission[];
    useServiceAccountExternalPermissions: boolean;
}

export interface GetClusterIamServiceAccountExternalPermission {
    aws: outputs.GetClusterIamServiceAccountExternalPermissionAw[];
    /**
     * - String - Name defines the cluster name.
     */
    name: string;
    namespace: string;
}

export interface GetClusterIamServiceAccountExternalPermissionAw {
    inlinePolicy: string;
    policyArNs: string[];
}

export interface GetClusterKarpenter {
    enabled: boolean;
}

export interface GetClusterKubeApiServer {
    address: string;
    admissionControlConfigFile: string;
    admissionControls: string[];
    advertiseAddress: string;
    allowPrivileged: boolean;
    anonymousAuth?: outputs.GetClusterKubeApiServerAnonymousAuth;
    apiAudiences: string[];
    apiServerCount: number;
    appendAdmissionPlugins: string[];
    auditDynamicConfiguration: boolean;
    auditLogFormat: string;
    auditLogMaxAge: number;
    auditLogMaxBackups: number;
    auditLogMaxSize: number;
    auditLogPath: string;
    auditPolicyFile: string;
    auditWebhookBatchBufferSize: number;
    auditWebhookBatchMaxSize: number;
    auditWebhookBatchMaxWait: string;
    auditWebhookBatchThrottleBurst: number;
    auditWebhookBatchThrottleEnable: boolean;
    auditWebhookBatchThrottleQps: string;
    auditWebhookConfigFile: string;
    auditWebhookInitialBackoff: string;
    auditWebhookMode: string;
    authenticationTokenWebhookCacheTtl: string;
    authenticationTokenWebhookConfigFile: string;
    authorizationMode: string;
    authorizationRbacSuperUser: string;
    authorizationWebhookCacheAuthorizedTtl: string;
    authorizationWebhookCacheUnauthorizedTtl: string;
    authorizationWebhookConfigFile: string;
    basicAuthFile: string;
    bindAddress: string;
    clientCaFile: string;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    cloudProvider: string;
    corsAllowedOrigins: string[];
    cpuLimit: string;
    cpuRequest: string;
    defaultNotReadyTolerationSeconds: number;
    defaultUnreachableTolerationSeconds: number;
    disableAdmissionPlugins: string[];
    disableBasicAuth: boolean;
    enableAdmissionPlugins: string[];
    enableAggregatorRouting: boolean;
    enableBootstrapAuthToken: boolean;
    enableProfiling: boolean;
    encryptionProviderConfig: string;
    etcdCaFile: string;
    etcdCertFile: string;
    etcdKeyFile: string;
    etcdQuorumRead: boolean;
    etcdServers: string[];
    etcdServersOverrides: string[];
    eventTtl: string;
    experimentalEncryptionProviderConfig: string;
    featureGates: {[key: string]: string};
    http2MaxStreamsPerConnection: number;
    image: string;
    insecureBindAddress: string;
    insecurePort: number;
    kubeletCertificateAuthority: string;
    kubeletClientCertificate: string;
    kubeletClientKey: string;
    kubeletPreferredAddressTypes: string[];
    logFormat: string;
    logLevel: number;
    maxMutatingRequestsInflight: number;
    maxRequestsInflight: number;
    memoryLimit: string;
    memoryRequest: string;
    minRequestTimeout: number;
    oidcCaFile: string;
    oidcClientId: string;
    oidcGroupsClaim: string;
    oidcGroupsPrefix: string;
    oidcIssuerUrl: string;
    oidcRequiredClaims: string[];
    oidcUsernameClaim: string;
    oidcUsernamePrefix: string;
    proxyClientCertFile: string;
    proxyClientKeyFile: string;
    requestTimeout: string;
    requestheaderAllowedNames: string[];
    requestheaderClientCaFile: string;
    requestheaderExtraHeaderPrefixes: string[];
    requestheaderGroupHeaders: string[];
    requestheaderUsernameHeaders: string[];
    runtimeConfig: {[key: string]: string};
    securePort: number;
    serviceAccountIssuer: string;
    serviceAccountJwksuri: string;
    serviceAccountKeyFiles: string[];
    serviceAccountSigningKeyFile: string;
    /**
     * - String - ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services.
     */
    serviceClusterIpRange: string;
    serviceNodePortRange: string;
    storageBackend: string;
    targetRamMb: number;
    tlsCertFile: string;
    tlsCipherSuites: string[];
    tlsMinVersion: string;
    tlsPrivateKeyFile: string;
    tokenAuthFile: string;
}

export interface GetClusterKubeApiServerAnonymousAuth {
    value: boolean;
}

export interface GetClusterKubeControllerManager {
    allocateNodeCidrs: boolean;
    attachDetachReconcileSyncPeriod: string;
    authenticationKubeconfig: string;
    authorizationAlwaysAllowPaths: string[];
    authorizationKubeconfig: string;
    cidrAllocatorType: string;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    cloudProvider: string;
    clusterCidr: string;
    clusterName: string;
    concurrentDeploymentSyncs: number;
    concurrentEndpointSyncs: number;
    concurrentNamespaceSyncs: number;
    concurrentRcSyncs: number;
    concurrentReplicasetSyncs: number;
    concurrentResourceQuotaSyncs: number;
    concurrentServiceSyncs: number;
    concurrentServiceaccountTokenSyncs: number;
    configureCloudRoutes: boolean;
    controllers: string[];
    disableAttachDetachReconcileSync: boolean;
    enableLeaderMigration: boolean;
    enableProfiling: boolean;
    experimentalClusterSigningDuration: string;
    externalCloudVolumePlugin: string;
    featureGates: {[key: string]: string};
    horizontalPodAutoscalerCpuInitializationPeriod: string;
    horizontalPodAutoscalerDownscaleDelay: string;
    horizontalPodAutoscalerDownscaleStabilization: string;
    horizontalPodAutoscalerInitialReadinessDelay: string;
    horizontalPodAutoscalerSyncPeriod: string;
    horizontalPodAutoscalerTolerance: string;
    horizontalPodAutoscalerUpscaleDelay: string;
    horizontalPodAutoscalerUseRestClients: boolean;
    image: string;
    kubeApiBurst: number;
    kubeApiQps: string;
    leaderElections: outputs.GetClusterKubeControllerManagerLeaderElection[];
    logFormat: string;
    logLevel: number;
    master: string;
    minResyncPeriod: string;
    nodeCidrMaskSize: number;
    nodeMonitorGracePeriod: string;
    nodeMonitorPeriod: string;
    podEvictionTimeout: string;
    rootCaFile: string;
    serviceAccountPrivateKeyFile: string;
    terminatedPodGcThreshold: number;
    tlsCertFile: string;
    tlsCipherSuites: string[];
    tlsMinVersion: string;
    tlsPrivateKeyFile: string;
    useServiceAccountCredentials: boolean;
}

export interface GetClusterKubeControllerManagerLeaderElection {
    leaderElect: boolean;
    leaderElectLeaseDuration: string;
    leaderElectRenewDeadlineDuration: string;
    leaderElectResourceLock: string;
    leaderElectResourceName: string;
    leaderElectResourceNamespace: string;
    leaderElectRetryPeriod: string;
}

export interface GetClusterKubeDn {
    affinities: outputs.GetClusterKubeDnAffinity[];
    cacheMaxConcurrent: number;
    cacheMaxSize: number;
    coreDnsImage: string;
    cpaImage: string;
    cpuRequest: string;
    domain: string;
    externalCoreFile: string;
    memoryLimit: string;
    memoryRequest: string;
    nodeLocalDns: outputs.GetClusterKubeDnNodeLocalDn[];
    provider: string;
    serverIp: string;
    stubDomains: outputs.GetClusterKubeDnStubDomain[];
    tolerations: outputs.GetClusterKubeDnToleration[];
    upstreamNameservers: string[];
}

export interface GetClusterKubeDnAffinity {
    nodeAffinities: outputs.GetClusterKubeDnAffinityNodeAffinity[];
    podAffinities: outputs.GetClusterKubeDnAffinityPodAffinity[];
    podAntiAffinities: outputs.GetClusterKubeDnAffinityPodAntiAffinity[];
}

export interface GetClusterKubeDnAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions: outputs.GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions: outputs.GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preferences: outputs.GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference[];
    weight: number;
}

export interface GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions: outputs.GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields: outputs.GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key: string;
    operator: string;
    values: string[];
}

export interface GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key: string;
    operator: string;
    values: string[];
}

export interface GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms: outputs.GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions: outputs.GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields: outputs.GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key: string;
    operator: string;
    values: string[];
}

export interface GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key: string;
    operator: string;
    values: string[];
}

export interface GetClusterKubeDnAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions: outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions: outputs.GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerms: outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm[];
    weight: number;
}

export interface GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelectors: outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector[];
    namespaceSelectors: outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector[];
    namespaces: string[];
    topologyKey: string;
}

export interface GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions: outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels: {[key: string]: string};
}

export interface GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key: string;
    operator: string;
    values: string[];
}

export interface GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions: outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels: {[key: string]: string};
}

export interface GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key: string;
    operator: string;
    values: string[];
}

export interface GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelectors: outputs.GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector[];
    namespaceSelectors: outputs.GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector[];
    namespaces: string[];
    topologyKey: string;
}

export interface GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions: outputs.GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels: {[key: string]: string};
}

export interface GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key: string;
    operator: string;
    values: string[];
}

export interface GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions: outputs.GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels: {[key: string]: string};
}

export interface GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key: string;
    operator: string;
    values: string[];
}

export interface GetClusterKubeDnAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions: outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions: outputs.GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerms: outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm[];
    weight: number;
}

export interface GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelectors: outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector[];
    namespaceSelectors: outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector[];
    namespaces: string[];
    topologyKey: string;
}

export interface GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions: outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels: {[key: string]: string};
}

export interface GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key: string;
    operator: string;
    values: string[];
}

export interface GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions: outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels: {[key: string]: string};
}

export interface GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key: string;
    operator: string;
    values: string[];
}

export interface GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelectors: outputs.GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector[];
    namespaceSelectors: outputs.GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector[];
    namespaces: string[];
    topologyKey: string;
}

export interface GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions: outputs.GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels: {[key: string]: string};
}

export interface GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key: string;
    operator: string;
    values: string[];
}

export interface GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions: outputs.GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels: {[key: string]: string};
}

export interface GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key: string;
    operator: string;
    values: string[];
}

export interface GetClusterKubeDnNodeLocalDn {
    cpuRequest: string;
    enabled: boolean;
    forwardToKubeDns: boolean;
    image: string;
    localIp: string;
    memoryRequest: string;
    podAnnotations: {[key: string]: string};
}

export interface GetClusterKubeDnStubDomain {
    key: string;
    values: string[];
}

export interface GetClusterKubeDnToleration {
    effect: string;
    key: string;
    operator: string;
    tolerationSeconds: number;
    value: string;
}

export interface GetClusterKubeProxy {
    bindAddress: string;
    clusterCidr: string;
    conntrackMaxPerCore: number;
    conntrackMin: number;
    cpuLimit: string;
    cpuRequest: string;
    enabled: boolean;
    featureGates: {[key: string]: string};
    hostnameOverride: string;
    image: string;
    ipVsExcludeCidrs: string[];
    ipVsMinSyncPeriod: string;
    ipVsScheduler: string;
    ipVsSyncPeriod: string;
    logLevel: number;
    master: string;
    memoryLimit: string;
    memoryRequest: string;
    metricsBindAddress: string;
    proxyMode: string;
}

export interface GetClusterKubeScheduler {
    authenticationKubeconfig: string;
    authorizationAlwaysAllowPaths: string[];
    authorizationKubeconfig: string;
    burst: number;
    enableProfiling: boolean;
    featureGates: {[key: string]: string};
    image: string;
    leaderElections: outputs.GetClusterKubeSchedulerLeaderElection[];
    logFormat: string;
    logLevel: number;
    master: string;
    maxPersistentVolumes: number;
    qps: string;
    tlsCertFile: string;
    tlsPrivateKeyFile: string;
    usePolicyConfigMap: boolean;
}

export interface GetClusterKubeSchedulerLeaderElection {
    leaderElect: boolean;
    leaderElectLeaseDuration: string;
    leaderElectRenewDeadlineDuration: string;
    leaderElectResourceLock: string;
    leaderElectResourceName: string;
    leaderElectResourceNamespace: string;
    leaderElectRetryPeriod: string;
}

export interface GetClusterKubelet {
    allowPrivileged: boolean;
    allowedUnsafeSysctls: string[];
    anonymousAuth?: outputs.GetClusterKubeletAnonymousAuth;
    apiServers: string;
    authenticationTokenWebhook: boolean;
    authenticationTokenWebhookCacheTtl: string;
    authorizationMode: string;
    babysitDaemons: boolean;
    bootstrapKubeconfig: string;
    cgroupDriver: string;
    cgroupRoot: string;
    clientCaFile: string;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    cloudProvider: string;
    clusterDns: string;
    clusterDomain: string;
    configureCbr0: boolean;
    containerLogMaxFiles: number;
    containerLogMaxSize: string;
    cpuCfsQuota?: outputs.GetClusterKubeletCpuCfsQuota;
    cpuCfsQuotaPeriod: string;
    cpuManagerPolicy: string;
    dockerDisableSharedPid: boolean;
    enableCadvisorJsonEndpoints: boolean;
    enableCustomMetrics: boolean;
    enableDebuggingHandlers: boolean;
    enforceNodeAllocatable: string;
    eventBurst: number;
    eventQps: number;
    evictionHard: string;
    evictionMaxPodGracePeriod: number;
    evictionMinimumReclaim: string;
    evictionPressureTransitionPeriod: string;
    evictionSoft: string;
    evictionSoftGracePeriod: string;
    experimentalAllowedUnsafeSysctls: string[];
    failSwapOn: boolean;
    featureGates: {[key: string]: string};
    hairpinMode: string;
    hostnameOverride: string;
    housekeepingInterval: string;
    imageGcHighThresholdPercent: number;
    imageGcLowThresholdPercent: number;
    imagePullProgressDeadline: string;
    kernelMemcgNotification: boolean;
    kubeReserved: {[key: string]: string};
    kubeReservedCgroup: string;
    kubeconfigPath: string;
    kubeletCgroups: string;
    logFormat: string;
    logLevel: number;
    maxPods: number;
    networkPluginMtu: number;
    networkPluginName: string;
    nodeLabels: {[key: string]: string};
    nodeStatusUpdateFrequency: string;
    /**
     * - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
     */
    nonMasqueradeCidr: string;
    nvidiaGpUs: number;
    /**
     * - String - PodCIDR is the CIDR from which we allocate IPs for pods.
     */
    podCidr: string;
    podInfraContainerImage: string;
    podManifestPath: string;
    podPidsLimit: number;
    protectKernelDefaults: boolean;
    readOnlyPort: number;
    reconcileCidr: boolean;
    registerNode: boolean;
    registerSchedulable: boolean;
    registryBurst: number;
    registryPullQps: number;
    requireKubeconfig: boolean;
    resolverConfig: string;
    rootDir: string;
    rotateCertificates: boolean;
    runtimeCgroups: string;
    runtimeRequestTimeout: string;
    seccompProfileRoot: string;
    serializeImagePulls: boolean;
    shutdownGracePeriod: string;
    shutdownGracePeriodCriticalPods: string;
    streamingConnectionIdleTimeout: string;
    systemCgroups: string;
    systemReserved: {[key: string]: string};
    systemReservedCgroup: string;
    taints: string[];
    tlsCertFile: string;
    tlsCipherSuites: string[];
    tlsMinVersion: string;
    tlsPrivateKeyFile: string;
    topologyManagerPolicy: string;
    volumePluginDirectory: string;
    volumeStatsAggPeriod: string;
}

export interface GetClusterKubeletAnonymousAuth {
    value: boolean;
}

export interface GetClusterKubeletCpuCfsQuota {
    value: boolean;
}

export interface GetClusterMasterKubelet {
    allowPrivileged: boolean;
    allowedUnsafeSysctls: string[];
    anonymousAuth?: outputs.GetClusterMasterKubeletAnonymousAuth;
    apiServers: string;
    authenticationTokenWebhook: boolean;
    authenticationTokenWebhookCacheTtl: string;
    authorizationMode: string;
    babysitDaemons: boolean;
    bootstrapKubeconfig: string;
    cgroupDriver: string;
    cgroupRoot: string;
    clientCaFile: string;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    cloudProvider: string;
    clusterDns: string;
    clusterDomain: string;
    configureCbr0: boolean;
    containerLogMaxFiles: number;
    containerLogMaxSize: string;
    cpuCfsQuota?: outputs.GetClusterMasterKubeletCpuCfsQuota;
    cpuCfsQuotaPeriod: string;
    cpuManagerPolicy: string;
    dockerDisableSharedPid: boolean;
    enableCadvisorJsonEndpoints: boolean;
    enableCustomMetrics: boolean;
    enableDebuggingHandlers: boolean;
    enforceNodeAllocatable: string;
    eventBurst: number;
    eventQps: number;
    evictionHard: string;
    evictionMaxPodGracePeriod: number;
    evictionMinimumReclaim: string;
    evictionPressureTransitionPeriod: string;
    evictionSoft: string;
    evictionSoftGracePeriod: string;
    experimentalAllowedUnsafeSysctls: string[];
    failSwapOn: boolean;
    featureGates: {[key: string]: string};
    hairpinMode: string;
    hostnameOverride: string;
    housekeepingInterval: string;
    imageGcHighThresholdPercent: number;
    imageGcLowThresholdPercent: number;
    imagePullProgressDeadline: string;
    kernelMemcgNotification: boolean;
    kubeReserved: {[key: string]: string};
    kubeReservedCgroup: string;
    kubeconfigPath: string;
    kubeletCgroups: string;
    logFormat: string;
    logLevel: number;
    maxPods: number;
    networkPluginMtu: number;
    networkPluginName: string;
    nodeLabels: {[key: string]: string};
    nodeStatusUpdateFrequency: string;
    /**
     * - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
     */
    nonMasqueradeCidr: string;
    nvidiaGpUs: number;
    /**
     * - String - PodCIDR is the CIDR from which we allocate IPs for pods.
     */
    podCidr: string;
    podInfraContainerImage: string;
    podManifestPath: string;
    podPidsLimit: number;
    protectKernelDefaults: boolean;
    readOnlyPort: number;
    reconcileCidr: boolean;
    registerNode: boolean;
    registerSchedulable: boolean;
    registryBurst: number;
    registryPullQps: number;
    requireKubeconfig: boolean;
    resolverConfig: string;
    rootDir: string;
    rotateCertificates: boolean;
    runtimeCgroups: string;
    runtimeRequestTimeout: string;
    seccompProfileRoot: string;
    serializeImagePulls: boolean;
    shutdownGracePeriod: string;
    shutdownGracePeriodCriticalPods: string;
    streamingConnectionIdleTimeout: string;
    systemCgroups: string;
    systemReserved: {[key: string]: string};
    systemReservedCgroup: string;
    taints: string[];
    tlsCertFile: string;
    tlsCipherSuites: string[];
    tlsMinVersion: string;
    tlsPrivateKeyFile: string;
    topologyManagerPolicy: string;
    volumePluginDirectory: string;
    volumeStatsAggPeriod: string;
}

export interface GetClusterMasterKubeletAnonymousAuth {
    value: boolean;
}

export interface GetClusterMasterKubeletCpuCfsQuota {
    value: boolean;
}

export interface GetClusterMetricsServer {
    enabled: boolean;
    image: string;
    insecure: boolean;
}

export interface GetClusterNetworking {
    amazonVpcs: outputs.GetClusterNetworkingAmazonVpc[];
    calicos: outputs.GetClusterNetworkingCalico[];
    canals: outputs.GetClusterNetworkingCanal[];
    cilias: outputs.GetClusterNetworkingCilia[];
    classics: outputs.GetClusterNetworkingClassic[];
    cnis: outputs.GetClusterNetworkingCni[];
    externals: outputs.GetClusterNetworkingExternal[];
    flannels: outputs.GetClusterNetworkingFlannel[];
    gces: outputs.GetClusterNetworkingGce[];
    kopeios: outputs.GetClusterNetworkingKopeio[];
    kubenets: outputs.GetClusterNetworkingKubenet[];
    kuberouters: outputs.GetClusterNetworkingKuberouter[];
    lyftVpcs: outputs.GetClusterNetworkingLyftVpc[];
    romanas: outputs.GetClusterNetworkingRomana[];
    weaves: outputs.GetClusterNetworkingWeafe[];
}

export interface GetClusterNetworkingAmazonVpc {
    envs: outputs.GetClusterNetworkingAmazonVpcEnv[];
    image: string;
    initImage: string;
}

export interface GetClusterNetworkingAmazonVpcEnv {
    /**
     * - String - Name defines the cluster name.
     */
    name: string;
    value: string;
}

export interface GetClusterNetworkingCalico {
    allowIpForwarding: boolean;
    awsSrcDstCheck: string;
    bpfEnabled: boolean;
    bpfExternalServiceMode: string;
    bpfKubeProxyIptablesCleanupEnabled: boolean;
    bpfLogLevel: string;
    chainInsertMode: string;
    cpuRequest: string;
    crossSubnet: boolean;
    encapsulationMode: string;
    ipIpMode: string;
    iptablesBackend: string;
    ipv4AutoDetectionMethod: string;
    ipv6AutoDetectionMethod: string;
    logSeverityScreen: string;
    mtu: number;
    prometheusGoMetricsEnabled: boolean;
    prometheusMetricsEnabled: boolean;
    prometheusMetricsPort: number;
    prometheusProcessMetricsEnabled: boolean;
    registry: string;
    typhaPrometheusMetricsEnabled: boolean;
    typhaPrometheusMetricsPort: number;
    typhaReplicas: number;
    version: string;
    vxlanMode: string;
    wireguardEnabled: boolean;
}

export interface GetClusterNetworkingCanal {
    chainInsertMode: string;
    cpuRequest: string;
    defaultEndpointToHostAction: string;
    flanneldIptablesForwardRules: boolean;
    iptablesBackend: string;
    logSeveritySys: string;
    mtu: number;
    prometheusGoMetricsEnabled: boolean;
    prometheusMetricsEnabled: boolean;
    prometheusMetricsPort: number;
    prometheusProcessMetricsEnabled: boolean;
    typhaPrometheusMetricsEnabled: boolean;
    typhaPrometheusMetricsPort: number;
    typhaReplicas: number;
}

export interface GetClusterNetworkingCilia {
    agentPodAnnotations: {[key: string]: string};
    agentPrometheusPort: number;
    autoDirectNodeRoutes: boolean;
    bpfNeighGlobalMax: number;
    bpfPolicyMapMax: number;
    bpfctGlobalAnyMax: number;
    bpfctGlobalTcpMax: number;
    bpflbAlgorithm: string;
    bpflbMaglevTableSize: string;
    bpflbMapMax: number;
    bpflbSockHostNsOnly: boolean;
    bpfnatGlobalMax: number;
    chainingMode: string;
    clusterName: string;
    cpuRequest: string;
    debug: boolean;
    disableCnpStatusUpdates: boolean;
    disableEndpointCrd: boolean;
    enableBpfMasquerade: boolean;
    enableEncryption: boolean;
    enableEndpointHealthChecking: boolean;
    enableHostReachableServices: boolean;
    enableL7Proxy: boolean;
    enableNodePort: boolean;
    enablePolicy: string;
    enablePrometheusMetrics: boolean;
    enableRemoteNodeIdentity: boolean;
    enableServiceTopology: boolean;
    encryptionType: string;
    etcdManaged: boolean;
    hubbles: outputs.GetClusterNetworkingCiliaHubble[];
    identityAllocationMode: string;
    identityChangeGracePeriod: string;
    installIptablesRules: boolean;
    ipam: string;
    masquerade: boolean;
    memoryRequest: string;
    metrics: string[];
    monitorAggregation: string;
    preallocateBpfMaps: boolean;
    sidecarIstioProxyImage: string;
    toFqdnsDnsRejectResponseCode: string;
    toFqdnsEnablePoller: boolean;
    tunnel: string;
    version: string;
}

export interface GetClusterNetworkingCiliaHubble {
    enabled: boolean;
    metrics: string[];
}

export interface GetClusterNetworkingClassic {
}

export interface GetClusterNetworkingCni {
    usesSecondaryIp: boolean;
}

export interface GetClusterNetworkingExternal {
}

export interface GetClusterNetworkingFlannel {
    backend: string;
    iptablesResyncSeconds: number;
}

export interface GetClusterNetworkingGce {
}

export interface GetClusterNetworkingKopeio {
}

export interface GetClusterNetworkingKubenet {
}

export interface GetClusterNetworkingKuberouter {
}

export interface GetClusterNetworkingLyftVpc {
    subnetTags: {[key: string]: string};
}

export interface GetClusterNetworkingRomana {
    daemonServiceIp: string;
    etcdServiceIp: string;
}

export interface GetClusterNetworkingWeafe {
    connLimit: number;
    cpuLimit: string;
    cpuRequest: string;
    memoryLimit: string;
    memoryRequest: string;
    mtu: number;
    netExtraArgs: string;
    noMasqLocal: number;
    npcCpuLimit: string;
    npcCpuRequest: string;
    npcExtraArgs: string;
    npcMemoryLimit: string;
    npcMemoryRequest: string;
    version: string;
}

export interface GetClusterNodeAuthorization {
    nodeAuthorizers: outputs.GetClusterNodeAuthorizationNodeAuthorizer[];
}

export interface GetClusterNodeAuthorizationNodeAuthorizer {
    authorizer: string;
    features: string[];
    image: string;
    interval: string;
    nodeUrl: string;
    port: number;
    timeout: string;
    tokenTtl: string;
}

export interface GetClusterNodeProblemDetector {
    cpuLimit: string;
    cpuRequest: string;
    enabled: boolean;
    image: string;
    memoryLimit: string;
    memoryRequest: string;
}

export interface GetClusterNodeTerminationHandler {
    cpuRequest: string;
    enablePrometheusMetrics: boolean;
    enableRebalanceDraining: boolean;
    enableRebalanceMonitoring: boolean;
    enableScheduledEventDraining: boolean;
    enableSpotInterruptionDraining: boolean;
    enableSqsTerminationDraining: boolean;
    enabled: boolean;
    excludeFromLoadBalancers: boolean;
    managedAsgTag: string;
    memoryRequest: string;
    version: string;
}

export interface GetClusterNtp {
    managed: boolean;
}

export interface GetClusterPodIdentityWebhook {
    enabled: boolean;
    replicas: number;
}

export interface GetClusterRollingUpdate {
    drainAndTerminate: boolean;
    maxSurge: string;
    maxUnavailable: string;
}

export interface GetClusterSecret {
    clusterCaCert: string;
    clusterCaKey: string;
    dockerConfig: string;
}

export interface GetClusterServiceAccountIssuerDiscovery {
    additionalAudiences: string[];
    discoveryStore: string;
    enableAwsOidcProvider: boolean;
}

export interface GetClusterSnapshotController {
    enabled: boolean;
    installDefaultClass: boolean;
}

export interface GetClusterSubnet {
    additionalRoutes: outputs.GetClusterSubnetAdditionalRoute[];
    cidr: string;
    egress: string;
    ipv6Cidr: string;
    /**
     * - String - Name defines the cluster name.
     */
    name: string;
    providerId: string;
    publicIp: string;
    region: string;
    type: string;
    zone: string;
}

export interface GetClusterSubnetAdditionalRoute {
    cidr: string;
    target: string;
}

export interface GetClusterTagSubnets {
    value: boolean;
}

export interface GetClusterTopology {
    bastions: outputs.GetClusterTopologyBastion[];
    dns: outputs.GetClusterTopologyDn[];
    masters: string;
    nodes: string;
}

export interface GetClusterTopologyBastion {
    bastionPublicName: string;
    idleTimeoutSeconds: number;
    loadBalancers: outputs.GetClusterTopologyBastionLoadBalancer[];
}

export interface GetClusterTopologyBastionLoadBalancer {
    additionalSecurityGroups: string[];
    type: string;
}

export interface GetClusterTopologyDn {
    type: string;
}

export interface GetClusterWarmPool {
    enableLifecycleHook: boolean;
    maxSize: number;
    minSize: number;
}

export interface GetInstanceGroupAdditionalUserData {
    content: string;
    /**
     * - String - Name defines the instance group name.
     */
    name: string;
    type: string;
}

export interface GetInstanceGroupContainerd {
    address: string;
    configOverride: string;
    logLevel: string;
    nvidiaGpus: outputs.GetInstanceGroupContainerdNvidiaGpus[];
    /**
     * - List(String) - Packages specifies additional packages to be installed.
     */
    packages: outputs.GetInstanceGroupContainerdPackage[];
    registryMirrors: outputs.GetInstanceGroupContainerdRegistryMirror[];
    root: string;
    runcs: outputs.GetInstanceGroupContainerdRunc[];
    skipInstall: boolean;
    state: string;
    version: string;
}

export interface GetInstanceGroupContainerdNvidiaGpus {
    driverPackage: string;
    enabled: boolean;
}

export interface GetInstanceGroupContainerdPackage {
    hashAmd64: string;
    hashArm64: string;
    urlAmd64: string;
    urlArm64: string;
}

export interface GetInstanceGroupContainerdRegistryMirror {
    key: string;
    values: string[];
}

export interface GetInstanceGroupContainerdRunc {
    /**
     * - List(String) - Packages specifies additional packages to be installed.
     */
    packages: outputs.GetInstanceGroupContainerdRuncPackage[];
    version: string;
}

export interface GetInstanceGroupContainerdRuncPackage {
    hashAmd64: string;
    hashArm64: string;
    urlAmd64: string;
    urlArm64: string;
}

export interface GetInstanceGroupExternalLoadBalancer {
    loadBalancerName: string;
    targetGroupArn: string;
}

export interface GetInstanceGroupFileAsset {
    content: string;
    isBase64: boolean;
    mode: string;
    /**
     * - String - Name defines the instance group name.
     */
    name: string;
    path: string;
    roles: string[];
}

export interface GetInstanceGroupGuestAccelerator {
    acceleratorCount: number;
    acceleratorType: string;
}

export interface GetInstanceGroupHook {
    befores: string[];
    enabled: boolean;
    execContainers: outputs.GetInstanceGroupHookExecContainer[];
    manifest: string;
    /**
     * - String - Name defines the instance group name.
     */
    name: string;
    requires: string[];
    roles: string[];
    useRawManifest: boolean;
}

export interface GetInstanceGroupHookExecContainer {
    commands: string[];
    environment: {[key: string]: string};
    /**
     * - String - Image is the instance (ami etc) we should use.
     */
    image: string;
}

export interface GetInstanceGroupIam {
    profile: string;
}

export interface GetInstanceGroupInstanceMetadata {
    httpPutResponseHopLimit: number;
    httpTokens: string;
}

export interface GetInstanceGroupKubelet {
    allowPrivileged: boolean;
    allowedUnsafeSysctls: string[];
    anonymousAuth?: outputs.GetInstanceGroupKubeletAnonymousAuth;
    apiServers: string;
    authenticationTokenWebhook: boolean;
    authenticationTokenWebhookCacheTtl: string;
    authorizationMode: string;
    babysitDaemons: boolean;
    bootstrapKubeconfig: string;
    cgroupDriver: string;
    cgroupRoot: string;
    clientCaFile: string;
    cloudProvider: string;
    clusterDns: string;
    clusterDomain: string;
    configureCbr0: boolean;
    containerLogMaxFiles: number;
    containerLogMaxSize: string;
    cpuCfsQuota?: outputs.GetInstanceGroupKubeletCpuCfsQuota;
    cpuCfsQuotaPeriod: string;
    cpuManagerPolicy: string;
    dockerDisableSharedPid: boolean;
    enableCadvisorJsonEndpoints: boolean;
    enableCustomMetrics: boolean;
    enableDebuggingHandlers: boolean;
    enforceNodeAllocatable: string;
    eventBurst: number;
    eventQps: number;
    evictionHard: string;
    evictionMaxPodGracePeriod: number;
    evictionMinimumReclaim: string;
    evictionPressureTransitionPeriod: string;
    evictionSoft: string;
    evictionSoftGracePeriod: string;
    experimentalAllowedUnsafeSysctls: string[];
    failSwapOn: boolean;
    featureGates: {[key: string]: string};
    hairpinMode: string;
    hostnameOverride: string;
    housekeepingInterval: string;
    imageGcHighThresholdPercent: number;
    imageGcLowThresholdPercent: number;
    imagePullProgressDeadline: string;
    kernelMemcgNotification: boolean;
    kubeReserved: {[key: string]: string};
    kubeReservedCgroup: string;
    kubeconfigPath: string;
    kubeletCgroups: string;
    logFormat: string;
    logLevel: number;
    maxPods: number;
    networkPluginMtu: number;
    networkPluginName: string;
    /**
     * - Map(String) - NodeLabels indicates the kubernetes labels for nodes in this instance group.
     */
    nodeLabels: {[key: string]: string};
    nodeStatusUpdateFrequency: string;
    nonMasqueradeCidr: string;
    nvidiaGpUs: number;
    podCidr: string;
    podInfraContainerImage: string;
    podManifestPath: string;
    podPidsLimit: number;
    protectKernelDefaults: boolean;
    readOnlyPort: number;
    reconcileCidr: boolean;
    registerNode: boolean;
    registerSchedulable: boolean;
    registryBurst: number;
    registryPullQps: number;
    requireKubeconfig: boolean;
    resolverConfig: string;
    rootDir: string;
    rotateCertificates: boolean;
    runtimeCgroups: string;
    runtimeRequestTimeout: string;
    seccompProfileRoot: string;
    serializeImagePulls: boolean;
    shutdownGracePeriod: string;
    shutdownGracePeriodCriticalPods: string;
    streamingConnectionIdleTimeout: string;
    systemCgroups: string;
    systemReserved: {[key: string]: string};
    systemReservedCgroup: string;
    /**
     * - List(String) - Taints indicates the kubernetes taints for nodes in this instance group.
     */
    taints: string[];
    tlsCertFile: string;
    tlsCipherSuites: string[];
    tlsMinVersion: string;
    tlsPrivateKeyFile: string;
    topologyManagerPolicy: string;
    volumePluginDirectory: string;
    volumeStatsAggPeriod: string;
}

export interface GetInstanceGroupKubeletAnonymousAuth {
    value: boolean;
}

export interface GetInstanceGroupKubeletCpuCfsQuota {
    value: boolean;
}

export interface GetInstanceGroupMixedInstancesPolicy {
    instanceRequirements: outputs.GetInstanceGroupMixedInstancesPolicyInstanceRequirement[];
    instances: string[];
    onDemandAboveBase?: outputs.GetInstanceGroupMixedInstancesPolicyOnDemandAboveBase;
    onDemandAllocationStrategy: string;
    onDemandBase?: outputs.GetInstanceGroupMixedInstancesPolicyOnDemandBase;
    spotAllocationStrategy: string;
    spotInstancePools: number;
}

export interface GetInstanceGroupMixedInstancesPolicyInstanceRequirement {
    cpus: outputs.GetInstanceGroupMixedInstancesPolicyInstanceRequirementCpus[];
    memories: outputs.GetInstanceGroupMixedInstancesPolicyInstanceRequirementMemory[];
}

export interface GetInstanceGroupMixedInstancesPolicyInstanceRequirementCpus {
    max: string;
    min: string;
}

export interface GetInstanceGroupMixedInstancesPolicyInstanceRequirementMemory {
    max: string;
    min: string;
}

export interface GetInstanceGroupMixedInstancesPolicyOnDemandAboveBase {
    value: number;
}

export interface GetInstanceGroupMixedInstancesPolicyOnDemandBase {
    value: number;
}

export interface GetInstanceGroupRollingUpdate {
    drainAndTerminate: boolean;
    maxSurge: string;
    maxUnavailable: string;
}

export interface GetInstanceGroupVolume {
    deleteOnTermination: boolean;
    device: string;
    encrypted: boolean;
    iops: number;
    key: string;
    size: number;
    throughput: number;
    type: string;
}

export interface GetInstanceGroupVolumeMount {
    device: string;
    filesystem: string;
    formatOptions: string[];
    mountOptions: string[];
    path: string;
}

export interface GetInstanceGroupWarmPool {
    enableLifecycleHook: boolean;
    /**
     * - Int - MaxSize is the maximum size of the pool.
     */
    maxSize: number;
    /**
     * - Int - MinSize is the minimum size of the pool.
     */
    minSize: number;
}

export interface InstanceGroupAdditionalUserData {
    content: string;
    /**
     * - (Force new) - String - Name defines the instance group name.
     */
    name: string;
    type: string;
}

export interface InstanceGroupContainerd {
    address?: string;
    configOverride?: string;
    logLevel?: string;
    nvidiaGpu?: outputs.InstanceGroupContainerdNvidiaGpu;
    /**
     * - List(String) - Packages specifies additional packages to be installed.
     */
    packages?: outputs.InstanceGroupContainerdPackages;
    registryMirrors?: outputs.InstanceGroupContainerdRegistryMirror[];
    root?: string;
    runc?: outputs.InstanceGroupContainerdRunc;
    skipInstall?: boolean;
    state?: string;
    version?: string;
}

export interface InstanceGroupContainerdNvidiaGpu {
    driverPackage?: string;
    enabled?: boolean;
}

export interface InstanceGroupContainerdPackages {
    hashAmd64?: string;
    hashArm64?: string;
    urlAmd64?: string;
    urlArm64?: string;
}

export interface InstanceGroupContainerdRegistryMirror {
    key: string;
    values: string[];
}

export interface InstanceGroupContainerdRunc {
    /**
     * - List(String) - Packages specifies additional packages to be installed.
     */
    packages?: outputs.InstanceGroupContainerdRuncPackages;
    version?: string;
}

export interface InstanceGroupContainerdRuncPackages {
    hashAmd64?: string;
    hashArm64?: string;
    urlAmd64?: string;
    urlArm64?: string;
}

export interface InstanceGroupExternalLoadBalancer {
    loadBalancerName?: string;
    targetGroupArn?: string;
}

export interface InstanceGroupFileAsset {
    content: string;
    isBase64?: boolean;
    mode?: string;
    /**
     * - (Force new) - String - Name defines the instance group name.
     */
    name: string;
    path: string;
    roles?: string[];
}

export interface InstanceGroupGuestAccelerator {
    acceleratorCount?: number;
    acceleratorType?: string;
}

export interface InstanceGroupHook {
    befores?: string[];
    enabled?: boolean;
    execContainer?: outputs.InstanceGroupHookExecContainer;
    manifest?: string;
    /**
     * - (Force new) - String - Name defines the instance group name.
     */
    name: string;
    requires?: string[];
    roles?: string[];
    useRawManifest?: boolean;
}

export interface InstanceGroupHookExecContainer {
    commands?: string[];
    environment?: {[key: string]: string};
    /**
     * - (Computed) - String - Image is the instance (ami etc) we should use.
     */
    image: string;
}

export interface InstanceGroupIam {
    profile: string;
}

export interface InstanceGroupInstanceMetadata {
    httpPutResponseHopLimit?: number;
    httpTokens?: string;
}

export interface InstanceGroupKubelet {
    allowPrivileged?: boolean;
    allowedUnsafeSysctls?: string[];
    anonymousAuth?: outputs.InstanceGroupKubeletAnonymousAuth;
    apiServers?: string;
    authenticationTokenWebhook?: boolean;
    authenticationTokenWebhookCacheTtl?: string;
    authorizationMode?: string;
    babysitDaemons?: boolean;
    bootstrapKubeconfig?: string;
    cgroupDriver?: string;
    cgroupRoot?: string;
    clientCaFile?: string;
    cloudProvider?: string;
    clusterDns?: string;
    clusterDomain?: string;
    configureCbr0?: boolean;
    containerLogMaxFiles?: number;
    containerLogMaxSize?: string;
    cpuCfsQuota?: outputs.InstanceGroupKubeletCpuCfsQuota;
    cpuCfsQuotaPeriod?: string;
    cpuManagerPolicy?: string;
    dockerDisableSharedPid?: boolean;
    enableCadvisorJsonEndpoints?: boolean;
    enableCustomMetrics?: boolean;
    enableDebuggingHandlers?: boolean;
    enforceNodeAllocatable?: string;
    eventBurst?: number;
    eventQps?: number;
    evictionHard?: string;
    evictionMaxPodGracePeriod?: number;
    evictionMinimumReclaim?: string;
    evictionPressureTransitionPeriod?: string;
    evictionSoft?: string;
    evictionSoftGracePeriod?: string;
    experimentalAllowedUnsafeSysctls?: string[];
    failSwapOn?: boolean;
    featureGates?: {[key: string]: string};
    hairpinMode?: string;
    hostnameOverride?: string;
    housekeepingInterval?: string;
    imageGcHighThresholdPercent?: number;
    imageGcLowThresholdPercent?: number;
    imagePullProgressDeadline?: string;
    kernelMemcgNotification?: boolean;
    kubeReserved?: {[key: string]: string};
    kubeReservedCgroup?: string;
    kubeconfigPath?: string;
    kubeletCgroups?: string;
    logFormat?: string;
    logLevel?: number;
    maxPods?: number;
    networkPluginMtu?: number;
    networkPluginName?: string;
    /**
     * - Map(String) - NodeLabels indicates the kubernetes labels for nodes in this instance group.
     */
    nodeLabels?: {[key: string]: string};
    nodeStatusUpdateFrequency?: string;
    nonMasqueradeCidr?: string;
    nvidiaGpUs?: number;
    podCidr?: string;
    podInfraContainerImage?: string;
    podManifestPath?: string;
    podPidsLimit?: number;
    protectKernelDefaults?: boolean;
    readOnlyPort?: number;
    reconcileCidr?: boolean;
    registerNode?: boolean;
    registerSchedulable?: boolean;
    registryBurst?: number;
    registryPullQps?: number;
    requireKubeconfig?: boolean;
    resolverConfig?: string;
    rootDir?: string;
    rotateCertificates?: boolean;
    runtimeCgroups?: string;
    runtimeRequestTimeout?: string;
    seccompProfileRoot?: string;
    serializeImagePulls?: boolean;
    shutdownGracePeriod?: string;
    shutdownGracePeriodCriticalPods?: string;
    streamingConnectionIdleTimeout?: string;
    systemCgroups?: string;
    systemReserved?: {[key: string]: string};
    systemReservedCgroup?: string;
    /**
     * - List(String) - Taints indicates the kubernetes taints for nodes in this instance group.
     */
    taints?: string[];
    tlsCertFile?: string;
    tlsCipherSuites?: string[];
    tlsMinVersion?: string;
    tlsPrivateKeyFile?: string;
    topologyManagerPolicy?: string;
    volumePluginDirectory?: string;
    volumeStatsAggPeriod?: string;
}

export interface InstanceGroupKubeletAnonymousAuth {
    value?: boolean;
}

export interface InstanceGroupKubeletCpuCfsQuota {
    value?: boolean;
}

export interface InstanceGroupMixedInstancesPolicy {
    instanceRequirements?: outputs.InstanceGroupMixedInstancesPolicyInstanceRequirements;
    instances?: string[];
    onDemandAboveBase?: outputs.InstanceGroupMixedInstancesPolicyOnDemandAboveBase;
    onDemandAllocationStrategy?: string;
    onDemandBase?: outputs.InstanceGroupMixedInstancesPolicyOnDemandBase;
    spotAllocationStrategy?: string;
    spotInstancePools?: number;
}

export interface InstanceGroupMixedInstancesPolicyInstanceRequirements {
    cpu?: outputs.InstanceGroupMixedInstancesPolicyInstanceRequirementsCpu;
    memory?: outputs.InstanceGroupMixedInstancesPolicyInstanceRequirementsMemory;
}

export interface InstanceGroupMixedInstancesPolicyInstanceRequirementsCpu {
    max?: string;
    min?: string;
}

export interface InstanceGroupMixedInstancesPolicyInstanceRequirementsMemory {
    max?: string;
    min?: string;
}

export interface InstanceGroupMixedInstancesPolicyOnDemandAboveBase {
    value?: number;
}

export interface InstanceGroupMixedInstancesPolicyOnDemandBase {
    value?: number;
}

export interface InstanceGroupRollingUpdate {
    drainAndTerminate?: boolean;
    maxSurge?: string;
    maxUnavailable?: string;
}

export interface InstanceGroupVolume {
    deleteOnTermination?: boolean;
    device: string;
    encrypted?: boolean;
    iops?: number;
    key?: string;
    size?: number;
    throughput?: number;
    type?: string;
}

export interface InstanceGroupVolumeMount {
    device: string;
    filesystem: string;
    formatOptions?: string[];
    mountOptions?: string[];
    path: string;
}

export interface InstanceGroupWarmPool {
    enableLifecycleHook?: boolean;
    /**
     * - Int - MaxSize is the maximum size of the pool.
     */
    maxSize?: number;
    /**
     * - Int - MinSize is the minimum size of the pool.
     */
    minSize?: number;
}

export namespace config {
    export interface Aws {
        accessKey?: string;
        assumeRole?: outputs.config.AwsAssumeRole;
        profile?: string;
        region?: string;
        s3AccessKey?: string;
        s3Endpoint?: string;
        s3Region?: string;
        s3SecretKey?: string;
        secretKey?: string;
        skipRegionCheck?: boolean;
    }

    export interface AwsAssumeRole {
        roleArn?: string;
    }

    export interface Klog {
        verbosity?: outputs.config.KlogVerbosity;
    }

    export interface KlogVerbosity {
        value?: number;
    }

    export interface Openstack {
        applicationCredentialId?: string;
        applicationCredentialSecret?: string;
        authUrl?: string;
        domainId?: string;
        domainName?: string;
        password?: string;
        projectDomainId?: string;
        projectDomainName?: string;
        projectId?: string;
        projectName?: string;
        regionName?: string;
        tenantId?: string;
        tenantName?: string;
        username?: string;
    }

}
