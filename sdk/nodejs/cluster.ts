// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "./types";
import * as utilities from "./utilities";

/**
 * ## Import
 *
 * You can import an existing cluster by creating a `kops_cluster` configuration
 *
 * ```sh
 *  $ pulumi import kops:index/cluster:Cluster and running the `terraform import` command
 * ```
 *
 *  1. Create a terraform configuration:
 *
 *  hcl
 *
 *  provider "kops" {
 *
 *  state_store = "s3://cluster.example.com"
 *
 *  }
 *
 *  resource "kops_cluster" "cluster" {
 *
 *  name
 *
 * = "cluster.example.com"
 *
 *  // ....
 *
 *  }
 *
 * ```sh
 *  $ pulumi import kops:index/cluster:Cluster
 *
 * Run `terraform import`
 * ```
 *
 * ```sh
 *  $ pulumi import kops:index/cluster:Cluster kops_cluster.cluster cluster.example.com
 * ```
 */
export class Cluster extends pulumi.CustomResource {
    /**
     * Get an existing Cluster resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ClusterState, opts?: pulumi.CustomResourceOptions): Cluster {
        return new Cluster(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'kops:index/cluster:Cluster';

    /**
     * Returns true if the given object is an instance of Cluster.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Cluster {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Cluster.__pulumiType;
    }

    /**
     * - List(String) - AdditionalNetworkCIDRs is a list of additional CIDR used for the AWS VPC<br />or otherwise allocated to k8s. This is a real CIDR, not the internal k8s network<br />On AWS, it maps to any additional CIDRs added to a VPC.
     */
    public readonly additionalNetworkCidrs!: pulumi.Output<string[] | undefined>;
    /**
     * - Map(String) - Additional policies to add for roles.
     */
    public readonly additionalPolicies!: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * - List(String) - AdditionalSANs adds additional Subject Alternate Names to apiserver cert that kops generates.
     */
    public readonly additionalSans!: pulumi.Output<string[] | undefined>;
    /**
     * - List(addon_spec) - Additional addons that should be installed on the cluster.
     */
    public readonly addons!: pulumi.Output<outputs.ClusterAddon[] | undefined>;
    /**
     * - (Sensitive) - String - AdminSshKey defines the cluster admin ssh key.
     */
    public readonly adminSshKey!: pulumi.Output<string | undefined>;
    /**
     * - Map(String) - Annotations is an unstructured key value map stored with a resource that may be<br />set by external tools to store and retrieve arbitrary metadata. They are not<br />queryable and should be preserved when modifying objects.
     */
    public readonly annotations!: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * - accessSpec - API field controls how the API is exposed outside the cluster.
     */
    public readonly api!: pulumi.Output<outputs.ClusterApi | undefined>;
    /**
     * - assets - Assets is alternative locations for files and containers; the API under construction, will remove this comment once this API is fully functional.
     */
    public readonly assets!: pulumi.Output<outputs.ClusterAssets | undefined>;
    /**
     * - authenticationSpec - Authentication field controls how the cluster is configured for authentication.
     */
    public readonly authentication!: pulumi.Output<outputs.ClusterAuthentication | undefined>;
    /**
     * - authorizationSpec - Authorization field controls how the cluster is configured for authorization.
     */
    public readonly authorization!: pulumi.Output<outputs.ClusterAuthorization | undefined>;
    /**
     * - awsLoadBalancerControllerConfig - AWSLoadbalancerControllerConfig determines the AWS LB controller configuration.
     */
    public readonly awsLoadBalancerController!: pulumi.Output<outputs.ClusterAwsLoadBalancerController | undefined>;
    /**
     * - certManagerConfig - CertManager determines the metrics server configuration.
     */
    public readonly certManager!: pulumi.Output<outputs.ClusterCertManager | undefined>;
    /**
     * - String - The Channel we are following.
     */
    public readonly channel!: pulumi.Output<string | undefined>;
    /**
     * - cloud_configuration
     */
    public readonly cloudConfig!: pulumi.Output<outputs.ClusterCloudConfig | undefined>;
    /**
     * - Map(String) - CloudLabels defines additional tags or labels on cloud provider resources.
     */
    public readonly cloudLabels!: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    public readonly cloudProvider!: pulumi.Output<outputs.ClusterCloudProvider>;
    /**
     * - clusterAutoscalerConfig - ClusterAutoscaler defines the cluster autoscaler configuration.
     */
    public readonly clusterAutoscaler!: pulumi.Output<outputs.ClusterClusterAutoscaler | undefined>;
    /**
     * - String - ClusterDNSDomain is the suffix we use for internal DNS names (normally cluster.local).
     */
    public readonly clusterDnsDomain!: pulumi.Output<string | undefined>;
    /**
     * - (Computed) - String - ConfigBase is the path where we store configuration for the cluster<br />This might be different than the location where the cluster spec itself is stored,<br />both because this must be accessible to the cluster,<br />and because it might be on a different cloud or storage system (etcd vs S3).
     */
    public readonly configBase!: pulumi.Output<string>;
    /**
     * - String - ConfigStore is the VFS path to where the configuration (Cluster, InstanceGroups etc) is stored.
     */
    public readonly configStore!: pulumi.Output<string | undefined>;
    /**
     * - String - Container runtime to use for Kubernetes.
     */
    public readonly containerRuntime!: pulumi.Output<string | undefined>;
    /**
     * - containerdConfig - Component configurations.
     */
    public readonly containerd!: pulumi.Output<outputs.ClusterContainerd | undefined>;
    /**
     * - String - DNSZone is the DNS zone we should use when configuring DNS<br />This is because some clouds let us define a managed zone foo.bar, and then have<br />kubernetes.dev.foo.bar, without needing to define dev.foo.bar as a hosted zone.<br />DNSZone will probably be a suffix of the MasterPublicName and MasterInternalName<br />Note that DNSZone can either by the host name of the zone (containing dots),<br />or can be an identifier for the zone.
     */
    public readonly dnsZone!: pulumi.Output<string | undefined>;
    /**
     * - docker_config
     */
    public readonly docker!: pulumi.Output<outputs.ClusterDocker | undefined>;
    /**
     * - egressProxySpec - HTTPProxy defines connection information to support use of a private cluster behind an forward HTTP Proxy.
     */
    public readonly egressProxy!: pulumi.Output<outputs.ClusterEgressProxy | undefined>;
    /**
     * - Bool - EncryptionConfig controls if encryption is enabled.
     */
    public readonly encryptionConfig!: pulumi.Output<boolean | undefined>;
    /**
     * - List(etcd_cluster_spec) - EtcdClusters stores the configuration for each cluster.
     */
    public readonly etcdClusters!: pulumi.Output<outputs.ClusterEtcdCluster[]>;
    /**
     * - cloud_controller_manager_config
     */
    public readonly externalCloudControllerManager!: pulumi.Output<outputs.ClusterExternalCloudControllerManager | undefined>;
    /**
     * - external_dns_config
     */
    public readonly externalDns!: pulumi.Output<outputs.ClusterExternalDns | undefined>;
    /**
     * - Map(List(String)) - ExternalPolicies allows the insertion of pre-existing managed policies on IG Roles.
     */
    public readonly externalPolicies!: pulumi.Output<outputs.ClusterExternalPolicy[] | undefined>;
    /**
     * - List(file_asset_spec) - A collection of files assets for deployed cluster wide.
     */
    public readonly fileAssets!: pulumi.Output<outputs.ClusterFileAsset[] | undefined>;
    /**
     * - List(hook_spec) - Hooks for custom actions e.g. on first installation.
     */
    public readonly hooks!: pulumi.Output<outputs.ClusterHook[] | undefined>;
    /**
     * - (Computed) - iamSpec - IAM field adds control over the IAM security policies applied to resources.
     */
    public readonly iam!: pulumi.Output<outputs.ClusterIam>;
    /**
     * - Bool - IsolateMasters determines whether we should lock down masters so that they are not on the pod network.<br />true is the kube-up behaviour, but it is very surprising: it means that daemonsets only work on the master<br />if they have hostNetwork=true.<br />false is now the default, and it will:<br /> * give the master a normal PodCIDR<br /> * run kube-proxy on the master<br /> * enable debugging handlers on the master, so kubectl logs works.
     */
    public readonly isolateMasters!: pulumi.Output<boolean | undefined>;
    /**
     * - karpenterConfig - Karpenter defines the Karpenter configuration.
     */
    public readonly karpenter!: pulumi.Output<outputs.ClusterKarpenter | undefined>;
    /**
     * - String - KeyStore is the VFS path to where SSL keys and certificates are stored.
     */
    public readonly keyStore!: pulumi.Output<string | undefined>;
    /**
     * - kube_api_server_config
     */
    public readonly kubeApiServer!: pulumi.Output<outputs.ClusterKubeApiServer | undefined>;
    /**
     * - kube_controller_manager_config
     */
    public readonly kubeControllerManager!: pulumi.Output<outputs.ClusterKubeControllerManager | undefined>;
    /**
     * - kube_dns_config
     */
    public readonly kubeDns!: pulumi.Output<outputs.ClusterKubeDns | undefined>;
    /**
     * - kube_proxy_config
     */
    public readonly kubeProxy!: pulumi.Output<outputs.ClusterKubeProxy | undefined>;
    /**
     * - kube_scheduler_config
     */
    public readonly kubeScheduler!: pulumi.Output<outputs.ClusterKubeScheduler | undefined>;
    /**
     * - kubeletConfigSpec - Kubelet is the kubelet configuration for nodes not belonging to the control plane.<br />It can be overridden by the kubelet configuration specified in the instance group.
     */
    public readonly kubelet!: pulumi.Output<outputs.ClusterKubelet | undefined>;
    /**
     * - List(String) - KubernetesAPIAccess is a list of the CIDRs that can access the Kubernetes API endpoint (master HTTPS).
     */
    public readonly kubernetesApiAccesses!: pulumi.Output<string[] | undefined>;
    /**
     * - String - The version of kubernetes to install (optional, and can be a "spec" like stable).
     */
    public readonly kubernetesVersion!: pulumi.Output<string | undefined>;
    /**
     * - Map(String) - Map of string keys and values that can be used to organize and categorize<br />(scope and select) objects. May match selectors of replication controllers<br />and services.
     */
    public readonly labels!: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * - (Computed) - String - MasterInternalName is the internal DNS name for the master nodes.
     */
    public readonly masterInternalName!: pulumi.Output<string>;
    /**
     * - kubeletConfigSpec - MasterKubelet is the kubelet configuration for nodes belonging to the control plane<br />It can be overridden by the kubelet configuration specified in the instance group.
     */
    public readonly masterKubelet!: pulumi.Output<outputs.ClusterMasterKubelet | undefined>;
    /**
     * - (Computed) - String - MasterPublicName is the external DNS name for the master nodes.
     */
    public readonly masterPublicName!: pulumi.Output<string>;
    /**
     * - metricsServerConfig - MetricsServer determines the metrics server configuration.
     */
    public readonly metricsServer!: pulumi.Output<outputs.ClusterMetricsServer | undefined>;
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * - (Computed) - String - NetworkCIDR is the CIDR used for the AWS VPC / DO/ GCE Network, or otherwise allocated to k8s<br />This is a real CIDR, not the internal k8s network<br />On AWS, it maps to the VPC CIDR.  It is not required on GCE.<br />On DO, it maps to the VPC CIDR.
     */
    public readonly networkCidr!: pulumi.Output<string>;
    /**
     * - String - NetworkID is an identifier of a network, if we want to reuse/share an existing network (e.g. an AWS VPC).
     */
    public readonly networkId!: pulumi.Output<string>;
    /**
     * - networkingSpec - Networking configuration.
     */
    public readonly networking!: pulumi.Output<outputs.ClusterNetworking>;
    /**
     * - nodeAuthorizationSpec - NodeAuthorization defined the custom node authorization configuration.
     */
    public readonly nodeAuthorization!: pulumi.Output<outputs.ClusterNodeAuthorization | undefined>;
    /**
     * - List(String) - NodePortAccess is a list of the CIDRs that can access the node ports range (30000-32767).
     */
    public readonly nodePortAccesses!: pulumi.Output<string[] | undefined>;
    /**
     * - nodeProblemDetectorConfig - NodeProblemDetector determines the node problem detector configuration.
     */
    public readonly nodeProblemDetector!: pulumi.Output<outputs.ClusterNodeProblemDetector | undefined>;
    /**
     * - nodeTerminationHandlerConfig - NodeTerminationHandler determines the node termination handler configuration.
     */
    public readonly nodeTerminationHandler!: pulumi.Output<outputs.ClusterNodeTerminationHandler | undefined>;
    /**
     * - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
     */
    public readonly nonMasqueradeCidr!: pulumi.Output<string>;
    /**
     * - ntp_config
     */
    public readonly ntp!: pulumi.Output<outputs.ClusterNtp | undefined>;
    /**
     * - String - PodCIDR is the CIDR from which we allocate IPs for pods.
     */
    public readonly podCidr!: pulumi.Output<string | undefined>;
    /**
     * - podIdentityWebhookConfig - PodIdentityWebhook determines the EKS Pod Identity Webhook configuration.
     */
    public readonly podIdentityWebhook!: pulumi.Output<outputs.ClusterPodIdentityWebhook | undefined>;
    /**
     * - String - Project is the cloud project we should use, required on GCE.
     */
    public readonly project!: pulumi.Output<string | undefined>;
    /**
     * - Int - Revision is incremented every time the resource changes, this is useful for triggering cluster updater.
     */
    public /*out*/ readonly revision!: pulumi.Output<number>;
    /**
     * - rollingUpdate - RollingUpdate defines the default rolling-update settings for instance groups.
     */
    public readonly rollingUpdate!: pulumi.Output<outputs.ClusterRollingUpdate | undefined>;
    /**
     * - String - SecretStore is the VFS path to where secrets are stored.
     */
    public readonly secretStore!: pulumi.Output<string | undefined>;
    /**
     * - clusterSecrets - Secrets defines the cluster secret.
     */
    public readonly secrets!: pulumi.Output<outputs.ClusterSecrets | undefined>;
    /**
     * - serviceAccountIssuerDiscoveryConfig - ServiceAccountIssuerDiscovery configures the OIDC Issuer for ServiceAccounts.
     */
    public readonly serviceAccountIssuerDiscovery!: pulumi.Output<outputs.ClusterServiceAccountIssuerDiscovery | undefined>;
    /**
     * - String - ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services.
     */
    public readonly serviceClusterIpRange!: pulumi.Output<string | undefined>;
    /**
     * - snapshotControllerConfig - SnapshotController defines the CSI Snapshot Controller configuration.
     */
    public readonly snapshotController!: pulumi.Output<outputs.ClusterSnapshotController | undefined>;
    /**
     * - List(String) - SSHAccess is a list of the CIDRs that can access SSH.
     */
    public readonly sshAccesses!: pulumi.Output<string[] | undefined>;
    /**
     * - String - SSHKeyName specifies a preexisting SSH key to use.
     */
    public readonly sshKeyName!: pulumi.Output<string | undefined>;
    /**
     * - List(cluster_subnet_spec) - Configuration of subnets we are targeting.
     */
    public readonly subnets!: pulumi.Output<outputs.ClusterSubnet[]>;
    /**
     * - List(String) - SysctlParameters will configure kernel parameters using sysctl(8). When<br />specified, each parameter must follow the form variable=value, the way<br />it would appear in sysctl.conf.
     */
    public readonly sysctlParameters!: pulumi.Output<string[] | undefined>;
    /**
     * - Bool(Nullable) - TagSubnets controls if tags are added to subnets to enable use by load balancers (AWS only). Default: true.
     */
    public readonly tagSubnets!: pulumi.Output<outputs.ClusterTagSubnets | undefined>;
    /**
     * - topologySpec - Topology defines the type of network topology to use on the cluster - default public<br />This is heavily weighted towards AWS for the time being, but should also be agnostic enough<br />to port out to GCE later if needed.
     */
    public readonly topology!: pulumi.Output<outputs.ClusterTopology>;
    /**
     * - String - UpdatePolicy determines the policy for applying upgrades automatically.<br />Valid values:<br />  'automatic' (default): apply updates automatically (apply OS security upgrades, avoiding rebooting when possible)<br />  'external': do not apply updates automatically; they are applied manually or by an external system.
     */
    public readonly updatePolicy!: pulumi.Output<string | undefined>;
    /**
     * - Bool - UseHostCertificates will mount /etc/ssl/certs to inside needed containers.<br />This is needed if some APIs do have self-signed certs.
     */
    public readonly useHostCertificates!: pulumi.Output<boolean | undefined>;
    /**
     * - warmPoolSpec - WarmPool defines the default warm pool settings for instance groups (AWS only).
     */
    public readonly warmPool!: pulumi.Output<outputs.ClusterWarmPool | undefined>;

    /**
     * Create a Cluster resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ClusterArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ClusterArgs | ClusterState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ClusterState | undefined;
            resourceInputs["additionalNetworkCidrs"] = state ? state.additionalNetworkCidrs : undefined;
            resourceInputs["additionalPolicies"] = state ? state.additionalPolicies : undefined;
            resourceInputs["additionalSans"] = state ? state.additionalSans : undefined;
            resourceInputs["addons"] = state ? state.addons : undefined;
            resourceInputs["adminSshKey"] = state ? state.adminSshKey : undefined;
            resourceInputs["annotations"] = state ? state.annotations : undefined;
            resourceInputs["api"] = state ? state.api : undefined;
            resourceInputs["assets"] = state ? state.assets : undefined;
            resourceInputs["authentication"] = state ? state.authentication : undefined;
            resourceInputs["authorization"] = state ? state.authorization : undefined;
            resourceInputs["awsLoadBalancerController"] = state ? state.awsLoadBalancerController : undefined;
            resourceInputs["certManager"] = state ? state.certManager : undefined;
            resourceInputs["channel"] = state ? state.channel : undefined;
            resourceInputs["cloudConfig"] = state ? state.cloudConfig : undefined;
            resourceInputs["cloudLabels"] = state ? state.cloudLabels : undefined;
            resourceInputs["cloudProvider"] = state ? state.cloudProvider : undefined;
            resourceInputs["clusterAutoscaler"] = state ? state.clusterAutoscaler : undefined;
            resourceInputs["clusterDnsDomain"] = state ? state.clusterDnsDomain : undefined;
            resourceInputs["configBase"] = state ? state.configBase : undefined;
            resourceInputs["configStore"] = state ? state.configStore : undefined;
            resourceInputs["containerRuntime"] = state ? state.containerRuntime : undefined;
            resourceInputs["containerd"] = state ? state.containerd : undefined;
            resourceInputs["dnsZone"] = state ? state.dnsZone : undefined;
            resourceInputs["docker"] = state ? state.docker : undefined;
            resourceInputs["egressProxy"] = state ? state.egressProxy : undefined;
            resourceInputs["encryptionConfig"] = state ? state.encryptionConfig : undefined;
            resourceInputs["etcdClusters"] = state ? state.etcdClusters : undefined;
            resourceInputs["externalCloudControllerManager"] = state ? state.externalCloudControllerManager : undefined;
            resourceInputs["externalDns"] = state ? state.externalDns : undefined;
            resourceInputs["externalPolicies"] = state ? state.externalPolicies : undefined;
            resourceInputs["fileAssets"] = state ? state.fileAssets : undefined;
            resourceInputs["hooks"] = state ? state.hooks : undefined;
            resourceInputs["iam"] = state ? state.iam : undefined;
            resourceInputs["isolateMasters"] = state ? state.isolateMasters : undefined;
            resourceInputs["karpenter"] = state ? state.karpenter : undefined;
            resourceInputs["keyStore"] = state ? state.keyStore : undefined;
            resourceInputs["kubeApiServer"] = state ? state.kubeApiServer : undefined;
            resourceInputs["kubeControllerManager"] = state ? state.kubeControllerManager : undefined;
            resourceInputs["kubeDns"] = state ? state.kubeDns : undefined;
            resourceInputs["kubeProxy"] = state ? state.kubeProxy : undefined;
            resourceInputs["kubeScheduler"] = state ? state.kubeScheduler : undefined;
            resourceInputs["kubelet"] = state ? state.kubelet : undefined;
            resourceInputs["kubernetesApiAccesses"] = state ? state.kubernetesApiAccesses : undefined;
            resourceInputs["kubernetesVersion"] = state ? state.kubernetesVersion : undefined;
            resourceInputs["labels"] = state ? state.labels : undefined;
            resourceInputs["masterInternalName"] = state ? state.masterInternalName : undefined;
            resourceInputs["masterKubelet"] = state ? state.masterKubelet : undefined;
            resourceInputs["masterPublicName"] = state ? state.masterPublicName : undefined;
            resourceInputs["metricsServer"] = state ? state.metricsServer : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["networkCidr"] = state ? state.networkCidr : undefined;
            resourceInputs["networkId"] = state ? state.networkId : undefined;
            resourceInputs["networking"] = state ? state.networking : undefined;
            resourceInputs["nodeAuthorization"] = state ? state.nodeAuthorization : undefined;
            resourceInputs["nodePortAccesses"] = state ? state.nodePortAccesses : undefined;
            resourceInputs["nodeProblemDetector"] = state ? state.nodeProblemDetector : undefined;
            resourceInputs["nodeTerminationHandler"] = state ? state.nodeTerminationHandler : undefined;
            resourceInputs["nonMasqueradeCidr"] = state ? state.nonMasqueradeCidr : undefined;
            resourceInputs["ntp"] = state ? state.ntp : undefined;
            resourceInputs["podCidr"] = state ? state.podCidr : undefined;
            resourceInputs["podIdentityWebhook"] = state ? state.podIdentityWebhook : undefined;
            resourceInputs["project"] = state ? state.project : undefined;
            resourceInputs["revision"] = state ? state.revision : undefined;
            resourceInputs["rollingUpdate"] = state ? state.rollingUpdate : undefined;
            resourceInputs["secretStore"] = state ? state.secretStore : undefined;
            resourceInputs["secrets"] = state ? state.secrets : undefined;
            resourceInputs["serviceAccountIssuerDiscovery"] = state ? state.serviceAccountIssuerDiscovery : undefined;
            resourceInputs["serviceClusterIpRange"] = state ? state.serviceClusterIpRange : undefined;
            resourceInputs["snapshotController"] = state ? state.snapshotController : undefined;
            resourceInputs["sshAccesses"] = state ? state.sshAccesses : undefined;
            resourceInputs["sshKeyName"] = state ? state.sshKeyName : undefined;
            resourceInputs["subnets"] = state ? state.subnets : undefined;
            resourceInputs["sysctlParameters"] = state ? state.sysctlParameters : undefined;
            resourceInputs["tagSubnets"] = state ? state.tagSubnets : undefined;
            resourceInputs["topology"] = state ? state.topology : undefined;
            resourceInputs["updatePolicy"] = state ? state.updatePolicy : undefined;
            resourceInputs["useHostCertificates"] = state ? state.useHostCertificates : undefined;
            resourceInputs["warmPool"] = state ? state.warmPool : undefined;
        } else {
            const args = argsOrState as ClusterArgs | undefined;
            if ((!args || args.cloudProvider === undefined) && !opts.urn) {
                throw new Error("Missing required property 'cloudProvider'");
            }
            if ((!args || args.etcdClusters === undefined) && !opts.urn) {
                throw new Error("Missing required property 'etcdClusters'");
            }
            if ((!args || args.networkId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'networkId'");
            }
            if ((!args || args.networking === undefined) && !opts.urn) {
                throw new Error("Missing required property 'networking'");
            }
            if ((!args || args.subnets === undefined) && !opts.urn) {
                throw new Error("Missing required property 'subnets'");
            }
            if ((!args || args.topology === undefined) && !opts.urn) {
                throw new Error("Missing required property 'topology'");
            }
            resourceInputs["additionalNetworkCidrs"] = args ? args.additionalNetworkCidrs : undefined;
            resourceInputs["additionalPolicies"] = args ? args.additionalPolicies : undefined;
            resourceInputs["additionalSans"] = args ? args.additionalSans : undefined;
            resourceInputs["addons"] = args ? args.addons : undefined;
            resourceInputs["adminSshKey"] = args ? args.adminSshKey : undefined;
            resourceInputs["annotations"] = args ? args.annotations : undefined;
            resourceInputs["api"] = args ? args.api : undefined;
            resourceInputs["assets"] = args ? args.assets : undefined;
            resourceInputs["authentication"] = args ? args.authentication : undefined;
            resourceInputs["authorization"] = args ? args.authorization : undefined;
            resourceInputs["awsLoadBalancerController"] = args ? args.awsLoadBalancerController : undefined;
            resourceInputs["certManager"] = args ? args.certManager : undefined;
            resourceInputs["channel"] = args ? args.channel : undefined;
            resourceInputs["cloudConfig"] = args ? args.cloudConfig : undefined;
            resourceInputs["cloudLabels"] = args ? args.cloudLabels : undefined;
            resourceInputs["cloudProvider"] = args ? args.cloudProvider : undefined;
            resourceInputs["clusterAutoscaler"] = args ? args.clusterAutoscaler : undefined;
            resourceInputs["clusterDnsDomain"] = args ? args.clusterDnsDomain : undefined;
            resourceInputs["configBase"] = args ? args.configBase : undefined;
            resourceInputs["configStore"] = args ? args.configStore : undefined;
            resourceInputs["containerRuntime"] = args ? args.containerRuntime : undefined;
            resourceInputs["containerd"] = args ? args.containerd : undefined;
            resourceInputs["dnsZone"] = args ? args.dnsZone : undefined;
            resourceInputs["docker"] = args ? args.docker : undefined;
            resourceInputs["egressProxy"] = args ? args.egressProxy : undefined;
            resourceInputs["encryptionConfig"] = args ? args.encryptionConfig : undefined;
            resourceInputs["etcdClusters"] = args ? args.etcdClusters : undefined;
            resourceInputs["externalCloudControllerManager"] = args ? args.externalCloudControllerManager : undefined;
            resourceInputs["externalDns"] = args ? args.externalDns : undefined;
            resourceInputs["externalPolicies"] = args ? args.externalPolicies : undefined;
            resourceInputs["fileAssets"] = args ? args.fileAssets : undefined;
            resourceInputs["hooks"] = args ? args.hooks : undefined;
            resourceInputs["iam"] = args ? args.iam : undefined;
            resourceInputs["isolateMasters"] = args ? args.isolateMasters : undefined;
            resourceInputs["karpenter"] = args ? args.karpenter : undefined;
            resourceInputs["keyStore"] = args ? args.keyStore : undefined;
            resourceInputs["kubeApiServer"] = args ? args.kubeApiServer : undefined;
            resourceInputs["kubeControllerManager"] = args ? args.kubeControllerManager : undefined;
            resourceInputs["kubeDns"] = args ? args.kubeDns : undefined;
            resourceInputs["kubeProxy"] = args ? args.kubeProxy : undefined;
            resourceInputs["kubeScheduler"] = args ? args.kubeScheduler : undefined;
            resourceInputs["kubelet"] = args ? args.kubelet : undefined;
            resourceInputs["kubernetesApiAccesses"] = args ? args.kubernetesApiAccesses : undefined;
            resourceInputs["kubernetesVersion"] = args ? args.kubernetesVersion : undefined;
            resourceInputs["labels"] = args ? args.labels : undefined;
            resourceInputs["masterInternalName"] = args ? args.masterInternalName : undefined;
            resourceInputs["masterKubelet"] = args ? args.masterKubelet : undefined;
            resourceInputs["masterPublicName"] = args ? args.masterPublicName : undefined;
            resourceInputs["metricsServer"] = args ? args.metricsServer : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["networkCidr"] = args ? args.networkCidr : undefined;
            resourceInputs["networkId"] = args ? args.networkId : undefined;
            resourceInputs["networking"] = args ? args.networking : undefined;
            resourceInputs["nodeAuthorization"] = args ? args.nodeAuthorization : undefined;
            resourceInputs["nodePortAccesses"] = args ? args.nodePortAccesses : undefined;
            resourceInputs["nodeProblemDetector"] = args ? args.nodeProblemDetector : undefined;
            resourceInputs["nodeTerminationHandler"] = args ? args.nodeTerminationHandler : undefined;
            resourceInputs["nonMasqueradeCidr"] = args ? args.nonMasqueradeCidr : undefined;
            resourceInputs["ntp"] = args ? args.ntp : undefined;
            resourceInputs["podCidr"] = args ? args.podCidr : undefined;
            resourceInputs["podIdentityWebhook"] = args ? args.podIdentityWebhook : undefined;
            resourceInputs["project"] = args ? args.project : undefined;
            resourceInputs["rollingUpdate"] = args ? args.rollingUpdate : undefined;
            resourceInputs["secretStore"] = args ? args.secretStore : undefined;
            resourceInputs["secrets"] = args ? args.secrets : undefined;
            resourceInputs["serviceAccountIssuerDiscovery"] = args ? args.serviceAccountIssuerDiscovery : undefined;
            resourceInputs["serviceClusterIpRange"] = args ? args.serviceClusterIpRange : undefined;
            resourceInputs["snapshotController"] = args ? args.snapshotController : undefined;
            resourceInputs["sshAccesses"] = args ? args.sshAccesses : undefined;
            resourceInputs["sshKeyName"] = args ? args.sshKeyName : undefined;
            resourceInputs["subnets"] = args ? args.subnets : undefined;
            resourceInputs["sysctlParameters"] = args ? args.sysctlParameters : undefined;
            resourceInputs["tagSubnets"] = args ? args.tagSubnets : undefined;
            resourceInputs["topology"] = args ? args.topology : undefined;
            resourceInputs["updatePolicy"] = args ? args.updatePolicy : undefined;
            resourceInputs["useHostCertificates"] = args ? args.useHostCertificates : undefined;
            resourceInputs["warmPool"] = args ? args.warmPool : undefined;
            resourceInputs["revision"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Cluster.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Cluster resources.
 */
export interface ClusterState {
    /**
     * - List(String) - AdditionalNetworkCIDRs is a list of additional CIDR used for the AWS VPC<br />or otherwise allocated to k8s. This is a real CIDR, not the internal k8s network<br />On AWS, it maps to any additional CIDRs added to a VPC.
     */
    additionalNetworkCidrs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * - Map(String) - Additional policies to add for roles.
     */
    additionalPolicies?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * - List(String) - AdditionalSANs adds additional Subject Alternate Names to apiserver cert that kops generates.
     */
    additionalSans?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * - List(addon_spec) - Additional addons that should be installed on the cluster.
     */
    addons?: pulumi.Input<pulumi.Input<inputs.ClusterAddon>[]>;
    /**
     * - (Sensitive) - String - AdminSshKey defines the cluster admin ssh key.
     */
    adminSshKey?: pulumi.Input<string>;
    /**
     * - Map(String) - Annotations is an unstructured key value map stored with a resource that may be<br />set by external tools to store and retrieve arbitrary metadata. They are not<br />queryable and should be preserved when modifying objects.
     */
    annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * - accessSpec - API field controls how the API is exposed outside the cluster.
     */
    api?: pulumi.Input<inputs.ClusterApi>;
    /**
     * - assets - Assets is alternative locations for files and containers; the API under construction, will remove this comment once this API is fully functional.
     */
    assets?: pulumi.Input<inputs.ClusterAssets>;
    /**
     * - authenticationSpec - Authentication field controls how the cluster is configured for authentication.
     */
    authentication?: pulumi.Input<inputs.ClusterAuthentication>;
    /**
     * - authorizationSpec - Authorization field controls how the cluster is configured for authorization.
     */
    authorization?: pulumi.Input<inputs.ClusterAuthorization>;
    /**
     * - awsLoadBalancerControllerConfig - AWSLoadbalancerControllerConfig determines the AWS LB controller configuration.
     */
    awsLoadBalancerController?: pulumi.Input<inputs.ClusterAwsLoadBalancerController>;
    /**
     * - certManagerConfig - CertManager determines the metrics server configuration.
     */
    certManager?: pulumi.Input<inputs.ClusterCertManager>;
    /**
     * - String - The Channel we are following.
     */
    channel?: pulumi.Input<string>;
    /**
     * - cloud_configuration
     */
    cloudConfig?: pulumi.Input<inputs.ClusterCloudConfig>;
    /**
     * - Map(String) - CloudLabels defines additional tags or labels on cloud provider resources.
     */
    cloudLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    cloudProvider?: pulumi.Input<inputs.ClusterCloudProvider>;
    /**
     * - clusterAutoscalerConfig - ClusterAutoscaler defines the cluster autoscaler configuration.
     */
    clusterAutoscaler?: pulumi.Input<inputs.ClusterClusterAutoscaler>;
    /**
     * - String - ClusterDNSDomain is the suffix we use for internal DNS names (normally cluster.local).
     */
    clusterDnsDomain?: pulumi.Input<string>;
    /**
     * - (Computed) - String - ConfigBase is the path where we store configuration for the cluster<br />This might be different than the location where the cluster spec itself is stored,<br />both because this must be accessible to the cluster,<br />and because it might be on a different cloud or storage system (etcd vs S3).
     */
    configBase?: pulumi.Input<string>;
    /**
     * - String - ConfigStore is the VFS path to where the configuration (Cluster, InstanceGroups etc) is stored.
     */
    configStore?: pulumi.Input<string>;
    /**
     * - String - Container runtime to use for Kubernetes.
     */
    containerRuntime?: pulumi.Input<string>;
    /**
     * - containerdConfig - Component configurations.
     */
    containerd?: pulumi.Input<inputs.ClusterContainerd>;
    /**
     * - String - DNSZone is the DNS zone we should use when configuring DNS<br />This is because some clouds let us define a managed zone foo.bar, and then have<br />kubernetes.dev.foo.bar, without needing to define dev.foo.bar as a hosted zone.<br />DNSZone will probably be a suffix of the MasterPublicName and MasterInternalName<br />Note that DNSZone can either by the host name of the zone (containing dots),<br />or can be an identifier for the zone.
     */
    dnsZone?: pulumi.Input<string>;
    /**
     * - docker_config
     */
    docker?: pulumi.Input<inputs.ClusterDocker>;
    /**
     * - egressProxySpec - HTTPProxy defines connection information to support use of a private cluster behind an forward HTTP Proxy.
     */
    egressProxy?: pulumi.Input<inputs.ClusterEgressProxy>;
    /**
     * - Bool - EncryptionConfig controls if encryption is enabled.
     */
    encryptionConfig?: pulumi.Input<boolean>;
    /**
     * - List(etcd_cluster_spec) - EtcdClusters stores the configuration for each cluster.
     */
    etcdClusters?: pulumi.Input<pulumi.Input<inputs.ClusterEtcdCluster>[]>;
    /**
     * - cloud_controller_manager_config
     */
    externalCloudControllerManager?: pulumi.Input<inputs.ClusterExternalCloudControllerManager>;
    /**
     * - external_dns_config
     */
    externalDns?: pulumi.Input<inputs.ClusterExternalDns>;
    /**
     * - Map(List(String)) - ExternalPolicies allows the insertion of pre-existing managed policies on IG Roles.
     */
    externalPolicies?: pulumi.Input<pulumi.Input<inputs.ClusterExternalPolicy>[]>;
    /**
     * - List(file_asset_spec) - A collection of files assets for deployed cluster wide.
     */
    fileAssets?: pulumi.Input<pulumi.Input<inputs.ClusterFileAsset>[]>;
    /**
     * - List(hook_spec) - Hooks for custom actions e.g. on first installation.
     */
    hooks?: pulumi.Input<pulumi.Input<inputs.ClusterHook>[]>;
    /**
     * - (Computed) - iamSpec - IAM field adds control over the IAM security policies applied to resources.
     */
    iam?: pulumi.Input<inputs.ClusterIam>;
    /**
     * - Bool - IsolateMasters determines whether we should lock down masters so that they are not on the pod network.<br />true is the kube-up behaviour, but it is very surprising: it means that daemonsets only work on the master<br />if they have hostNetwork=true.<br />false is now the default, and it will:<br /> * give the master a normal PodCIDR<br /> * run kube-proxy on the master<br /> * enable debugging handlers on the master, so kubectl logs works.
     */
    isolateMasters?: pulumi.Input<boolean>;
    /**
     * - karpenterConfig - Karpenter defines the Karpenter configuration.
     */
    karpenter?: pulumi.Input<inputs.ClusterKarpenter>;
    /**
     * - String - KeyStore is the VFS path to where SSL keys and certificates are stored.
     */
    keyStore?: pulumi.Input<string>;
    /**
     * - kube_api_server_config
     */
    kubeApiServer?: pulumi.Input<inputs.ClusterKubeApiServer>;
    /**
     * - kube_controller_manager_config
     */
    kubeControllerManager?: pulumi.Input<inputs.ClusterKubeControllerManager>;
    /**
     * - kube_dns_config
     */
    kubeDns?: pulumi.Input<inputs.ClusterKubeDns>;
    /**
     * - kube_proxy_config
     */
    kubeProxy?: pulumi.Input<inputs.ClusterKubeProxy>;
    /**
     * - kube_scheduler_config
     */
    kubeScheduler?: pulumi.Input<inputs.ClusterKubeScheduler>;
    /**
     * - kubeletConfigSpec - Kubelet is the kubelet configuration for nodes not belonging to the control plane.<br />It can be overridden by the kubelet configuration specified in the instance group.
     */
    kubelet?: pulumi.Input<inputs.ClusterKubelet>;
    /**
     * - List(String) - KubernetesAPIAccess is a list of the CIDRs that can access the Kubernetes API endpoint (master HTTPS).
     */
    kubernetesApiAccesses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * - String - The version of kubernetes to install (optional, and can be a "spec" like stable).
     */
    kubernetesVersion?: pulumi.Input<string>;
    /**
     * - Map(String) - Map of string keys and values that can be used to organize and categorize<br />(scope and select) objects. May match selectors of replication controllers<br />and services.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * - (Computed) - String - MasterInternalName is the internal DNS name for the master nodes.
     */
    masterInternalName?: pulumi.Input<string>;
    /**
     * - kubeletConfigSpec - MasterKubelet is the kubelet configuration for nodes belonging to the control plane<br />It can be overridden by the kubelet configuration specified in the instance group.
     */
    masterKubelet?: pulumi.Input<inputs.ClusterMasterKubelet>;
    /**
     * - (Computed) - String - MasterPublicName is the external DNS name for the master nodes.
     */
    masterPublicName?: pulumi.Input<string>;
    /**
     * - metricsServerConfig - MetricsServer determines the metrics server configuration.
     */
    metricsServer?: pulumi.Input<inputs.ClusterMetricsServer>;
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name?: pulumi.Input<string>;
    /**
     * - (Computed) - String - NetworkCIDR is the CIDR used for the AWS VPC / DO/ GCE Network, or otherwise allocated to k8s<br />This is a real CIDR, not the internal k8s network<br />On AWS, it maps to the VPC CIDR.  It is not required on GCE.<br />On DO, it maps to the VPC CIDR.
     */
    networkCidr?: pulumi.Input<string>;
    /**
     * - String - NetworkID is an identifier of a network, if we want to reuse/share an existing network (e.g. an AWS VPC).
     */
    networkId?: pulumi.Input<string>;
    /**
     * - networkingSpec - Networking configuration.
     */
    networking?: pulumi.Input<inputs.ClusterNetworking>;
    /**
     * - nodeAuthorizationSpec - NodeAuthorization defined the custom node authorization configuration.
     */
    nodeAuthorization?: pulumi.Input<inputs.ClusterNodeAuthorization>;
    /**
     * - List(String) - NodePortAccess is a list of the CIDRs that can access the node ports range (30000-32767).
     */
    nodePortAccesses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * - nodeProblemDetectorConfig - NodeProblemDetector determines the node problem detector configuration.
     */
    nodeProblemDetector?: pulumi.Input<inputs.ClusterNodeProblemDetector>;
    /**
     * - nodeTerminationHandlerConfig - NodeTerminationHandler determines the node termination handler configuration.
     */
    nodeTerminationHandler?: pulumi.Input<inputs.ClusterNodeTerminationHandler>;
    /**
     * - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
     */
    nonMasqueradeCidr?: pulumi.Input<string>;
    /**
     * - ntp_config
     */
    ntp?: pulumi.Input<inputs.ClusterNtp>;
    /**
     * - String - PodCIDR is the CIDR from which we allocate IPs for pods.
     */
    podCidr?: pulumi.Input<string>;
    /**
     * - podIdentityWebhookConfig - PodIdentityWebhook determines the EKS Pod Identity Webhook configuration.
     */
    podIdentityWebhook?: pulumi.Input<inputs.ClusterPodIdentityWebhook>;
    /**
     * - String - Project is the cloud project we should use, required on GCE.
     */
    project?: pulumi.Input<string>;
    /**
     * - Int - Revision is incremented every time the resource changes, this is useful for triggering cluster updater.
     */
    revision?: pulumi.Input<number>;
    /**
     * - rollingUpdate - RollingUpdate defines the default rolling-update settings for instance groups.
     */
    rollingUpdate?: pulumi.Input<inputs.ClusterRollingUpdate>;
    /**
     * - String - SecretStore is the VFS path to where secrets are stored.
     */
    secretStore?: pulumi.Input<string>;
    /**
     * - clusterSecrets - Secrets defines the cluster secret.
     */
    secrets?: pulumi.Input<inputs.ClusterSecrets>;
    /**
     * - serviceAccountIssuerDiscoveryConfig - ServiceAccountIssuerDiscovery configures the OIDC Issuer for ServiceAccounts.
     */
    serviceAccountIssuerDiscovery?: pulumi.Input<inputs.ClusterServiceAccountIssuerDiscovery>;
    /**
     * - String - ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services.
     */
    serviceClusterIpRange?: pulumi.Input<string>;
    /**
     * - snapshotControllerConfig - SnapshotController defines the CSI Snapshot Controller configuration.
     */
    snapshotController?: pulumi.Input<inputs.ClusterSnapshotController>;
    /**
     * - List(String) - SSHAccess is a list of the CIDRs that can access SSH.
     */
    sshAccesses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * - String - SSHKeyName specifies a preexisting SSH key to use.
     */
    sshKeyName?: pulumi.Input<string>;
    /**
     * - List(cluster_subnet_spec) - Configuration of subnets we are targeting.
     */
    subnets?: pulumi.Input<pulumi.Input<inputs.ClusterSubnet>[]>;
    /**
     * - List(String) - SysctlParameters will configure kernel parameters using sysctl(8). When<br />specified, each parameter must follow the form variable=value, the way<br />it would appear in sysctl.conf.
     */
    sysctlParameters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * - Bool(Nullable) - TagSubnets controls if tags are added to subnets to enable use by load balancers (AWS only). Default: true.
     */
    tagSubnets?: pulumi.Input<inputs.ClusterTagSubnets>;
    /**
     * - topologySpec - Topology defines the type of network topology to use on the cluster - default public<br />This is heavily weighted towards AWS for the time being, but should also be agnostic enough<br />to port out to GCE later if needed.
     */
    topology?: pulumi.Input<inputs.ClusterTopology>;
    /**
     * - String - UpdatePolicy determines the policy for applying upgrades automatically.<br />Valid values:<br />  'automatic' (default): apply updates automatically (apply OS security upgrades, avoiding rebooting when possible)<br />  'external': do not apply updates automatically; they are applied manually or by an external system.
     */
    updatePolicy?: pulumi.Input<string>;
    /**
     * - Bool - UseHostCertificates will mount /etc/ssl/certs to inside needed containers.<br />This is needed if some APIs do have self-signed certs.
     */
    useHostCertificates?: pulumi.Input<boolean>;
    /**
     * - warmPoolSpec - WarmPool defines the default warm pool settings for instance groups (AWS only).
     */
    warmPool?: pulumi.Input<inputs.ClusterWarmPool>;
}

/**
 * The set of arguments for constructing a Cluster resource.
 */
export interface ClusterArgs {
    /**
     * - List(String) - AdditionalNetworkCIDRs is a list of additional CIDR used for the AWS VPC<br />or otherwise allocated to k8s. This is a real CIDR, not the internal k8s network<br />On AWS, it maps to any additional CIDRs added to a VPC.
     */
    additionalNetworkCidrs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * - Map(String) - Additional policies to add for roles.
     */
    additionalPolicies?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * - List(String) - AdditionalSANs adds additional Subject Alternate Names to apiserver cert that kops generates.
     */
    additionalSans?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * - List(addon_spec) - Additional addons that should be installed on the cluster.
     */
    addons?: pulumi.Input<pulumi.Input<inputs.ClusterAddon>[]>;
    /**
     * - (Sensitive) - String - AdminSshKey defines the cluster admin ssh key.
     */
    adminSshKey?: pulumi.Input<string>;
    /**
     * - Map(String) - Annotations is an unstructured key value map stored with a resource that may be<br />set by external tools to store and retrieve arbitrary metadata. They are not<br />queryable and should be preserved when modifying objects.
     */
    annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * - accessSpec - API field controls how the API is exposed outside the cluster.
     */
    api?: pulumi.Input<inputs.ClusterApi>;
    /**
     * - assets - Assets is alternative locations for files and containers; the API under construction, will remove this comment once this API is fully functional.
     */
    assets?: pulumi.Input<inputs.ClusterAssets>;
    /**
     * - authenticationSpec - Authentication field controls how the cluster is configured for authentication.
     */
    authentication?: pulumi.Input<inputs.ClusterAuthentication>;
    /**
     * - authorizationSpec - Authorization field controls how the cluster is configured for authorization.
     */
    authorization?: pulumi.Input<inputs.ClusterAuthorization>;
    /**
     * - awsLoadBalancerControllerConfig - AWSLoadbalancerControllerConfig determines the AWS LB controller configuration.
     */
    awsLoadBalancerController?: pulumi.Input<inputs.ClusterAwsLoadBalancerController>;
    /**
     * - certManagerConfig - CertManager determines the metrics server configuration.
     */
    certManager?: pulumi.Input<inputs.ClusterCertManager>;
    /**
     * - String - The Channel we are following.
     */
    channel?: pulumi.Input<string>;
    /**
     * - cloud_configuration
     */
    cloudConfig?: pulumi.Input<inputs.ClusterCloudConfig>;
    /**
     * - Map(String) - CloudLabels defines additional tags or labels on cloud provider resources.
     */
    cloudLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * - cloudProviderSpec - CloudProvider configures the cloud provider to use.
     */
    cloudProvider: pulumi.Input<inputs.ClusterCloudProvider>;
    /**
     * - clusterAutoscalerConfig - ClusterAutoscaler defines the cluster autoscaler configuration.
     */
    clusterAutoscaler?: pulumi.Input<inputs.ClusterClusterAutoscaler>;
    /**
     * - String - ClusterDNSDomain is the suffix we use for internal DNS names (normally cluster.local).
     */
    clusterDnsDomain?: pulumi.Input<string>;
    /**
     * - (Computed) - String - ConfigBase is the path where we store configuration for the cluster<br />This might be different than the location where the cluster spec itself is stored,<br />both because this must be accessible to the cluster,<br />and because it might be on a different cloud or storage system (etcd vs S3).
     */
    configBase?: pulumi.Input<string>;
    /**
     * - String - ConfigStore is the VFS path to where the configuration (Cluster, InstanceGroups etc) is stored.
     */
    configStore?: pulumi.Input<string>;
    /**
     * - String - Container runtime to use for Kubernetes.
     */
    containerRuntime?: pulumi.Input<string>;
    /**
     * - containerdConfig - Component configurations.
     */
    containerd?: pulumi.Input<inputs.ClusterContainerd>;
    /**
     * - String - DNSZone is the DNS zone we should use when configuring DNS<br />This is because some clouds let us define a managed zone foo.bar, and then have<br />kubernetes.dev.foo.bar, without needing to define dev.foo.bar as a hosted zone.<br />DNSZone will probably be a suffix of the MasterPublicName and MasterInternalName<br />Note that DNSZone can either by the host name of the zone (containing dots),<br />or can be an identifier for the zone.
     */
    dnsZone?: pulumi.Input<string>;
    /**
     * - docker_config
     */
    docker?: pulumi.Input<inputs.ClusterDocker>;
    /**
     * - egressProxySpec - HTTPProxy defines connection information to support use of a private cluster behind an forward HTTP Proxy.
     */
    egressProxy?: pulumi.Input<inputs.ClusterEgressProxy>;
    /**
     * - Bool - EncryptionConfig controls if encryption is enabled.
     */
    encryptionConfig?: pulumi.Input<boolean>;
    /**
     * - List(etcd_cluster_spec) - EtcdClusters stores the configuration for each cluster.
     */
    etcdClusters: pulumi.Input<pulumi.Input<inputs.ClusterEtcdCluster>[]>;
    /**
     * - cloud_controller_manager_config
     */
    externalCloudControllerManager?: pulumi.Input<inputs.ClusterExternalCloudControllerManager>;
    /**
     * - external_dns_config
     */
    externalDns?: pulumi.Input<inputs.ClusterExternalDns>;
    /**
     * - Map(List(String)) - ExternalPolicies allows the insertion of pre-existing managed policies on IG Roles.
     */
    externalPolicies?: pulumi.Input<pulumi.Input<inputs.ClusterExternalPolicy>[]>;
    /**
     * - List(file_asset_spec) - A collection of files assets for deployed cluster wide.
     */
    fileAssets?: pulumi.Input<pulumi.Input<inputs.ClusterFileAsset>[]>;
    /**
     * - List(hook_spec) - Hooks for custom actions e.g. on first installation.
     */
    hooks?: pulumi.Input<pulumi.Input<inputs.ClusterHook>[]>;
    /**
     * - (Computed) - iamSpec - IAM field adds control over the IAM security policies applied to resources.
     */
    iam?: pulumi.Input<inputs.ClusterIam>;
    /**
     * - Bool - IsolateMasters determines whether we should lock down masters so that they are not on the pod network.<br />true is the kube-up behaviour, but it is very surprising: it means that daemonsets only work on the master<br />if they have hostNetwork=true.<br />false is now the default, and it will:<br /> * give the master a normal PodCIDR<br /> * run kube-proxy on the master<br /> * enable debugging handlers on the master, so kubectl logs works.
     */
    isolateMasters?: pulumi.Input<boolean>;
    /**
     * - karpenterConfig - Karpenter defines the Karpenter configuration.
     */
    karpenter?: pulumi.Input<inputs.ClusterKarpenter>;
    /**
     * - String - KeyStore is the VFS path to where SSL keys and certificates are stored.
     */
    keyStore?: pulumi.Input<string>;
    /**
     * - kube_api_server_config
     */
    kubeApiServer?: pulumi.Input<inputs.ClusterKubeApiServer>;
    /**
     * - kube_controller_manager_config
     */
    kubeControllerManager?: pulumi.Input<inputs.ClusterKubeControllerManager>;
    /**
     * - kube_dns_config
     */
    kubeDns?: pulumi.Input<inputs.ClusterKubeDns>;
    /**
     * - kube_proxy_config
     */
    kubeProxy?: pulumi.Input<inputs.ClusterKubeProxy>;
    /**
     * - kube_scheduler_config
     */
    kubeScheduler?: pulumi.Input<inputs.ClusterKubeScheduler>;
    /**
     * - kubeletConfigSpec - Kubelet is the kubelet configuration for nodes not belonging to the control plane.<br />It can be overridden by the kubelet configuration specified in the instance group.
     */
    kubelet?: pulumi.Input<inputs.ClusterKubelet>;
    /**
     * - List(String) - KubernetesAPIAccess is a list of the CIDRs that can access the Kubernetes API endpoint (master HTTPS).
     */
    kubernetesApiAccesses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * - String - The version of kubernetes to install (optional, and can be a "spec" like stable).
     */
    kubernetesVersion?: pulumi.Input<string>;
    /**
     * - Map(String) - Map of string keys and values that can be used to organize and categorize<br />(scope and select) objects. May match selectors of replication controllers<br />and services.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * - (Computed) - String - MasterInternalName is the internal DNS name for the master nodes.
     */
    masterInternalName?: pulumi.Input<string>;
    /**
     * - kubeletConfigSpec - MasterKubelet is the kubelet configuration for nodes belonging to the control plane<br />It can be overridden by the kubelet configuration specified in the instance group.
     */
    masterKubelet?: pulumi.Input<inputs.ClusterMasterKubelet>;
    /**
     * - (Computed) - String - MasterPublicName is the external DNS name for the master nodes.
     */
    masterPublicName?: pulumi.Input<string>;
    /**
     * - metricsServerConfig - MetricsServer determines the metrics server configuration.
     */
    metricsServer?: pulumi.Input<inputs.ClusterMetricsServer>;
    /**
     * - (Force new) - String - Name defines the cluster name.
     */
    name?: pulumi.Input<string>;
    /**
     * - (Computed) - String - NetworkCIDR is the CIDR used for the AWS VPC / DO/ GCE Network, or otherwise allocated to k8s<br />This is a real CIDR, not the internal k8s network<br />On AWS, it maps to the VPC CIDR.  It is not required on GCE.<br />On DO, it maps to the VPC CIDR.
     */
    networkCidr?: pulumi.Input<string>;
    /**
     * - String - NetworkID is an identifier of a network, if we want to reuse/share an existing network (e.g. an AWS VPC).
     */
    networkId: pulumi.Input<string>;
    /**
     * - networkingSpec - Networking configuration.
     */
    networking: pulumi.Input<inputs.ClusterNetworking>;
    /**
     * - nodeAuthorizationSpec - NodeAuthorization defined the custom node authorization configuration.
     */
    nodeAuthorization?: pulumi.Input<inputs.ClusterNodeAuthorization>;
    /**
     * - List(String) - NodePortAccess is a list of the CIDRs that can access the node ports range (30000-32767).
     */
    nodePortAccesses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * - nodeProblemDetectorConfig - NodeProblemDetector determines the node problem detector configuration.
     */
    nodeProblemDetector?: pulumi.Input<inputs.ClusterNodeProblemDetector>;
    /**
     * - nodeTerminationHandlerConfig - NodeTerminationHandler determines the node termination handler configuration.
     */
    nodeTerminationHandler?: pulumi.Input<inputs.ClusterNodeTerminationHandler>;
    /**
     * - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
     */
    nonMasqueradeCidr?: pulumi.Input<string>;
    /**
     * - ntp_config
     */
    ntp?: pulumi.Input<inputs.ClusterNtp>;
    /**
     * - String - PodCIDR is the CIDR from which we allocate IPs for pods.
     */
    podCidr?: pulumi.Input<string>;
    /**
     * - podIdentityWebhookConfig - PodIdentityWebhook determines the EKS Pod Identity Webhook configuration.
     */
    podIdentityWebhook?: pulumi.Input<inputs.ClusterPodIdentityWebhook>;
    /**
     * - String - Project is the cloud project we should use, required on GCE.
     */
    project?: pulumi.Input<string>;
    /**
     * - rollingUpdate - RollingUpdate defines the default rolling-update settings for instance groups.
     */
    rollingUpdate?: pulumi.Input<inputs.ClusterRollingUpdate>;
    /**
     * - String - SecretStore is the VFS path to where secrets are stored.
     */
    secretStore?: pulumi.Input<string>;
    /**
     * - clusterSecrets - Secrets defines the cluster secret.
     */
    secrets?: pulumi.Input<inputs.ClusterSecrets>;
    /**
     * - serviceAccountIssuerDiscoveryConfig - ServiceAccountIssuerDiscovery configures the OIDC Issuer for ServiceAccounts.
     */
    serviceAccountIssuerDiscovery?: pulumi.Input<inputs.ClusterServiceAccountIssuerDiscovery>;
    /**
     * - String - ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services.
     */
    serviceClusterIpRange?: pulumi.Input<string>;
    /**
     * - snapshotControllerConfig - SnapshotController defines the CSI Snapshot Controller configuration.
     */
    snapshotController?: pulumi.Input<inputs.ClusterSnapshotController>;
    /**
     * - List(String) - SSHAccess is a list of the CIDRs that can access SSH.
     */
    sshAccesses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * - String - SSHKeyName specifies a preexisting SSH key to use.
     */
    sshKeyName?: pulumi.Input<string>;
    /**
     * - List(cluster_subnet_spec) - Configuration of subnets we are targeting.
     */
    subnets: pulumi.Input<pulumi.Input<inputs.ClusterSubnet>[]>;
    /**
     * - List(String) - SysctlParameters will configure kernel parameters using sysctl(8). When<br />specified, each parameter must follow the form variable=value, the way<br />it would appear in sysctl.conf.
     */
    sysctlParameters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * - Bool(Nullable) - TagSubnets controls if tags are added to subnets to enable use by load balancers (AWS only). Default: true.
     */
    tagSubnets?: pulumi.Input<inputs.ClusterTagSubnets>;
    /**
     * - topologySpec - Topology defines the type of network topology to use on the cluster - default public<br />This is heavily weighted towards AWS for the time being, but should also be agnostic enough<br />to port out to GCE later if needed.
     */
    topology: pulumi.Input<inputs.ClusterTopology>;
    /**
     * - String - UpdatePolicy determines the policy for applying upgrades automatically.<br />Valid values:<br />  'automatic' (default): apply updates automatically (apply OS security upgrades, avoiding rebooting when possible)<br />  'external': do not apply updates automatically; they are applied manually or by an external system.
     */
    updatePolicy?: pulumi.Input<string>;
    /**
     * - Bool - UseHostCertificates will mount /etc/ssl/certs to inside needed containers.<br />This is needed if some APIs do have self-signed certs.
     */
    useHostCertificates?: pulumi.Input<boolean>;
    /**
     * - warmPoolSpec - WarmPool defines the default warm pool settings for instance groups (AWS only).
     */
    warmPool?: pulumi.Input<inputs.ClusterWarmPool>;
}
