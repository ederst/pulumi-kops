// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "./types";
import * as utilities from "./utilities";

export function getCluster(args: GetClusterArgs, opts?: pulumi.InvokeOptions): Promise<GetClusterResult> {
    if (!opts) {
        opts = {}
    }

    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
    return pulumi.runtime.invoke("kops:index/getCluster:getCluster", {
        "externalPolicies": args.externalPolicies,
        "name": args.name,
        "tagSubnets": args.tagSubnets,
    }, opts);
}

/**
 * A collection of arguments for invoking getCluster.
 */
export interface GetClusterArgs {
    /**
     * - Map(List(String)) - ExternalPolicies allows the insertion of pre-existing managed policies on IG Roles.
     */
    externalPolicies?: inputs.GetClusterExternalPolicy[];
    /**
     * - String - Name defines the cluster name.
     */
    name: string;
    /**
     * - Bool(Nullable) - TagSubnets controls if tags are added to subnets to enable use by load balancers (AWS only). Default: true.
     */
    tagSubnets?: inputs.GetClusterTagSubnets;
}

/**
 * A collection of values returned by getCluster.
 */
export interface GetClusterResult {
    readonly additionalNetworkCidrs: string[];
    readonly additionalPolicies: {[key: string]: string};
    readonly additionalSans: string[];
    readonly addons: outputs.GetClusterAddon[];
    readonly adminSshKey: string;
    readonly annotations: {[key: string]: string};
    readonly apis: outputs.GetClusterApi[];
    readonly assets: outputs.GetClusterAsset[];
    readonly authentications: outputs.GetClusterAuthentication[];
    readonly authorizations: outputs.GetClusterAuthorization[];
    readonly awsLoadBalancerControllers: outputs.GetClusterAwsLoadBalancerController[];
    readonly certManagers: outputs.GetClusterCertManager[];
    readonly channel: string;
    readonly cloudConfigs: outputs.GetClusterCloudConfig[];
    readonly cloudLabels: {[key: string]: string};
    readonly cloudProviders: outputs.GetClusterCloudProvider[];
    readonly clusterAutoscalers: outputs.GetClusterClusterAutoscaler[];
    readonly clusterDnsDomain: string;
    readonly configBase: string;
    readonly configStore: string;
    readonly containerRuntime: string;
    readonly containerds: outputs.GetClusterContainerd[];
    readonly dnsZone: string;
    readonly dockers: outputs.GetClusterDocker[];
    readonly egressProxies: outputs.GetClusterEgressProxy[];
    readonly encryptionConfig: boolean;
    readonly etcdClusters: outputs.GetClusterEtcdCluster[];
    readonly externalCloudControllerManagers: outputs.GetClusterExternalCloudControllerManager[];
    readonly externalDns: outputs.GetClusterExternalDn[];
    readonly externalPolicies: outputs.GetClusterExternalPolicy[];
    readonly fileAssets: outputs.GetClusterFileAsset[];
    readonly hooks: outputs.GetClusterHook[];
    readonly iams: outputs.GetClusterIam[];
    /**
     * The provider-assigned unique ID for this managed resource.
     */
    readonly id: string;
    readonly isolateMasters: boolean;
    readonly karpenters: outputs.GetClusterKarpenter[];
    readonly keyStore: string;
    readonly kubeApiServers: outputs.GetClusterKubeApiServer[];
    readonly kubeControllerManagers: outputs.GetClusterKubeControllerManager[];
    readonly kubeDns: outputs.GetClusterKubeDn[];
    readonly kubeProxies: outputs.GetClusterKubeProxy[];
    readonly kubeSchedulers: outputs.GetClusterKubeScheduler[];
    readonly kubelets: outputs.GetClusterKubelet[];
    readonly kubernetesApiAccesses: string[];
    readonly kubernetesVersion: string;
    readonly labels: {[key: string]: string};
    readonly masterInternalName: string;
    readonly masterKubelets: outputs.GetClusterMasterKubelet[];
    readonly masterPublicName: string;
    readonly metricsServers: outputs.GetClusterMetricsServer[];
    readonly name: string;
    readonly networkCidr: string;
    readonly networkId: string;
    readonly networkings: outputs.GetClusterNetworking[];
    readonly nodeAuthorizations: outputs.GetClusterNodeAuthorization[];
    readonly nodePortAccesses: string[];
    readonly nodeProblemDetectors: outputs.GetClusterNodeProblemDetector[];
    readonly nodeTerminationHandlers: outputs.GetClusterNodeTerminationHandler[];
    readonly nonMasqueradeCidr: string;
    readonly ntps: outputs.GetClusterNtp[];
    readonly podCidr: string;
    readonly podIdentityWebhooks: outputs.GetClusterPodIdentityWebhook[];
    readonly project: string;
    readonly rollingUpdates: outputs.GetClusterRollingUpdate[];
    readonly secretStore: string;
    readonly secrets: outputs.GetClusterSecret[];
    readonly serviceAccountIssuerDiscoveries: outputs.GetClusterServiceAccountIssuerDiscovery[];
    readonly serviceClusterIpRange: string;
    readonly snapshotControllers: outputs.GetClusterSnapshotController[];
    readonly sshAccesses: string[];
    readonly sshKeyName: string;
    readonly subnets: outputs.GetClusterSubnet[];
    readonly sysctlParameters: string[];
    readonly tagSubnets?: outputs.GetClusterTagSubnets;
    readonly topologies: outputs.GetClusterTopology[];
    readonly updatePolicy: string;
    readonly useHostCertificates: boolean;
    readonly warmPools: outputs.GetClusterWarmPool[];
}

export function getClusterOutput(args: GetClusterOutputArgs, opts?: pulumi.InvokeOptions): pulumi.Output<GetClusterResult> {
    return pulumi.output(args).apply(a => getCluster(a, opts))
}

/**
 * A collection of arguments for invoking getCluster.
 */
export interface GetClusterOutputArgs {
    /**
     * - Map(List(String)) - ExternalPolicies allows the insertion of pre-existing managed policies on IG Roles.
     */
    externalPolicies?: pulumi.Input<pulumi.Input<inputs.GetClusterExternalPolicyArgs>[]>;
    /**
     * - String - Name defines the cluster name.
     */
    name: pulumi.Input<string>;
    /**
     * - Bool(Nullable) - TagSubnets controls if tags are added to subnets to enable use by load balancers (AWS only). Default: true.
     */
    tagSubnets?: pulumi.Input<inputs.GetClusterTagSubnetsArgs>;
}
