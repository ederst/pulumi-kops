# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ClusterAddon',
    'ClusterApi',
    'ClusterApiDns',
    'ClusterApiLoadBalancer',
    'ClusterApiLoadBalancerAccessLog',
    'ClusterApiLoadBalancerSubnet',
    'ClusterAssets',
    'ClusterAuthentication',
    'ClusterAuthenticationAws',
    'ClusterAuthenticationAwsIdentityMapping',
    'ClusterAuthenticationKopeio',
    'ClusterAuthorization',
    'ClusterAuthorizationAlwaysAllow',
    'ClusterAuthorizationRbac',
    'ClusterAwsLoadBalancerController',
    'ClusterCertManager',
    'ClusterCloudConfig',
    'ClusterCloudConfigAwsEbsCsiDriver',
    'ClusterCloudConfigGcpPdCsiDriver',
    'ClusterCloudProvider',
    'ClusterCloudProviderAws',
    'ClusterCloudProviderAzure',
    'ClusterCloudProviderDo',
    'ClusterCloudProviderGce',
    'ClusterCloudProviderHetzner',
    'ClusterCloudProviderOpenstack',
    'ClusterCloudProviderOpenstackBlockStorage',
    'ClusterCloudProviderOpenstackLoadbalancer',
    'ClusterCloudProviderOpenstackMetadata',
    'ClusterCloudProviderOpenstackMonitor',
    'ClusterCloudProviderOpenstackNetwork',
    'ClusterCloudProviderOpenstackRouter',
    'ClusterClusterAutoscaler',
    'ClusterContainerd',
    'ClusterContainerdNvidiaGpu',
    'ClusterContainerdPackages',
    'ClusterContainerdRegistryMirror',
    'ClusterContainerdRunc',
    'ClusterContainerdRuncPackages',
    'ClusterDocker',
    'ClusterDockerPackages',
    'ClusterEgressProxy',
    'ClusterEgressProxyHttpProxy',
    'ClusterEtcdCluster',
    'ClusterEtcdClusterBackups',
    'ClusterEtcdClusterManager',
    'ClusterEtcdClusterManagerEnv',
    'ClusterEtcdClusterMember',
    'ClusterExternalCloudControllerManager',
    'ClusterExternalCloudControllerManagerLeaderElection',
    'ClusterExternalDns',
    'ClusterExternalPolicy',
    'ClusterFileAsset',
    'ClusterHook',
    'ClusterHookExecContainer',
    'ClusterIam',
    'ClusterIamServiceAccountExternalPermission',
    'ClusterIamServiceAccountExternalPermissionAws',
    'ClusterKarpenter',
    'ClusterKubeApiServer',
    'ClusterKubeApiServerAnonymousAuth',
    'ClusterKubeControllerManager',
    'ClusterKubeControllerManagerLeaderElection',
    'ClusterKubeDns',
    'ClusterKubeDnsAffinity',
    'ClusterKubeDnsAffinityNodeAffinity',
    'ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression',
    'ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField',
    'ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm',
    'ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression',
    'ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField',
    'ClusterKubeDnsAffinityPodAffinity',
    'ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression',
    'ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector',
    'ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression',
    'ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression',
    'ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector',
    'ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression',
    'ClusterKubeDnsAffinityPodAntiAffinity',
    'ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression',
    'ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector',
    'ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression',
    'ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression',
    'ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector',
    'ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression',
    'ClusterKubeDnsNodeLocalDns',
    'ClusterKubeDnsStubDomain',
    'ClusterKubeDnsToleration',
    'ClusterKubeProxy',
    'ClusterKubeScheduler',
    'ClusterKubeSchedulerLeaderElection',
    'ClusterKubelet',
    'ClusterKubeletAnonymousAuth',
    'ClusterKubeletCpuCfsQuota',
    'ClusterMasterKubelet',
    'ClusterMasterKubeletAnonymousAuth',
    'ClusterMasterKubeletCpuCfsQuota',
    'ClusterMetricsServer',
    'ClusterNetworking',
    'ClusterNetworkingAmazonVpc',
    'ClusterNetworkingAmazonVpcEnv',
    'ClusterNetworkingCalico',
    'ClusterNetworkingCanal',
    'ClusterNetworkingCilium',
    'ClusterNetworkingCiliumHubble',
    'ClusterNetworkingClassic',
    'ClusterNetworkingCni',
    'ClusterNetworkingExternal',
    'ClusterNetworkingFlannel',
    'ClusterNetworkingGce',
    'ClusterNetworkingKopeio',
    'ClusterNetworkingKubenet',
    'ClusterNetworkingKuberouter',
    'ClusterNetworkingLyftVpc',
    'ClusterNetworkingRomana',
    'ClusterNetworkingWeave',
    'ClusterNodeAuthorization',
    'ClusterNodeAuthorizationNodeAuthorizer',
    'ClusterNodeProblemDetector',
    'ClusterNodeTerminationHandler',
    'ClusterNtp',
    'ClusterPodIdentityWebhook',
    'ClusterRollingUpdate',
    'ClusterSecrets',
    'ClusterServiceAccountIssuerDiscovery',
    'ClusterSnapshotController',
    'ClusterSubnet',
    'ClusterSubnetAdditionalRoute',
    'ClusterTagSubnets',
    'ClusterTopology',
    'ClusterTopologyBastion',
    'ClusterTopologyBastionLoadBalancer',
    'ClusterTopologyDns',
    'ClusterUpdaterApply',
    'ClusterUpdaterRollingUpdate',
    'ClusterUpdaterValidate',
    'ClusterWarmPool',
    'InstanceGroupAdditionalUserData',
    'InstanceGroupContainerd',
    'InstanceGroupContainerdNvidiaGpu',
    'InstanceGroupContainerdPackages',
    'InstanceGroupContainerdRegistryMirror',
    'InstanceGroupContainerdRunc',
    'InstanceGroupContainerdRuncPackages',
    'InstanceGroupExternalLoadBalancer',
    'InstanceGroupFileAsset',
    'InstanceGroupGuestAccelerator',
    'InstanceGroupHook',
    'InstanceGroupHookExecContainer',
    'InstanceGroupIam',
    'InstanceGroupInstanceMetadata',
    'InstanceGroupKubelet',
    'InstanceGroupKubeletAnonymousAuth',
    'InstanceGroupKubeletCpuCfsQuota',
    'InstanceGroupMixedInstancesPolicy',
    'InstanceGroupMixedInstancesPolicyInstanceRequirements',
    'InstanceGroupMixedInstancesPolicyInstanceRequirementsCpu',
    'InstanceGroupMixedInstancesPolicyInstanceRequirementsMemory',
    'InstanceGroupMixedInstancesPolicyOnDemandAboveBase',
    'InstanceGroupMixedInstancesPolicyOnDemandBase',
    'InstanceGroupRollingUpdate',
    'InstanceGroupVolume',
    'InstanceGroupVolumeMount',
    'InstanceGroupWarmPool',
    'GetClusterAddonResult',
    'GetClusterApiResult',
    'GetClusterApiDnResult',
    'GetClusterApiLoadBalancerResult',
    'GetClusterApiLoadBalancerAccessLogResult',
    'GetClusterApiLoadBalancerSubnetResult',
    'GetClusterAssetResult',
    'GetClusterAuthenticationResult',
    'GetClusterAuthenticationAwResult',
    'GetClusterAuthenticationAwIdentityMappingResult',
    'GetClusterAuthenticationKopeioResult',
    'GetClusterAuthorizationResult',
    'GetClusterAuthorizationAlwaysAllowResult',
    'GetClusterAuthorizationRbacResult',
    'GetClusterAwsLoadBalancerControllerResult',
    'GetClusterCertManagerResult',
    'GetClusterCloudConfigResult',
    'GetClusterCloudConfigAwsEbsCsiDriverResult',
    'GetClusterCloudConfigGcpPdCsiDriverResult',
    'GetClusterCloudProviderResult',
    'GetClusterCloudProviderAwResult',
    'GetClusterCloudProviderAzureResult',
    'GetClusterCloudProviderDoResult',
    'GetClusterCloudProviderGceResult',
    'GetClusterCloudProviderHetznerResult',
    'GetClusterCloudProviderOpenstackResult',
    'GetClusterCloudProviderOpenstackBlockStorageResult',
    'GetClusterCloudProviderOpenstackLoadbalancerResult',
    'GetClusterCloudProviderOpenstackMetadataResult',
    'GetClusterCloudProviderOpenstackMonitorResult',
    'GetClusterCloudProviderOpenstackNetworkResult',
    'GetClusterCloudProviderOpenstackRouterResult',
    'GetClusterClusterAutoscalerResult',
    'GetClusterContainerdResult',
    'GetClusterContainerdNvidiaGpusResult',
    'GetClusterContainerdPackageResult',
    'GetClusterContainerdRegistryMirrorResult',
    'GetClusterContainerdRuncResult',
    'GetClusterContainerdRuncPackageResult',
    'GetClusterDockerResult',
    'GetClusterDockerPackageResult',
    'GetClusterEgressProxyResult',
    'GetClusterEgressProxyHttpProxyResult',
    'GetClusterEtcdClusterResult',
    'GetClusterEtcdClusterBackupResult',
    'GetClusterEtcdClusterManagerResult',
    'GetClusterEtcdClusterManagerEnvResult',
    'GetClusterEtcdClusterMemberResult',
    'GetClusterExternalCloudControllerManagerResult',
    'GetClusterExternalCloudControllerManagerLeaderElectionResult',
    'GetClusterExternalDnResult',
    'GetClusterExternalPolicyResult',
    'GetClusterFileAssetResult',
    'GetClusterHookResult',
    'GetClusterHookExecContainerResult',
    'GetClusterIamResult',
    'GetClusterIamServiceAccountExternalPermissionResult',
    'GetClusterIamServiceAccountExternalPermissionAwResult',
    'GetClusterKarpenterResult',
    'GetClusterKubeApiServerResult',
    'GetClusterKubeApiServerAnonymousAuthResult',
    'GetClusterKubeControllerManagerResult',
    'GetClusterKubeControllerManagerLeaderElectionResult',
    'GetClusterKubeDnResult',
    'GetClusterKubeDnAffinityResult',
    'GetClusterKubeDnAffinityNodeAffinityResult',
    'GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult',
    'GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceResult',
    'GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionResult',
    'GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldResult',
    'GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult',
    'GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermResult',
    'GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionResult',
    'GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchFieldResult',
    'GetClusterKubeDnAffinityPodAffinityResult',
    'GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult',
    'GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult',
    'GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult',
    'GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult',
    'GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorResult',
    'GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionResult',
    'GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult',
    'GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult',
    'GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult',
    'GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorResult',
    'GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionResult',
    'GetClusterKubeDnAffinityPodAntiAffinityResult',
    'GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult',
    'GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult',
    'GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult',
    'GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult',
    'GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorResult',
    'GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionResult',
    'GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult',
    'GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult',
    'GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult',
    'GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorResult',
    'GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionResult',
    'GetClusterKubeDnNodeLocalDnResult',
    'GetClusterKubeDnStubDomainResult',
    'GetClusterKubeDnTolerationResult',
    'GetClusterKubeProxyResult',
    'GetClusterKubeSchedulerResult',
    'GetClusterKubeSchedulerLeaderElectionResult',
    'GetClusterKubeletResult',
    'GetClusterKubeletAnonymousAuthResult',
    'GetClusterKubeletCpuCfsQuotaResult',
    'GetClusterMasterKubeletResult',
    'GetClusterMasterKubeletAnonymousAuthResult',
    'GetClusterMasterKubeletCpuCfsQuotaResult',
    'GetClusterMetricsServerResult',
    'GetClusterNetworkingResult',
    'GetClusterNetworkingAmazonVpcResult',
    'GetClusterNetworkingAmazonVpcEnvResult',
    'GetClusterNetworkingCalicoResult',
    'GetClusterNetworkingCanalResult',
    'GetClusterNetworkingCiliaResult',
    'GetClusterNetworkingCiliaHubbleResult',
    'GetClusterNetworkingClassicResult',
    'GetClusterNetworkingCniResult',
    'GetClusterNetworkingExternalResult',
    'GetClusterNetworkingFlannelResult',
    'GetClusterNetworkingGceResult',
    'GetClusterNetworkingKopeioResult',
    'GetClusterNetworkingKubenetResult',
    'GetClusterNetworkingKuberouterResult',
    'GetClusterNetworkingLyftVpcResult',
    'GetClusterNetworkingRomanaResult',
    'GetClusterNetworkingWeafeResult',
    'GetClusterNodeAuthorizationResult',
    'GetClusterNodeAuthorizationNodeAuthorizerResult',
    'GetClusterNodeProblemDetectorResult',
    'GetClusterNodeTerminationHandlerResult',
    'GetClusterNtpResult',
    'GetClusterPodIdentityWebhookResult',
    'GetClusterRollingUpdateResult',
    'GetClusterSecretResult',
    'GetClusterServiceAccountIssuerDiscoveryResult',
    'GetClusterSnapshotControllerResult',
    'GetClusterSubnetResult',
    'GetClusterSubnetAdditionalRouteResult',
    'GetClusterTagSubnetsResult',
    'GetClusterTopologyResult',
    'GetClusterTopologyBastionResult',
    'GetClusterTopologyBastionLoadBalancerResult',
    'GetClusterTopologyDnResult',
    'GetClusterWarmPoolResult',
    'GetInstanceGroupAdditionalUserDataResult',
    'GetInstanceGroupContainerdResult',
    'GetInstanceGroupContainerdNvidiaGpusResult',
    'GetInstanceGroupContainerdPackageResult',
    'GetInstanceGroupContainerdRegistryMirrorResult',
    'GetInstanceGroupContainerdRuncResult',
    'GetInstanceGroupContainerdRuncPackageResult',
    'GetInstanceGroupExternalLoadBalancerResult',
    'GetInstanceGroupFileAssetResult',
    'GetInstanceGroupGuestAcceleratorResult',
    'GetInstanceGroupHookResult',
    'GetInstanceGroupHookExecContainerResult',
    'GetInstanceGroupIamResult',
    'GetInstanceGroupInstanceMetadataResult',
    'GetInstanceGroupKubeletResult',
    'GetInstanceGroupKubeletAnonymousAuthResult',
    'GetInstanceGroupKubeletCpuCfsQuotaResult',
    'GetInstanceGroupMixedInstancesPolicyResult',
    'GetInstanceGroupMixedInstancesPolicyInstanceRequirementResult',
    'GetInstanceGroupMixedInstancesPolicyInstanceRequirementCpusResult',
    'GetInstanceGroupMixedInstancesPolicyInstanceRequirementMemoryResult',
    'GetInstanceGroupMixedInstancesPolicyOnDemandAboveBaseResult',
    'GetInstanceGroupMixedInstancesPolicyOnDemandBaseResult',
    'GetInstanceGroupRollingUpdateResult',
    'GetInstanceGroupVolumeResult',
    'GetInstanceGroupVolumeMountResult',
    'GetInstanceGroupWarmPoolResult',
]

@pulumi.output_type
class ClusterAddon(dict):
    def __init__(__self__, *,
                 manifest: str):
        pulumi.set(__self__, "manifest", manifest)

    @property
    @pulumi.getter
    def manifest(self) -> str:
        return pulumi.get(self, "manifest")


@pulumi.output_type
class ClusterApi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadBalancer":
            suggest = "load_balancer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterApi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterApi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterApi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns: Optional['outputs.ClusterApiDns'] = None,
                 load_balancer: Optional['outputs.ClusterApiLoadBalancer'] = None):
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)

    @property
    @pulumi.getter
    def dns(self) -> Optional['outputs.ClusterApiDns']:
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional['outputs.ClusterApiLoadBalancer']:
        return pulumi.get(self, "load_balancer")


@pulumi.output_type
class ClusterApiDns(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClusterApiLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessLog":
            suggest = "access_log"
        elif key == "additionalSecurityGroups":
            suggest = "additional_security_groups"
        elif key == "class":
            suggest = "class_"
        elif key == "crossZoneLoadBalancing":
            suggest = "cross_zone_load_balancing"
        elif key == "idleTimeoutSeconds":
            suggest = "idle_timeout_seconds"
        elif key == "securityGroupOverride":
            suggest = "security_group_override"
        elif key == "sslCertificate":
            suggest = "ssl_certificate"
        elif key == "sslPolicy":
            suggest = "ssl_policy"
        elif key == "useForInternalApi":
            suggest = "use_for_internal_api"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterApiLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterApiLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterApiLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_log: Optional['outputs.ClusterApiLoadBalancerAccessLog'] = None,
                 additional_security_groups: Optional[Sequence[str]] = None,
                 class_: Optional[str] = None,
                 cross_zone_load_balancing: Optional[bool] = None,
                 idle_timeout_seconds: Optional[int] = None,
                 security_group_override: Optional[str] = None,
                 ssl_certificate: Optional[str] = None,
                 ssl_policy: Optional[str] = None,
                 subnets: Optional[Sequence['outputs.ClusterApiLoadBalancerSubnet']] = None,
                 use_for_internal_api: Optional[bool] = None):
        pulumi.set(__self__, "type", type)
        if access_log is not None:
            pulumi.set(__self__, "access_log", access_log)
        if additional_security_groups is not None:
            pulumi.set(__self__, "additional_security_groups", additional_security_groups)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if cross_zone_load_balancing is not None:
            pulumi.set(__self__, "cross_zone_load_balancing", cross_zone_load_balancing)
        if idle_timeout_seconds is not None:
            pulumi.set(__self__, "idle_timeout_seconds", idle_timeout_seconds)
        if security_group_override is not None:
            pulumi.set(__self__, "security_group_override", security_group_override)
        if ssl_certificate is not None:
            pulumi.set(__self__, "ssl_certificate", ssl_certificate)
        if ssl_policy is not None:
            pulumi.set(__self__, "ssl_policy", ssl_policy)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if use_for_internal_api is not None:
            pulumi.set(__self__, "use_for_internal_api", use_for_internal_api)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessLog")
    def access_log(self) -> Optional['outputs.ClusterApiLoadBalancerAccessLog']:
        return pulumi.get(self, "access_log")

    @property
    @pulumi.getter(name="additionalSecurityGroups")
    def additional_security_groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "additional_security_groups")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[str]:
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter(name="crossZoneLoadBalancing")
    def cross_zone_load_balancing(self) -> Optional[bool]:
        return pulumi.get(self, "cross_zone_load_balancing")

    @property
    @pulumi.getter(name="idleTimeoutSeconds")
    def idle_timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "idle_timeout_seconds")

    @property
    @pulumi.getter(name="securityGroupOverride")
    def security_group_override(self) -> Optional[str]:
        return pulumi.get(self, "security_group_override")

    @property
    @pulumi.getter(name="sslCertificate")
    def ssl_certificate(self) -> Optional[str]:
        return pulumi.get(self, "ssl_certificate")

    @property
    @pulumi.getter(name="sslPolicy")
    def ssl_policy(self) -> Optional[str]:
        return pulumi.get(self, "ssl_policy")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence['outputs.ClusterApiLoadBalancerSubnet']]:
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter(name="useForInternalApi")
    def use_for_internal_api(self) -> Optional[bool]:
        return pulumi.get(self, "use_for_internal_api")


@pulumi.output_type
class ClusterApiLoadBalancerAccessLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketPrefix":
            suggest = "bucket_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterApiLoadBalancerAccessLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterApiLoadBalancerAccessLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterApiLoadBalancerAccessLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 interval: Optional[int] = None):
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class ClusterApiLoadBalancerSubnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationId":
            suggest = "allocation_id"
        elif key == "privateIpv4Address":
            suggest = "private_ipv4_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterApiLoadBalancerSubnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterApiLoadBalancerSubnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterApiLoadBalancerSubnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_id: Optional[str] = None,
                 name: Optional[str] = None,
                 private_ipv4_address: Optional[str] = None):
        """
        :param str name: - (Force new) - String - Name defines the cluster name.
        """
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_ipv4_address is not None:
            pulumi.set(__self__, "private_ipv4_address", private_ipv4_address)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[str]:
        return pulumi.get(self, "allocation_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Force new) - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpv4Address")
    def private_ipv4_address(self) -> Optional[str]:
        return pulumi.get(self, "private_ipv4_address")


@pulumi.output_type
class ClusterAssets(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerProxy":
            suggest = "container_proxy"
        elif key == "containerRegistry":
            suggest = "container_registry"
        elif key == "fileRepository":
            suggest = "file_repository"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAssets. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAssets.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAssets.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_proxy: Optional[str] = None,
                 container_registry: Optional[str] = None,
                 file_repository: Optional[str] = None):
        if container_proxy is not None:
            pulumi.set(__self__, "container_proxy", container_proxy)
        if container_registry is not None:
            pulumi.set(__self__, "container_registry", container_registry)
        if file_repository is not None:
            pulumi.set(__self__, "file_repository", file_repository)

    @property
    @pulumi.getter(name="containerProxy")
    def container_proxy(self) -> Optional[str]:
        return pulumi.get(self, "container_proxy")

    @property
    @pulumi.getter(name="containerRegistry")
    def container_registry(self) -> Optional[str]:
        return pulumi.get(self, "container_registry")

    @property
    @pulumi.getter(name="fileRepository")
    def file_repository(self) -> Optional[str]:
        return pulumi.get(self, "file_repository")


@pulumi.output_type
class ClusterAuthentication(dict):
    def __init__(__self__, *,
                 aws: Optional['outputs.ClusterAuthenticationAws'] = None,
                 kopeio: Optional['outputs.ClusterAuthenticationKopeio'] = None):
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if kopeio is not None:
            pulumi.set(__self__, "kopeio", kopeio)

    @property
    @pulumi.getter
    def aws(self) -> Optional['outputs.ClusterAuthenticationAws']:
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter
    def kopeio(self) -> Optional['outputs.ClusterAuthenticationKopeio']:
        return pulumi.get(self, "kopeio")


@pulumi.output_type
class ClusterAuthenticationAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendMode":
            suggest = "backend_mode"
        elif key == "clusterId":
            suggest = "cluster_id"
        elif key == "cpuLimit":
            suggest = "cpu_limit"
        elif key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "identityMappings":
            suggest = "identity_mappings"
        elif key == "memoryLimit":
            suggest = "memory_limit"
        elif key == "memoryRequest":
            suggest = "memory_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAuthenticationAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAuthenticationAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAuthenticationAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_mode: Optional[str] = None,
                 cluster_id: Optional[str] = None,
                 cpu_limit: Optional[str] = None,
                 cpu_request: Optional[str] = None,
                 identity_mappings: Optional[Sequence['outputs.ClusterAuthenticationAwsIdentityMapping']] = None,
                 image: Optional[str] = None,
                 memory_limit: Optional[str] = None,
                 memory_request: Optional[str] = None):
        if backend_mode is not None:
            pulumi.set(__self__, "backend_mode", backend_mode)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if identity_mappings is not None:
            pulumi.set(__self__, "identity_mappings", identity_mappings)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)

    @property
    @pulumi.getter(name="backendMode")
    def backend_mode(self) -> Optional[str]:
        return pulumi.get(self, "backend_mode")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[str]:
        return pulumi.get(self, "cpu_limit")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[str]:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter(name="identityMappings")
    def identity_mappings(self) -> Optional[Sequence['outputs.ClusterAuthenticationAwsIdentityMapping']]:
        return pulumi.get(self, "identity_mappings")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[str]:
        return pulumi.get(self, "memory_limit")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[str]:
        return pulumi.get(self, "memory_request")


@pulumi.output_type
class ClusterAuthenticationAwsIdentityMapping(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 groups: Optional[Sequence[str]] = None,
                 username: Optional[str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class ClusterAuthenticationKopeio(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClusterAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysAllow":
            suggest = "always_allow"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_allow: Optional['outputs.ClusterAuthorizationAlwaysAllow'] = None,
                 rbac: Optional['outputs.ClusterAuthorizationRbac'] = None):
        if always_allow is not None:
            pulumi.set(__self__, "always_allow", always_allow)
        if rbac is not None:
            pulumi.set(__self__, "rbac", rbac)

    @property
    @pulumi.getter(name="alwaysAllow")
    def always_allow(self) -> Optional['outputs.ClusterAuthorizationAlwaysAllow']:
        return pulumi.get(self, "always_allow")

    @property
    @pulumi.getter
    def rbac(self) -> Optional['outputs.ClusterAuthorizationRbac']:
        return pulumi.get(self, "rbac")


@pulumi.output_type
class ClusterAuthorizationAlwaysAllow(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClusterAuthorizationRbac(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClusterAwsLoadBalancerController(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableShield":
            suggest = "enable_shield"
        elif key == "enableWaFv2":
            suggest = "enable_wa_fv2"
        elif key == "enableWaf":
            suggest = "enable_waf"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAwsLoadBalancerController. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAwsLoadBalancerController.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAwsLoadBalancerController.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_shield: Optional[bool] = None,
                 enable_wa_fv2: Optional[bool] = None,
                 enable_waf: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 version: Optional[str] = None):
        if enable_shield is not None:
            pulumi.set(__self__, "enable_shield", enable_shield)
        if enable_wa_fv2 is not None:
            pulumi.set(__self__, "enable_wa_fv2", enable_wa_fv2)
        if enable_waf is not None:
            pulumi.set(__self__, "enable_waf", enable_waf)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="enableShield")
    def enable_shield(self) -> Optional[bool]:
        return pulumi.get(self, "enable_shield")

    @property
    @pulumi.getter(name="enableWaFv2")
    def enable_wa_fv2(self) -> Optional[bool]:
        return pulumi.get(self, "enable_wa_fv2")

    @property
    @pulumi.getter(name="enableWaf")
    def enable_waf(self) -> Optional[bool]:
        return pulumi.get(self, "enable_waf")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterCertManager(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultIssuer":
            suggest = "default_issuer"
        elif key == "hostedZoneIds":
            suggest = "hosted_zone_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCertManager. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCertManager.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCertManager.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 managed: bool,
                 default_issuer: Optional[str] = None,
                 hosted_zone_ids: Optional[Sequence[str]] = None,
                 image: Optional[str] = None,
                 nameservers: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "managed", managed)
        if default_issuer is not None:
            pulumi.set(__self__, "default_issuer", default_issuer)
        if hosted_zone_ids is not None:
            pulumi.set(__self__, "hosted_zone_ids", hosted_zone_ids)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if nameservers is not None:
            pulumi.set(__self__, "nameservers", nameservers)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def managed(self) -> bool:
        return pulumi.get(self, "managed")

    @property
    @pulumi.getter(name="defaultIssuer")
    def default_issuer(self) -> Optional[str]:
        return pulumi.get(self, "default_issuer")

    @property
    @pulumi.getter(name="hostedZoneIds")
    def hosted_zone_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "hosted_zone_ids")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def nameservers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "nameservers")


@pulumi.output_type
class ClusterCloudConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsEbsCsiDriver":
            suggest = "aws_ebs_csi_driver"
        elif key == "disableSecurityGroupIngress":
            suggest = "disable_security_group_ingress"
        elif key == "elbSecurityGroup":
            suggest = "elb_security_group"
        elif key == "gceServiceAccount":
            suggest = "gce_service_account"
        elif key == "gcpPdCsiDriver":
            suggest = "gcp_pd_csi_driver"
        elif key == "manageStorageClasses":
            suggest = "manage_storage_classes"
        elif key == "nodeInstancePrefix":
            suggest = "node_instance_prefix"
        elif key == "nodeIpFamilies":
            suggest = "node_ip_families"
        elif key == "nodeTags":
            suggest = "node_tags"
        elif key == "spotinstOrientation":
            suggest = "spotinst_orientation"
        elif key == "spotinstProduct":
            suggest = "spotinst_product"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_ebs_csi_driver: Optional['outputs.ClusterCloudConfigAwsEbsCsiDriver'] = None,
                 disable_security_group_ingress: Optional[bool] = None,
                 elb_security_group: Optional[str] = None,
                 gce_service_account: Optional[str] = None,
                 gcp_pd_csi_driver: Optional['outputs.ClusterCloudConfigGcpPdCsiDriver'] = None,
                 manage_storage_classes: Optional[bool] = None,
                 multizone: Optional[bool] = None,
                 node_instance_prefix: Optional[str] = None,
                 node_ip_families: Optional[Sequence[str]] = None,
                 node_tags: Optional[str] = None,
                 spotinst_orientation: Optional[str] = None,
                 spotinst_product: Optional[str] = None):
        if aws_ebs_csi_driver is not None:
            pulumi.set(__self__, "aws_ebs_csi_driver", aws_ebs_csi_driver)
        if disable_security_group_ingress is not None:
            pulumi.set(__self__, "disable_security_group_ingress", disable_security_group_ingress)
        if elb_security_group is not None:
            pulumi.set(__self__, "elb_security_group", elb_security_group)
        if gce_service_account is not None:
            pulumi.set(__self__, "gce_service_account", gce_service_account)
        if gcp_pd_csi_driver is not None:
            pulumi.set(__self__, "gcp_pd_csi_driver", gcp_pd_csi_driver)
        if manage_storage_classes is not None:
            pulumi.set(__self__, "manage_storage_classes", manage_storage_classes)
        if multizone is not None:
            pulumi.set(__self__, "multizone", multizone)
        if node_instance_prefix is not None:
            pulumi.set(__self__, "node_instance_prefix", node_instance_prefix)
        if node_ip_families is not None:
            pulumi.set(__self__, "node_ip_families", node_ip_families)
        if node_tags is not None:
            pulumi.set(__self__, "node_tags", node_tags)
        if spotinst_orientation is not None:
            pulumi.set(__self__, "spotinst_orientation", spotinst_orientation)
        if spotinst_product is not None:
            pulumi.set(__self__, "spotinst_product", spotinst_product)

    @property
    @pulumi.getter(name="awsEbsCsiDriver")
    def aws_ebs_csi_driver(self) -> Optional['outputs.ClusterCloudConfigAwsEbsCsiDriver']:
        return pulumi.get(self, "aws_ebs_csi_driver")

    @property
    @pulumi.getter(name="disableSecurityGroupIngress")
    def disable_security_group_ingress(self) -> Optional[bool]:
        return pulumi.get(self, "disable_security_group_ingress")

    @property
    @pulumi.getter(name="elbSecurityGroup")
    def elb_security_group(self) -> Optional[str]:
        return pulumi.get(self, "elb_security_group")

    @property
    @pulumi.getter(name="gceServiceAccount")
    def gce_service_account(self) -> Optional[str]:
        return pulumi.get(self, "gce_service_account")

    @property
    @pulumi.getter(name="gcpPdCsiDriver")
    def gcp_pd_csi_driver(self) -> Optional['outputs.ClusterCloudConfigGcpPdCsiDriver']:
        return pulumi.get(self, "gcp_pd_csi_driver")

    @property
    @pulumi.getter(name="manageStorageClasses")
    def manage_storage_classes(self) -> Optional[bool]:
        return pulumi.get(self, "manage_storage_classes")

    @property
    @pulumi.getter
    def multizone(self) -> Optional[bool]:
        return pulumi.get(self, "multizone")

    @property
    @pulumi.getter(name="nodeInstancePrefix")
    def node_instance_prefix(self) -> Optional[str]:
        return pulumi.get(self, "node_instance_prefix")

    @property
    @pulumi.getter(name="nodeIpFamilies")
    def node_ip_families(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "node_ip_families")

    @property
    @pulumi.getter(name="nodeTags")
    def node_tags(self) -> Optional[str]:
        return pulumi.get(self, "node_tags")

    @property
    @pulumi.getter(name="spotinstOrientation")
    def spotinst_orientation(self) -> Optional[str]:
        return pulumi.get(self, "spotinst_orientation")

    @property
    @pulumi.getter(name="spotinstProduct")
    def spotinst_product(self) -> Optional[str]:
        return pulumi.get(self, "spotinst_product")


@pulumi.output_type
class ClusterCloudConfigAwsEbsCsiDriver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podAnnotations":
            suggest = "pod_annotations"
        elif key == "volumeAttachLimit":
            suggest = "volume_attach_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudConfigAwsEbsCsiDriver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudConfigAwsEbsCsiDriver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudConfigAwsEbsCsiDriver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 managed: Optional[bool] = None,
                 pod_annotations: Optional[Mapping[str, str]] = None,
                 version: Optional[str] = None,
                 volume_attach_limit: Optional[int] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if managed is not None:
            pulumi.set(__self__, "managed", managed)
        if pod_annotations is not None:
            pulumi.set(__self__, "pod_annotations", pod_annotations)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if volume_attach_limit is not None:
            pulumi.set(__self__, "volume_attach_limit", volume_attach_limit)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def managed(self) -> Optional[bool]:
        return pulumi.get(self, "managed")

    @property
    @pulumi.getter(name="podAnnotations")
    def pod_annotations(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "pod_annotations")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="volumeAttachLimit")
    def volume_attach_limit(self) -> Optional[int]:
        return pulumi.get(self, "volume_attach_limit")


@pulumi.output_type
class ClusterCloudConfigGcpPdCsiDriver(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterCloudProvider(dict):
    def __init__(__self__, *,
                 aws: Optional['outputs.ClusterCloudProviderAws'] = None,
                 azure: Optional['outputs.ClusterCloudProviderAzure'] = None,
                 do: Optional['outputs.ClusterCloudProviderDo'] = None,
                 gce: Optional['outputs.ClusterCloudProviderGce'] = None,
                 hetzner: Optional['outputs.ClusterCloudProviderHetzner'] = None,
                 openstack: Optional['outputs.ClusterCloudProviderOpenstack'] = None):
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if azure is not None:
            pulumi.set(__self__, "azure", azure)
        if do is not None:
            pulumi.set(__self__, "do", do)
        if gce is not None:
            pulumi.set(__self__, "gce", gce)
        if hetzner is not None:
            pulumi.set(__self__, "hetzner", hetzner)
        if openstack is not None:
            pulumi.set(__self__, "openstack", openstack)

    @property
    @pulumi.getter
    def aws(self) -> Optional['outputs.ClusterCloudProviderAws']:
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter
    def azure(self) -> Optional['outputs.ClusterCloudProviderAzure']:
        return pulumi.get(self, "azure")

    @property
    @pulumi.getter
    def do(self) -> Optional['outputs.ClusterCloudProviderDo']:
        return pulumi.get(self, "do")

    @property
    @pulumi.getter
    def gce(self) -> Optional['outputs.ClusterCloudProviderGce']:
        return pulumi.get(self, "gce")

    @property
    @pulumi.getter
    def hetzner(self) -> Optional['outputs.ClusterCloudProviderHetzner']:
        return pulumi.get(self, "hetzner")

    @property
    @pulumi.getter
    def openstack(self) -> Optional['outputs.ClusterCloudProviderOpenstack']:
        return pulumi.get(self, "openstack")


@pulumi.output_type
class ClusterCloudProviderAws(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClusterCloudProviderAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUser":
            suggest = "admin_user"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "routeTableName":
            suggest = "route_table_name"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_user: Optional[str] = None,
                 resource_group_name: Optional[str] = None,
                 route_table_name: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        if admin_user is not None:
            pulumi.set(__self__, "admin_user", admin_user)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if route_table_name is not None:
            pulumi.set(__self__, "route_table_name", route_table_name)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="adminUser")
    def admin_user(self) -> Optional[str]:
        return pulumi.get(self, "admin_user")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[str]:
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="routeTableName")
    def route_table_name(self) -> Optional[str]:
        return pulumi.get(self, "route_table_name")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ClusterCloudProviderDo(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClusterCloudProviderGce(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClusterCloudProviderHetzner(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClusterCloudProviderOpenstack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockStorage":
            suggest = "block_storage"
        elif key == "insecureSkipVerify":
            suggest = "insecure_skip_verify"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_storage: Optional['outputs.ClusterCloudProviderOpenstackBlockStorage'] = None,
                 insecure_skip_verify: Optional[bool] = None,
                 loadbalancer: Optional['outputs.ClusterCloudProviderOpenstackLoadbalancer'] = None,
                 metadata: Optional['outputs.ClusterCloudProviderOpenstackMetadata'] = None,
                 monitor: Optional['outputs.ClusterCloudProviderOpenstackMonitor'] = None,
                 network: Optional['outputs.ClusterCloudProviderOpenstackNetwork'] = None,
                 router: Optional['outputs.ClusterCloudProviderOpenstackRouter'] = None):
        if block_storage is not None:
            pulumi.set(__self__, "block_storage", block_storage)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if loadbalancer is not None:
            pulumi.set(__self__, "loadbalancer", loadbalancer)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if monitor is not None:
            pulumi.set(__self__, "monitor", monitor)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if router is not None:
            pulumi.set(__self__, "router", router)

    @property
    @pulumi.getter(name="blockStorage")
    def block_storage(self) -> Optional['outputs.ClusterCloudProviderOpenstackBlockStorage']:
        return pulumi.get(self, "block_storage")

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[bool]:
        return pulumi.get(self, "insecure_skip_verify")

    @property
    @pulumi.getter
    def loadbalancer(self) -> Optional['outputs.ClusterCloudProviderOpenstackLoadbalancer']:
        return pulumi.get(self, "loadbalancer")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.ClusterCloudProviderOpenstackMetadata']:
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def monitor(self) -> Optional['outputs.ClusterCloudProviderOpenstackMonitor']:
        return pulumi.get(self, "monitor")

    @property
    @pulumi.getter
    def network(self) -> Optional['outputs.ClusterCloudProviderOpenstackNetwork']:
        return pulumi.get(self, "network")

    @property
    @pulumi.getter
    def router(self) -> Optional['outputs.ClusterCloudProviderOpenstackRouter']:
        return pulumi.get(self, "router")


@pulumi.output_type
class ClusterCloudProviderOpenstackBlockStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createStorageClass":
            suggest = "create_storage_class"
        elif key == "csiPluginImage":
            suggest = "csi_plugin_image"
        elif key == "csiTopologySupport":
            suggest = "csi_topology_support"
        elif key == "ignoreAz":
            suggest = "ignore_az"
        elif key == "overrideAz":
            suggest = "override_az"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackBlockStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackBlockStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackBlockStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_storage_class: Optional[bool] = None,
                 csi_plugin_image: Optional[str] = None,
                 csi_topology_support: Optional[bool] = None,
                 ignore_az: Optional[bool] = None,
                 override_az: Optional[str] = None,
                 version: Optional[str] = None):
        if create_storage_class is not None:
            pulumi.set(__self__, "create_storage_class", create_storage_class)
        if csi_plugin_image is not None:
            pulumi.set(__self__, "csi_plugin_image", csi_plugin_image)
        if csi_topology_support is not None:
            pulumi.set(__self__, "csi_topology_support", csi_topology_support)
        if ignore_az is not None:
            pulumi.set(__self__, "ignore_az", ignore_az)
        if override_az is not None:
            pulumi.set(__self__, "override_az", override_az)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="createStorageClass")
    def create_storage_class(self) -> Optional[bool]:
        return pulumi.get(self, "create_storage_class")

    @property
    @pulumi.getter(name="csiPluginImage")
    def csi_plugin_image(self) -> Optional[str]:
        return pulumi.get(self, "csi_plugin_image")

    @property
    @pulumi.getter(name="csiTopologySupport")
    def csi_topology_support(self) -> Optional[bool]:
        return pulumi.get(self, "csi_topology_support")

    @property
    @pulumi.getter(name="ignoreAz")
    def ignore_az(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_az")

    @property
    @pulumi.getter(name="overrideAz")
    def override_az(self) -> Optional[str]:
        return pulumi.get(self, "override_az")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterCloudProviderOpenstackLoadbalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIngressHostname":
            suggest = "enable_ingress_hostname"
        elif key == "floatingNetwork":
            suggest = "floating_network"
        elif key == "floatingNetworkId":
            suggest = "floating_network_id"
        elif key == "floatingSubnet":
            suggest = "floating_subnet"
        elif key == "ingressHostnameSuffix":
            suggest = "ingress_hostname_suffix"
        elif key == "manageSecGroups":
            suggest = "manage_sec_groups"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "useOctavia":
            suggest = "use_octavia"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackLoadbalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackLoadbalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackLoadbalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_ingress_hostname: Optional[bool] = None,
                 floating_network: Optional[str] = None,
                 floating_network_id: Optional[str] = None,
                 floating_subnet: Optional[str] = None,
                 ingress_hostname_suffix: Optional[str] = None,
                 manage_sec_groups: Optional[bool] = None,
                 method: Optional[str] = None,
                 provider: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 use_octavia: Optional[bool] = None):
        if enable_ingress_hostname is not None:
            pulumi.set(__self__, "enable_ingress_hostname", enable_ingress_hostname)
        if floating_network is not None:
            pulumi.set(__self__, "floating_network", floating_network)
        if floating_network_id is not None:
            pulumi.set(__self__, "floating_network_id", floating_network_id)
        if floating_subnet is not None:
            pulumi.set(__self__, "floating_subnet", floating_subnet)
        if ingress_hostname_suffix is not None:
            pulumi.set(__self__, "ingress_hostname_suffix", ingress_hostname_suffix)
        if manage_sec_groups is not None:
            pulumi.set(__self__, "manage_sec_groups", manage_sec_groups)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if use_octavia is not None:
            pulumi.set(__self__, "use_octavia", use_octavia)

    @property
    @pulumi.getter(name="enableIngressHostname")
    def enable_ingress_hostname(self) -> Optional[bool]:
        return pulumi.get(self, "enable_ingress_hostname")

    @property
    @pulumi.getter(name="floatingNetwork")
    def floating_network(self) -> Optional[str]:
        return pulumi.get(self, "floating_network")

    @property
    @pulumi.getter(name="floatingNetworkId")
    def floating_network_id(self) -> Optional[str]:
        return pulumi.get(self, "floating_network_id")

    @property
    @pulumi.getter(name="floatingSubnet")
    def floating_subnet(self) -> Optional[str]:
        return pulumi.get(self, "floating_subnet")

    @property
    @pulumi.getter(name="ingressHostnameSuffix")
    def ingress_hostname_suffix(self) -> Optional[str]:
        return pulumi.get(self, "ingress_hostname_suffix")

    @property
    @pulumi.getter(name="manageSecGroups")
    def manage_sec_groups(self) -> Optional[bool]:
        return pulumi.get(self, "manage_sec_groups")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="useOctavia")
    def use_octavia(self) -> Optional[bool]:
        return pulumi.get(self, "use_octavia")


@pulumi.output_type
class ClusterCloudProviderOpenstackMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configDrive":
            suggest = "config_drive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_drive: Optional[bool] = None):
        if config_drive is not None:
            pulumi.set(__self__, "config_drive", config_drive)

    @property
    @pulumi.getter(name="configDrive")
    def config_drive(self) -> Optional[bool]:
        return pulumi.get(self, "config_drive")


@pulumi.output_type
class ClusterCloudProviderOpenstackMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRetries":
            suggest = "max_retries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay: Optional[str] = None,
                 max_retries: Optional[int] = None,
                 timeout: Optional[str] = None):
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def delay(self) -> Optional[str]:
        return pulumi.get(self, "delay")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[int]:
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ClusterCloudProviderOpenstackNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZoneHints":
            suggest = "availability_zone_hints"
        elif key == "internalNetworkNames":
            suggest = "internal_network_names"
        elif key == "ipv6SupportDisabled":
            suggest = "ipv6_support_disabled"
        elif key == "publicNetworkNames":
            suggest = "public_network_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone_hints: Optional[Sequence[str]] = None,
                 internal_network_names: Optional[Sequence[str]] = None,
                 ipv6_support_disabled: Optional[bool] = None,
                 public_network_names: Optional[Sequence[str]] = None):
        if availability_zone_hints is not None:
            pulumi.set(__self__, "availability_zone_hints", availability_zone_hints)
        if internal_network_names is not None:
            pulumi.set(__self__, "internal_network_names", internal_network_names)
        if ipv6_support_disabled is not None:
            pulumi.set(__self__, "ipv6_support_disabled", ipv6_support_disabled)
        if public_network_names is not None:
            pulumi.set(__self__, "public_network_names", public_network_names)

    @property
    @pulumi.getter(name="availabilityZoneHints")
    def availability_zone_hints(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "availability_zone_hints")

    @property
    @pulumi.getter(name="internalNetworkNames")
    def internal_network_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "internal_network_names")

    @property
    @pulumi.getter(name="ipv6SupportDisabled")
    def ipv6_support_disabled(self) -> Optional[bool]:
        return pulumi.get(self, "ipv6_support_disabled")

    @property
    @pulumi.getter(name="publicNetworkNames")
    def public_network_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "public_network_names")


@pulumi.output_type
class ClusterCloudProviderOpenstackRouter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZoneHints":
            suggest = "availability_zone_hints"
        elif key == "dnsServers":
            suggest = "dns_servers"
        elif key == "externalNetwork":
            suggest = "external_network"
        elif key == "externalSubnet":
            suggest = "external_subnet"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudProviderOpenstackRouter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudProviderOpenstackRouter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudProviderOpenstackRouter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone_hints: Optional[Sequence[str]] = None,
                 dns_servers: Optional[str] = None,
                 external_network: Optional[str] = None,
                 external_subnet: Optional[str] = None):
        if availability_zone_hints is not None:
            pulumi.set(__self__, "availability_zone_hints", availability_zone_hints)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if external_network is not None:
            pulumi.set(__self__, "external_network", external_network)
        if external_subnet is not None:
            pulumi.set(__self__, "external_subnet", external_subnet)

    @property
    @pulumi.getter(name="availabilityZoneHints")
    def availability_zone_hints(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "availability_zone_hints")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[str]:
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter(name="externalNetwork")
    def external_network(self) -> Optional[str]:
        return pulumi.get(self, "external_network")

    @property
    @pulumi.getter(name="externalSubnet")
    def external_subnet(self) -> Optional[str]:
        return pulumi.get(self, "external_subnet")


@pulumi.output_type
class ClusterClusterAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skipNodesWithLocalStorage":
            suggest = "skip_nodes_with_local_storage"
        elif key == "skipNodesWithSystemPods":
            suggest = "skip_nodes_with_system_pods"
        elif key == "awsUseStaticInstanceList":
            suggest = "aws_use_static_instance_list"
        elif key == "balanceSimilarNodeGroups":
            suggest = "balance_similar_node_groups"
        elif key == "cordonNodeBeforeTerminating":
            suggest = "cordon_node_before_terminating"
        elif key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "maxNodeProvisionTime":
            suggest = "max_node_provision_time"
        elif key == "memoryRequest":
            suggest = "memory_request"
        elif key == "newPodScaleUpDelay":
            suggest = "new_pod_scale_up_delay"
        elif key == "podAnnotations":
            suggest = "pod_annotations"
        elif key == "scaleDownDelayAfterAdd":
            suggest = "scale_down_delay_after_add"
        elif key == "scaleDownUnneededTime":
            suggest = "scale_down_unneeded_time"
        elif key == "scaleDownUnreadyTime":
            suggest = "scale_down_unready_time"
        elif key == "scaleDownUtilizationThreshold":
            suggest = "scale_down_utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClusterAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClusterAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClusterAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 skip_nodes_with_local_storage: bool,
                 skip_nodes_with_system_pods: bool,
                 aws_use_static_instance_list: Optional[bool] = None,
                 balance_similar_node_groups: Optional[bool] = None,
                 cordon_node_before_terminating: Optional[bool] = None,
                 cpu_request: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 expander: Optional[str] = None,
                 image: Optional[str] = None,
                 max_node_provision_time: Optional[str] = None,
                 memory_request: Optional[str] = None,
                 new_pod_scale_up_delay: Optional[str] = None,
                 pod_annotations: Optional[Mapping[str, str]] = None,
                 scale_down_delay_after_add: Optional[str] = None,
                 scale_down_unneeded_time: Optional[str] = None,
                 scale_down_unready_time: Optional[str] = None,
                 scale_down_utilization_threshold: Optional[str] = None):
        pulumi.set(__self__, "skip_nodes_with_local_storage", skip_nodes_with_local_storage)
        pulumi.set(__self__, "skip_nodes_with_system_pods", skip_nodes_with_system_pods)
        if aws_use_static_instance_list is not None:
            pulumi.set(__self__, "aws_use_static_instance_list", aws_use_static_instance_list)
        if balance_similar_node_groups is not None:
            pulumi.set(__self__, "balance_similar_node_groups", balance_similar_node_groups)
        if cordon_node_before_terminating is not None:
            pulumi.set(__self__, "cordon_node_before_terminating", cordon_node_before_terminating)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expander is not None:
            pulumi.set(__self__, "expander", expander)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if max_node_provision_time is not None:
            pulumi.set(__self__, "max_node_provision_time", max_node_provision_time)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)
        if new_pod_scale_up_delay is not None:
            pulumi.set(__self__, "new_pod_scale_up_delay", new_pod_scale_up_delay)
        if pod_annotations is not None:
            pulumi.set(__self__, "pod_annotations", pod_annotations)
        if scale_down_delay_after_add is not None:
            pulumi.set(__self__, "scale_down_delay_after_add", scale_down_delay_after_add)
        if scale_down_unneeded_time is not None:
            pulumi.set(__self__, "scale_down_unneeded_time", scale_down_unneeded_time)
        if scale_down_unready_time is not None:
            pulumi.set(__self__, "scale_down_unready_time", scale_down_unready_time)
        if scale_down_utilization_threshold is not None:
            pulumi.set(__self__, "scale_down_utilization_threshold", scale_down_utilization_threshold)

    @property
    @pulumi.getter(name="skipNodesWithLocalStorage")
    def skip_nodes_with_local_storage(self) -> bool:
        return pulumi.get(self, "skip_nodes_with_local_storage")

    @property
    @pulumi.getter(name="skipNodesWithSystemPods")
    def skip_nodes_with_system_pods(self) -> bool:
        return pulumi.get(self, "skip_nodes_with_system_pods")

    @property
    @pulumi.getter(name="awsUseStaticInstanceList")
    def aws_use_static_instance_list(self) -> Optional[bool]:
        return pulumi.get(self, "aws_use_static_instance_list")

    @property
    @pulumi.getter(name="balanceSimilarNodeGroups")
    def balance_similar_node_groups(self) -> Optional[bool]:
        return pulumi.get(self, "balance_similar_node_groups")

    @property
    @pulumi.getter(name="cordonNodeBeforeTerminating")
    def cordon_node_before_terminating(self) -> Optional[bool]:
        return pulumi.get(self, "cordon_node_before_terminating")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[str]:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def expander(self) -> Optional[str]:
        return pulumi.get(self, "expander")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="maxNodeProvisionTime")
    def max_node_provision_time(self) -> Optional[str]:
        return pulumi.get(self, "max_node_provision_time")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[str]:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter(name="newPodScaleUpDelay")
    def new_pod_scale_up_delay(self) -> Optional[str]:
        return pulumi.get(self, "new_pod_scale_up_delay")

    @property
    @pulumi.getter(name="podAnnotations")
    def pod_annotations(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "pod_annotations")

    @property
    @pulumi.getter(name="scaleDownDelayAfterAdd")
    def scale_down_delay_after_add(self) -> Optional[str]:
        return pulumi.get(self, "scale_down_delay_after_add")

    @property
    @pulumi.getter(name="scaleDownUnneededTime")
    def scale_down_unneeded_time(self) -> Optional[str]:
        return pulumi.get(self, "scale_down_unneeded_time")

    @property
    @pulumi.getter(name="scaleDownUnreadyTime")
    def scale_down_unready_time(self) -> Optional[str]:
        return pulumi.get(self, "scale_down_unready_time")

    @property
    @pulumi.getter(name="scaleDownUtilizationThreshold")
    def scale_down_utilization_threshold(self) -> Optional[str]:
        return pulumi.get(self, "scale_down_utilization_threshold")


@pulumi.output_type
class ClusterContainerd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configOverride":
            suggest = "config_override"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "nvidiaGpu":
            suggest = "nvidia_gpu"
        elif key == "registryMirrors":
            suggest = "registry_mirrors"
        elif key == "skipInstall":
            suggest = "skip_install"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterContainerd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterContainerd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterContainerd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 config_override: Optional[str] = None,
                 log_level: Optional[str] = None,
                 nvidia_gpu: Optional['outputs.ClusterContainerdNvidiaGpu'] = None,
                 packages: Optional['outputs.ClusterContainerdPackages'] = None,
                 registry_mirrors: Optional[Sequence['outputs.ClusterContainerdRegistryMirror']] = None,
                 root: Optional[str] = None,
                 runc: Optional['outputs.ClusterContainerdRunc'] = None,
                 skip_install: Optional[bool] = None,
                 state: Optional[str] = None,
                 version: Optional[str] = None):
        if address is not None:
            pulumi.set(__self__, "address", address)
        if config_override is not None:
            pulumi.set(__self__, "config_override", config_override)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if nvidia_gpu is not None:
            pulumi.set(__self__, "nvidia_gpu", nvidia_gpu)
        if packages is not None:
            pulumi.set(__self__, "packages", packages)
        if registry_mirrors is not None:
            pulumi.set(__self__, "registry_mirrors", registry_mirrors)
        if root is not None:
            pulumi.set(__self__, "root", root)
        if runc is not None:
            pulumi.set(__self__, "runc", runc)
        if skip_install is not None:
            pulumi.set(__self__, "skip_install", skip_install)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="configOverride")
    def config_override(self) -> Optional[str]:
        return pulumi.get(self, "config_override")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="nvidiaGpu")
    def nvidia_gpu(self) -> Optional['outputs.ClusterContainerdNvidiaGpu']:
        return pulumi.get(self, "nvidia_gpu")

    @property
    @pulumi.getter
    def packages(self) -> Optional['outputs.ClusterContainerdPackages']:
        return pulumi.get(self, "packages")

    @property
    @pulumi.getter(name="registryMirrors")
    def registry_mirrors(self) -> Optional[Sequence['outputs.ClusterContainerdRegistryMirror']]:
        return pulumi.get(self, "registry_mirrors")

    @property
    @pulumi.getter
    def root(self) -> Optional[str]:
        return pulumi.get(self, "root")

    @property
    @pulumi.getter
    def runc(self) -> Optional['outputs.ClusterContainerdRunc']:
        return pulumi.get(self, "runc")

    @property
    @pulumi.getter(name="skipInstall")
    def skip_install(self) -> Optional[bool]:
        return pulumi.get(self, "skip_install")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterContainerdNvidiaGpu(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "driverPackage":
            suggest = "driver_package"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterContainerdNvidiaGpu. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterContainerdNvidiaGpu.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterContainerdNvidiaGpu.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 driver_package: Optional[str] = None,
                 enabled: Optional[bool] = None):
        if driver_package is not None:
            pulumi.set(__self__, "driver_package", driver_package)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="driverPackage")
    def driver_package(self) -> Optional[str]:
        return pulumi.get(self, "driver_package")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterContainerdPackages(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hashAmd64":
            suggest = "hash_amd64"
        elif key == "hashArm64":
            suggest = "hash_arm64"
        elif key == "urlAmd64":
            suggest = "url_amd64"
        elif key == "urlArm64":
            suggest = "url_arm64"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterContainerdPackages. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterContainerdPackages.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterContainerdPackages.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hash_amd64: Optional[str] = None,
                 hash_arm64: Optional[str] = None,
                 url_amd64: Optional[str] = None,
                 url_arm64: Optional[str] = None):
        if hash_amd64 is not None:
            pulumi.set(__self__, "hash_amd64", hash_amd64)
        if hash_arm64 is not None:
            pulumi.set(__self__, "hash_arm64", hash_arm64)
        if url_amd64 is not None:
            pulumi.set(__self__, "url_amd64", url_amd64)
        if url_arm64 is not None:
            pulumi.set(__self__, "url_arm64", url_arm64)

    @property
    @pulumi.getter(name="hashAmd64")
    def hash_amd64(self) -> Optional[str]:
        return pulumi.get(self, "hash_amd64")

    @property
    @pulumi.getter(name="hashArm64")
    def hash_arm64(self) -> Optional[str]:
        return pulumi.get(self, "hash_arm64")

    @property
    @pulumi.getter(name="urlAmd64")
    def url_amd64(self) -> Optional[str]:
        return pulumi.get(self, "url_amd64")

    @property
    @pulumi.getter(name="urlArm64")
    def url_arm64(self) -> Optional[str]:
        return pulumi.get(self, "url_arm64")


@pulumi.output_type
class ClusterContainerdRegistryMirror(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterContainerdRunc(dict):
    def __init__(__self__, *,
                 packages: Optional['outputs.ClusterContainerdRuncPackages'] = None,
                 version: Optional[str] = None):
        if packages is not None:
            pulumi.set(__self__, "packages", packages)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def packages(self) -> Optional['outputs.ClusterContainerdRuncPackages']:
        return pulumi.get(self, "packages")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterContainerdRuncPackages(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hashAmd64":
            suggest = "hash_amd64"
        elif key == "hashArm64":
            suggest = "hash_arm64"
        elif key == "urlAmd64":
            suggest = "url_amd64"
        elif key == "urlArm64":
            suggest = "url_arm64"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterContainerdRuncPackages. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterContainerdRuncPackages.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterContainerdRuncPackages.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hash_amd64: Optional[str] = None,
                 hash_arm64: Optional[str] = None,
                 url_amd64: Optional[str] = None,
                 url_arm64: Optional[str] = None):
        if hash_amd64 is not None:
            pulumi.set(__self__, "hash_amd64", hash_amd64)
        if hash_arm64 is not None:
            pulumi.set(__self__, "hash_arm64", hash_arm64)
        if url_amd64 is not None:
            pulumi.set(__self__, "url_amd64", url_amd64)
        if url_arm64 is not None:
            pulumi.set(__self__, "url_arm64", url_arm64)

    @property
    @pulumi.getter(name="hashAmd64")
    def hash_amd64(self) -> Optional[str]:
        return pulumi.get(self, "hash_amd64")

    @property
    @pulumi.getter(name="hashArm64")
    def hash_arm64(self) -> Optional[str]:
        return pulumi.get(self, "hash_arm64")

    @property
    @pulumi.getter(name="urlAmd64")
    def url_amd64(self) -> Optional[str]:
        return pulumi.get(self, "url_amd64")

    @property
    @pulumi.getter(name="urlArm64")
    def url_arm64(self) -> Optional[str]:
        return pulumi.get(self, "url_arm64")


@pulumi.output_type
class ClusterDocker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationPlugins":
            suggest = "authorization_plugins"
        elif key == "bridgeIp":
            suggest = "bridge_ip"
        elif key == "dataRoot":
            suggest = "data_root"
        elif key == "defaultRuntime":
            suggest = "default_runtime"
        elif key == "defaultUlimits":
            suggest = "default_ulimits"
        elif key == "execOpts":
            suggest = "exec_opts"
        elif key == "execRoot":
            suggest = "exec_root"
        elif key == "healthCheck":
            suggest = "health_check"
        elif key == "insecureRegistries":
            suggest = "insecure_registries"
        elif key == "insecureRegistry":
            suggest = "insecure_registry"
        elif key == "ipMasq":
            suggest = "ip_masq"
        elif key == "ipTables":
            suggest = "ip_tables"
        elif key == "liveRestore":
            suggest = "live_restore"
        elif key == "logDriver":
            suggest = "log_driver"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "logOpts":
            suggest = "log_opts"
        elif key == "maxConcurrentDownloads":
            suggest = "max_concurrent_downloads"
        elif key == "maxConcurrentUploads":
            suggest = "max_concurrent_uploads"
        elif key == "maxDownloadAttempts":
            suggest = "max_download_attempts"
        elif key == "metricsAddress":
            suggest = "metrics_address"
        elif key == "registryMirrors":
            suggest = "registry_mirrors"
        elif key == "selinuxEnabled":
            suggest = "selinux_enabled"
        elif key == "skipInstall":
            suggest = "skip_install"
        elif key == "storageOpts":
            suggest = "storage_opts"
        elif key == "userNamespaceRemap":
            suggest = "user_namespace_remap"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterDocker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterDocker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterDocker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_plugins: Optional[Sequence[str]] = None,
                 bridge: Optional[str] = None,
                 bridge_ip: Optional[str] = None,
                 data_root: Optional[str] = None,
                 default_runtime: Optional[str] = None,
                 default_ulimits: Optional[Sequence[str]] = None,
                 dns: Optional[Sequence[str]] = None,
                 exec_opts: Optional[Sequence[str]] = None,
                 exec_root: Optional[str] = None,
                 experimental: Optional[bool] = None,
                 health_check: Optional[bool] = None,
                 hosts: Optional[Sequence[str]] = None,
                 insecure_registries: Optional[Sequence[str]] = None,
                 insecure_registry: Optional[str] = None,
                 ip_masq: Optional[bool] = None,
                 ip_tables: Optional[bool] = None,
                 live_restore: Optional[bool] = None,
                 log_driver: Optional[str] = None,
                 log_level: Optional[str] = None,
                 log_opts: Optional[Sequence[str]] = None,
                 max_concurrent_downloads: Optional[int] = None,
                 max_concurrent_uploads: Optional[int] = None,
                 max_download_attempts: Optional[int] = None,
                 metrics_address: Optional[str] = None,
                 mtu: Optional[int] = None,
                 packages: Optional['outputs.ClusterDockerPackages'] = None,
                 registry_mirrors: Optional[Sequence[str]] = None,
                 runtimes: Optional[Sequence[str]] = None,
                 selinux_enabled: Optional[bool] = None,
                 skip_install: Optional[bool] = None,
                 storage: Optional[str] = None,
                 storage_opts: Optional[Sequence[str]] = None,
                 user_namespace_remap: Optional[str] = None,
                 version: Optional[str] = None):
        if authorization_plugins is not None:
            pulumi.set(__self__, "authorization_plugins", authorization_plugins)
        if bridge is not None:
            pulumi.set(__self__, "bridge", bridge)
        if bridge_ip is not None:
            pulumi.set(__self__, "bridge_ip", bridge_ip)
        if data_root is not None:
            pulumi.set(__self__, "data_root", data_root)
        if default_runtime is not None:
            pulumi.set(__self__, "default_runtime", default_runtime)
        if default_ulimits is not None:
            pulumi.set(__self__, "default_ulimits", default_ulimits)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if exec_opts is not None:
            pulumi.set(__self__, "exec_opts", exec_opts)
        if exec_root is not None:
            pulumi.set(__self__, "exec_root", exec_root)
        if experimental is not None:
            pulumi.set(__self__, "experimental", experimental)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if insecure_registries is not None:
            pulumi.set(__self__, "insecure_registries", insecure_registries)
        if insecure_registry is not None:
            pulumi.set(__self__, "insecure_registry", insecure_registry)
        if ip_masq is not None:
            pulumi.set(__self__, "ip_masq", ip_masq)
        if ip_tables is not None:
            pulumi.set(__self__, "ip_tables", ip_tables)
        if live_restore is not None:
            pulumi.set(__self__, "live_restore", live_restore)
        if log_driver is not None:
            pulumi.set(__self__, "log_driver", log_driver)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if log_opts is not None:
            pulumi.set(__self__, "log_opts", log_opts)
        if max_concurrent_downloads is not None:
            pulumi.set(__self__, "max_concurrent_downloads", max_concurrent_downloads)
        if max_concurrent_uploads is not None:
            pulumi.set(__self__, "max_concurrent_uploads", max_concurrent_uploads)
        if max_download_attempts is not None:
            pulumi.set(__self__, "max_download_attempts", max_download_attempts)
        if metrics_address is not None:
            pulumi.set(__self__, "metrics_address", metrics_address)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if packages is not None:
            pulumi.set(__self__, "packages", packages)
        if registry_mirrors is not None:
            pulumi.set(__self__, "registry_mirrors", registry_mirrors)
        if runtimes is not None:
            pulumi.set(__self__, "runtimes", runtimes)
        if selinux_enabled is not None:
            pulumi.set(__self__, "selinux_enabled", selinux_enabled)
        if skip_install is not None:
            pulumi.set(__self__, "skip_install", skip_install)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if storage_opts is not None:
            pulumi.set(__self__, "storage_opts", storage_opts)
        if user_namespace_remap is not None:
            pulumi.set(__self__, "user_namespace_remap", user_namespace_remap)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="authorizationPlugins")
    def authorization_plugins(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "authorization_plugins")

    @property
    @pulumi.getter
    def bridge(self) -> Optional[str]:
        return pulumi.get(self, "bridge")

    @property
    @pulumi.getter(name="bridgeIp")
    def bridge_ip(self) -> Optional[str]:
        return pulumi.get(self, "bridge_ip")

    @property
    @pulumi.getter(name="dataRoot")
    def data_root(self) -> Optional[str]:
        return pulumi.get(self, "data_root")

    @property
    @pulumi.getter(name="defaultRuntime")
    def default_runtime(self) -> Optional[str]:
        return pulumi.get(self, "default_runtime")

    @property
    @pulumi.getter(name="defaultUlimits")
    def default_ulimits(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "default_ulimits")

    @property
    @pulumi.getter
    def dns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter(name="execOpts")
    def exec_opts(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exec_opts")

    @property
    @pulumi.getter(name="execRoot")
    def exec_root(self) -> Optional[str]:
        return pulumi.get(self, "exec_root")

    @property
    @pulumi.getter
    def experimental(self) -> Optional[bool]:
        return pulumi.get(self, "experimental")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[bool]:
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter(name="insecureRegistries")
    def insecure_registries(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "insecure_registries")

    @property
    @pulumi.getter(name="insecureRegistry")
    def insecure_registry(self) -> Optional[str]:
        return pulumi.get(self, "insecure_registry")

    @property
    @pulumi.getter(name="ipMasq")
    def ip_masq(self) -> Optional[bool]:
        return pulumi.get(self, "ip_masq")

    @property
    @pulumi.getter(name="ipTables")
    def ip_tables(self) -> Optional[bool]:
        return pulumi.get(self, "ip_tables")

    @property
    @pulumi.getter(name="liveRestore")
    def live_restore(self) -> Optional[bool]:
        return pulumi.get(self, "live_restore")

    @property
    @pulumi.getter(name="logDriver")
    def log_driver(self) -> Optional[str]:
        return pulumi.get(self, "log_driver")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="logOpts")
    def log_opts(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "log_opts")

    @property
    @pulumi.getter(name="maxConcurrentDownloads")
    def max_concurrent_downloads(self) -> Optional[int]:
        return pulumi.get(self, "max_concurrent_downloads")

    @property
    @pulumi.getter(name="maxConcurrentUploads")
    def max_concurrent_uploads(self) -> Optional[int]:
        return pulumi.get(self, "max_concurrent_uploads")

    @property
    @pulumi.getter(name="maxDownloadAttempts")
    def max_download_attempts(self) -> Optional[int]:
        return pulumi.get(self, "max_download_attempts")

    @property
    @pulumi.getter(name="metricsAddress")
    def metrics_address(self) -> Optional[str]:
        return pulumi.get(self, "metrics_address")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter
    def packages(self) -> Optional['outputs.ClusterDockerPackages']:
        return pulumi.get(self, "packages")

    @property
    @pulumi.getter(name="registryMirrors")
    def registry_mirrors(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "registry_mirrors")

    @property
    @pulumi.getter
    def runtimes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "runtimes")

    @property
    @pulumi.getter(name="selinuxEnabled")
    def selinux_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "selinux_enabled")

    @property
    @pulumi.getter(name="skipInstall")
    def skip_install(self) -> Optional[bool]:
        return pulumi.get(self, "skip_install")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        return pulumi.get(self, "storage")

    @property
    @pulumi.getter(name="storageOpts")
    def storage_opts(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "storage_opts")

    @property
    @pulumi.getter(name="userNamespaceRemap")
    def user_namespace_remap(self) -> Optional[str]:
        return pulumi.get(self, "user_namespace_remap")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterDockerPackages(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hashAmd64":
            suggest = "hash_amd64"
        elif key == "hashArm64":
            suggest = "hash_arm64"
        elif key == "urlAmd64":
            suggest = "url_amd64"
        elif key == "urlArm64":
            suggest = "url_arm64"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterDockerPackages. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterDockerPackages.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterDockerPackages.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hash_amd64: Optional[str] = None,
                 hash_arm64: Optional[str] = None,
                 url_amd64: Optional[str] = None,
                 url_arm64: Optional[str] = None):
        if hash_amd64 is not None:
            pulumi.set(__self__, "hash_amd64", hash_amd64)
        if hash_arm64 is not None:
            pulumi.set(__self__, "hash_arm64", hash_arm64)
        if url_amd64 is not None:
            pulumi.set(__self__, "url_amd64", url_amd64)
        if url_arm64 is not None:
            pulumi.set(__self__, "url_arm64", url_arm64)

    @property
    @pulumi.getter(name="hashAmd64")
    def hash_amd64(self) -> Optional[str]:
        return pulumi.get(self, "hash_amd64")

    @property
    @pulumi.getter(name="hashArm64")
    def hash_arm64(self) -> Optional[str]:
        return pulumi.get(self, "hash_arm64")

    @property
    @pulumi.getter(name="urlAmd64")
    def url_amd64(self) -> Optional[str]:
        return pulumi.get(self, "url_amd64")

    @property
    @pulumi.getter(name="urlArm64")
    def url_arm64(self) -> Optional[str]:
        return pulumi.get(self, "url_arm64")


@pulumi.output_type
class ClusterEgressProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpProxy":
            suggest = "http_proxy"
        elif key == "proxyExcludes":
            suggest = "proxy_excludes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterEgressProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterEgressProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterEgressProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_proxy: 'outputs.ClusterEgressProxyHttpProxy',
                 proxy_excludes: Optional[str] = None):
        pulumi.set(__self__, "http_proxy", http_proxy)
        if proxy_excludes is not None:
            pulumi.set(__self__, "proxy_excludes", proxy_excludes)

    @property
    @pulumi.getter(name="httpProxy")
    def http_proxy(self) -> 'outputs.ClusterEgressProxyHttpProxy':
        return pulumi.get(self, "http_proxy")

    @property
    @pulumi.getter(name="proxyExcludes")
    def proxy_excludes(self) -> Optional[str]:
        return pulumi.get(self, "proxy_excludes")


@pulumi.output_type
class ClusterEgressProxyHttpProxy(dict):
    def __init__(__self__, *,
                 host: str,
                 port: int):
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")


@pulumi.output_type
class ClusterEtcdCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "heartbeatInterval":
            suggest = "heartbeat_interval"
        elif key == "leaderElectionTimeout":
            suggest = "leader_election_timeout"
        elif key == "memoryRequest":
            suggest = "memory_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterEtcdCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterEtcdCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterEtcdCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 members: Sequence['outputs.ClusterEtcdClusterMember'],
                 name: str,
                 backups: Optional['outputs.ClusterEtcdClusterBackups'] = None,
                 cpu_request: Optional[str] = None,
                 heartbeat_interval: Optional[str] = None,
                 image: Optional[str] = None,
                 leader_election_timeout: Optional[str] = None,
                 manager: Optional['outputs.ClusterEtcdClusterManager'] = None,
                 memory_request: Optional[str] = None,
                 provider: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str name: - (Force new) - String - Name defines the cluster name.
        """
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "name", name)
        if backups is not None:
            pulumi.set(__self__, "backups", backups)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if heartbeat_interval is not None:
            pulumi.set(__self__, "heartbeat_interval", heartbeat_interval)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if leader_election_timeout is not None:
            pulumi.set(__self__, "leader_election_timeout", leader_election_timeout)
        if manager is not None:
            pulumi.set(__self__, "manager", manager)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def members(self) -> Sequence['outputs.ClusterEtcdClusterMember']:
        return pulumi.get(self, "members")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - (Force new) - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def backups(self) -> Optional['outputs.ClusterEtcdClusterBackups']:
        return pulumi.get(self, "backups")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[str]:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter(name="heartbeatInterval")
    def heartbeat_interval(self) -> Optional[str]:
        return pulumi.get(self, "heartbeat_interval")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="leaderElectionTimeout")
    def leader_election_timeout(self) -> Optional[str]:
        return pulumi.get(self, "leader_election_timeout")

    @property
    @pulumi.getter
    def manager(self) -> Optional['outputs.ClusterEtcdClusterManager']:
        return pulumi.get(self, "manager")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[str]:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterEtcdClusterBackups(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupStore":
            suggest = "backup_store"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterEtcdClusterBackups. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterEtcdClusterBackups.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterEtcdClusterBackups.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_store: str,
                 image: str):
        pulumi.set(__self__, "backup_store", backup_store)
        pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter(name="backupStore")
    def backup_store(self) -> str:
        return pulumi.get(self, "backup_store")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")


@pulumi.output_type
class ClusterEtcdClusterManager(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupInterval":
            suggest = "backup_interval"
        elif key == "discoveryPollInterval":
            suggest = "discovery_poll_interval"
        elif key == "logLevel":
            suggest = "log_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterEtcdClusterManager. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterEtcdClusterManager.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterEtcdClusterManager.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_interval: Optional[str] = None,
                 discovery_poll_interval: Optional[str] = None,
                 envs: Optional[Sequence['outputs.ClusterEtcdClusterManagerEnv']] = None,
                 image: Optional[str] = None,
                 log_level: Optional[int] = None):
        if backup_interval is not None:
            pulumi.set(__self__, "backup_interval", backup_interval)
        if discovery_poll_interval is not None:
            pulumi.set(__self__, "discovery_poll_interval", discovery_poll_interval)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)

    @property
    @pulumi.getter(name="backupInterval")
    def backup_interval(self) -> Optional[str]:
        return pulumi.get(self, "backup_interval")

    @property
    @pulumi.getter(name="discoveryPollInterval")
    def discovery_poll_interval(self) -> Optional[str]:
        return pulumi.get(self, "discovery_poll_interval")

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.ClusterEtcdClusterManagerEnv']]:
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[int]:
        return pulumi.get(self, "log_level")


@pulumi.output_type
class ClusterEtcdClusterManagerEnv(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str name: - (Force new) - String - Name defines the cluster name.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - (Force new) - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterEtcdClusterMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceGroup":
            suggest = "instance_group"
        elif key == "encryptedVolume":
            suggest = "encrypted_volume"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "volumeIops":
            suggest = "volume_iops"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeThroughput":
            suggest = "volume_throughput"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterEtcdClusterMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterEtcdClusterMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterEtcdClusterMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_group: str,
                 name: str,
                 encrypted_volume: Optional[bool] = None,
                 kms_key_id: Optional[str] = None,
                 volume_iops: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_throughput: Optional[int] = None,
                 volume_type: Optional[str] = None):
        """
        :param str name: - (Force new) - String - Name defines the cluster name.
        """
        pulumi.set(__self__, "instance_group", instance_group)
        pulumi.set(__self__, "name", name)
        if encrypted_volume is not None:
            pulumi.set(__self__, "encrypted_volume", encrypted_volume)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if volume_iops is not None:
            pulumi.set(__self__, "volume_iops", volume_iops)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_throughput is not None:
            pulumi.set(__self__, "volume_throughput", volume_throughput)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="instanceGroup")
    def instance_group(self) -> str:
        return pulumi.get(self, "instance_group")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - (Force new) - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="encryptedVolume")
    def encrypted_volume(self) -> Optional[bool]:
        return pulumi.get(self, "encrypted_volume")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="volumeIops")
    def volume_iops(self) -> Optional[int]:
        return pulumi.get(self, "volume_iops")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeThroughput")
    def volume_throughput(self) -> Optional[int]:
        return pulumi.get(self, "volume_throughput")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class ClusterExternalCloudControllerManager(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocateNodeCidrs":
            suggest = "allocate_node_cidrs"
        elif key == "allowUntaggedCloud":
            suggest = "allow_untagged_cloud"
        elif key == "cidrAllocatorType":
            suggest = "cidr_allocator_type"
        elif key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "clusterCidr":
            suggest = "cluster_cidr"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "configureCloudRoutes":
            suggest = "configure_cloud_routes"
        elif key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "enableLeaderMigration":
            suggest = "enable_leader_migration"
        elif key == "leaderElection":
            suggest = "leader_election"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "useServiceAccountCredentials":
            suggest = "use_service_account_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterExternalCloudControllerManager. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterExternalCloudControllerManager.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterExternalCloudControllerManager.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocate_node_cidrs: Optional[bool] = None,
                 allow_untagged_cloud: Optional[bool] = None,
                 cidr_allocator_type: Optional[str] = None,
                 cloud_provider: Optional[str] = None,
                 cluster_cidr: Optional[str] = None,
                 cluster_name: Optional[str] = None,
                 configure_cloud_routes: Optional[bool] = None,
                 controllers: Optional[Sequence[str]] = None,
                 cpu_request: Optional[str] = None,
                 enable_leader_migration: Optional[bool] = None,
                 image: Optional[str] = None,
                 leader_election: Optional['outputs.ClusterExternalCloudControllerManagerLeaderElection'] = None,
                 log_level: Optional[int] = None,
                 master: Optional[str] = None,
                 use_service_account_credentials: Optional[bool] = None):
        """
        :param str cloud_provider: - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        """
        if allocate_node_cidrs is not None:
            pulumi.set(__self__, "allocate_node_cidrs", allocate_node_cidrs)
        if allow_untagged_cloud is not None:
            pulumi.set(__self__, "allow_untagged_cloud", allow_untagged_cloud)
        if cidr_allocator_type is not None:
            pulumi.set(__self__, "cidr_allocator_type", cidr_allocator_type)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if cluster_cidr is not None:
            pulumi.set(__self__, "cluster_cidr", cluster_cidr)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if configure_cloud_routes is not None:
            pulumi.set(__self__, "configure_cloud_routes", configure_cloud_routes)
        if controllers is not None:
            pulumi.set(__self__, "controllers", controllers)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if enable_leader_migration is not None:
            pulumi.set(__self__, "enable_leader_migration", enable_leader_migration)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if leader_election is not None:
            pulumi.set(__self__, "leader_election", leader_election)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if master is not None:
            pulumi.set(__self__, "master", master)
        if use_service_account_credentials is not None:
            pulumi.set(__self__, "use_service_account_credentials", use_service_account_credentials)

    @property
    @pulumi.getter(name="allocateNodeCidrs")
    def allocate_node_cidrs(self) -> Optional[bool]:
        return pulumi.get(self, "allocate_node_cidrs")

    @property
    @pulumi.getter(name="allowUntaggedCloud")
    def allow_untagged_cloud(self) -> Optional[bool]:
        return pulumi.get(self, "allow_untagged_cloud")

    @property
    @pulumi.getter(name="cidrAllocatorType")
    def cidr_allocator_type(self) -> Optional[str]:
        return pulumi.get(self, "cidr_allocator_type")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[str]:
        """
        - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="clusterCidr")
    def cluster_cidr(self) -> Optional[str]:
        return pulumi.get(self, "cluster_cidr")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="configureCloudRoutes")
    def configure_cloud_routes(self) -> Optional[bool]:
        return pulumi.get(self, "configure_cloud_routes")

    @property
    @pulumi.getter
    def controllers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "controllers")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[str]:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter(name="enableLeaderMigration")
    def enable_leader_migration(self) -> Optional[bool]:
        return pulumi.get(self, "enable_leader_migration")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="leaderElection")
    def leader_election(self) -> Optional['outputs.ClusterExternalCloudControllerManagerLeaderElection']:
        return pulumi.get(self, "leader_election")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[int]:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter
    def master(self) -> Optional[str]:
        return pulumi.get(self, "master")

    @property
    @pulumi.getter(name="useServiceAccountCredentials")
    def use_service_account_credentials(self) -> Optional[bool]:
        return pulumi.get(self, "use_service_account_credentials")


@pulumi.output_type
class ClusterExternalCloudControllerManagerLeaderElection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "leaderElect":
            suggest = "leader_elect"
        elif key == "leaderElectLeaseDuration":
            suggest = "leader_elect_lease_duration"
        elif key == "leaderElectRenewDeadlineDuration":
            suggest = "leader_elect_renew_deadline_duration"
        elif key == "leaderElectResourceLock":
            suggest = "leader_elect_resource_lock"
        elif key == "leaderElectResourceName":
            suggest = "leader_elect_resource_name"
        elif key == "leaderElectResourceNamespace":
            suggest = "leader_elect_resource_namespace"
        elif key == "leaderElectRetryPeriod":
            suggest = "leader_elect_retry_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterExternalCloudControllerManagerLeaderElection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterExternalCloudControllerManagerLeaderElection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterExternalCloudControllerManagerLeaderElection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 leader_elect: Optional[bool] = None,
                 leader_elect_lease_duration: Optional[str] = None,
                 leader_elect_renew_deadline_duration: Optional[str] = None,
                 leader_elect_resource_lock: Optional[str] = None,
                 leader_elect_resource_name: Optional[str] = None,
                 leader_elect_resource_namespace: Optional[str] = None,
                 leader_elect_retry_period: Optional[str] = None):
        if leader_elect is not None:
            pulumi.set(__self__, "leader_elect", leader_elect)
        if leader_elect_lease_duration is not None:
            pulumi.set(__self__, "leader_elect_lease_duration", leader_elect_lease_duration)
        if leader_elect_renew_deadline_duration is not None:
            pulumi.set(__self__, "leader_elect_renew_deadline_duration", leader_elect_renew_deadline_duration)
        if leader_elect_resource_lock is not None:
            pulumi.set(__self__, "leader_elect_resource_lock", leader_elect_resource_lock)
        if leader_elect_resource_name is not None:
            pulumi.set(__self__, "leader_elect_resource_name", leader_elect_resource_name)
        if leader_elect_resource_namespace is not None:
            pulumi.set(__self__, "leader_elect_resource_namespace", leader_elect_resource_namespace)
        if leader_elect_retry_period is not None:
            pulumi.set(__self__, "leader_elect_retry_period", leader_elect_retry_period)

    @property
    @pulumi.getter(name="leaderElect")
    def leader_elect(self) -> Optional[bool]:
        return pulumi.get(self, "leader_elect")

    @property
    @pulumi.getter(name="leaderElectLeaseDuration")
    def leader_elect_lease_duration(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_lease_duration")

    @property
    @pulumi.getter(name="leaderElectRenewDeadlineDuration")
    def leader_elect_renew_deadline_duration(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_renew_deadline_duration")

    @property
    @pulumi.getter(name="leaderElectResourceLock")
    def leader_elect_resource_lock(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_resource_lock")

    @property
    @pulumi.getter(name="leaderElectResourceName")
    def leader_elect_resource_name(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_resource_name")

    @property
    @pulumi.getter(name="leaderElectResourceNamespace")
    def leader_elect_resource_namespace(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_resource_namespace")

    @property
    @pulumi.getter(name="leaderElectRetryPeriod")
    def leader_elect_retry_period(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_retry_period")


@pulumi.output_type
class ClusterExternalDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "watchIngress":
            suggest = "watch_ingress"
        elif key == "watchNamespace":
            suggest = "watch_namespace"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterExternalDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterExternalDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterExternalDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provider: Optional[str] = None,
                 watch_ingress: Optional[bool] = None,
                 watch_namespace: Optional[str] = None):
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if watch_ingress is not None:
            pulumi.set(__self__, "watch_ingress", watch_ingress)
        if watch_namespace is not None:
            pulumi.set(__self__, "watch_namespace", watch_namespace)

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="watchIngress")
    def watch_ingress(self) -> Optional[bool]:
        return pulumi.get(self, "watch_ingress")

    @property
    @pulumi.getter(name="watchNamespace")
    def watch_namespace(self) -> Optional[str]:
        return pulumi.get(self, "watch_namespace")


@pulumi.output_type
class ClusterExternalPolicy(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterFileAsset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isBase64":
            suggest = "is_base64"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterFileAsset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterFileAsset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterFileAsset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: str,
                 name: str,
                 path: str,
                 is_base64: Optional[bool] = None,
                 mode: Optional[str] = None,
                 roles: Optional[Sequence[str]] = None):
        """
        :param str name: - (Force new) - String - Name defines the cluster name.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        if is_base64 is not None:
            pulumi.set(__self__, "is_base64", is_base64)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - (Force new) - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="isBase64")
    def is_base64(self) -> Optional[bool]:
        return pulumi.get(self, "is_base64")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "roles")


@pulumi.output_type
class ClusterHook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "execContainer":
            suggest = "exec_container"
        elif key == "useRawManifest":
            suggest = "use_raw_manifest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterHook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterHook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterHook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 befores: Optional[Sequence[str]] = None,
                 enabled: Optional[bool] = None,
                 exec_container: Optional['outputs.ClusterHookExecContainer'] = None,
                 manifest: Optional[str] = None,
                 requires: Optional[Sequence[str]] = None,
                 roles: Optional[Sequence[str]] = None,
                 use_raw_manifest: Optional[bool] = None):
        """
        :param str name: - (Force new) - String - Name defines the cluster name.
        """
        pulumi.set(__self__, "name", name)
        if befores is not None:
            pulumi.set(__self__, "befores", befores)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exec_container is not None:
            pulumi.set(__self__, "exec_container", exec_container)
        if manifest is not None:
            pulumi.set(__self__, "manifest", manifest)
        if requires is not None:
            pulumi.set(__self__, "requires", requires)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if use_raw_manifest is not None:
            pulumi.set(__self__, "use_raw_manifest", use_raw_manifest)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - (Force new) - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def befores(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "befores")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="execContainer")
    def exec_container(self) -> Optional['outputs.ClusterHookExecContainer']:
        return pulumi.get(self, "exec_container")

    @property
    @pulumi.getter
    def manifest(self) -> Optional[str]:
        return pulumi.get(self, "manifest")

    @property
    @pulumi.getter
    def requires(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "requires")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter(name="useRawManifest")
    def use_raw_manifest(self) -> Optional[bool]:
        return pulumi.get(self, "use_raw_manifest")


@pulumi.output_type
class ClusterHookExecContainer(dict):
    def __init__(__self__, *,
                 image: str,
                 commands: Optional[Sequence[str]] = None,
                 environment: Optional[Mapping[str, str]] = None):
        pulumi.set(__self__, "image", image)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def environment(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "environment")


@pulumi.output_type
class ClusterIam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowContainerRegistry":
            suggest = "allow_container_registry"
        elif key == "permissionsBoundary":
            suggest = "permissions_boundary"
        elif key == "serviceAccountExternalPermissions":
            suggest = "service_account_external_permissions"
        elif key == "useServiceAccountExternalPermissions":
            suggest = "use_service_account_external_permissions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterIam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterIam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterIam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_container_registry: Optional[bool] = None,
                 legacy: Optional[bool] = None,
                 permissions_boundary: Optional[str] = None,
                 service_account_external_permissions: Optional[Sequence['outputs.ClusterIamServiceAccountExternalPermission']] = None,
                 use_service_account_external_permissions: Optional[bool] = None):
        if allow_container_registry is not None:
            pulumi.set(__self__, "allow_container_registry", allow_container_registry)
        if legacy is not None:
            pulumi.set(__self__, "legacy", legacy)
        if permissions_boundary is not None:
            pulumi.set(__self__, "permissions_boundary", permissions_boundary)
        if service_account_external_permissions is not None:
            pulumi.set(__self__, "service_account_external_permissions", service_account_external_permissions)
        if use_service_account_external_permissions is not None:
            pulumi.set(__self__, "use_service_account_external_permissions", use_service_account_external_permissions)

    @property
    @pulumi.getter(name="allowContainerRegistry")
    def allow_container_registry(self) -> Optional[bool]:
        return pulumi.get(self, "allow_container_registry")

    @property
    @pulumi.getter
    def legacy(self) -> Optional[bool]:
        return pulumi.get(self, "legacy")

    @property
    @pulumi.getter(name="permissionsBoundary")
    def permissions_boundary(self) -> Optional[str]:
        return pulumi.get(self, "permissions_boundary")

    @property
    @pulumi.getter(name="serviceAccountExternalPermissions")
    def service_account_external_permissions(self) -> Optional[Sequence['outputs.ClusterIamServiceAccountExternalPermission']]:
        return pulumi.get(self, "service_account_external_permissions")

    @property
    @pulumi.getter(name="useServiceAccountExternalPermissions")
    def use_service_account_external_permissions(self) -> Optional[bool]:
        return pulumi.get(self, "use_service_account_external_permissions")


@pulumi.output_type
class ClusterIamServiceAccountExternalPermission(dict):
    def __init__(__self__, *,
                 aws: Optional['outputs.ClusterIamServiceAccountExternalPermissionAws'] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        :param str name: - (Force new) - String - Name defines the cluster name.
        """
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def aws(self) -> Optional['outputs.ClusterIamServiceAccountExternalPermissionAws']:
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        - (Force new) - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")


@pulumi.output_type
class ClusterIamServiceAccountExternalPermissionAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inlinePolicy":
            suggest = "inline_policy"
        elif key == "policyArNs":
            suggest = "policy_ar_ns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterIamServiceAccountExternalPermissionAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterIamServiceAccountExternalPermissionAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterIamServiceAccountExternalPermissionAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inline_policy: Optional[str] = None,
                 policy_ar_ns: Optional[Sequence[str]] = None):
        if inline_policy is not None:
            pulumi.set(__self__, "inline_policy", inline_policy)
        if policy_ar_ns is not None:
            pulumi.set(__self__, "policy_ar_ns", policy_ar_ns)

    @property
    @pulumi.getter(name="inlinePolicy")
    def inline_policy(self) -> Optional[str]:
        return pulumi.get(self, "inline_policy")

    @property
    @pulumi.getter(name="policyArNs")
    def policy_ar_ns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "policy_ar_ns")


@pulumi.output_type
class ClusterKarpenter(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterKubeApiServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "admissionControlConfigFile":
            suggest = "admission_control_config_file"
        elif key == "admissionControls":
            suggest = "admission_controls"
        elif key == "advertiseAddress":
            suggest = "advertise_address"
        elif key == "allowPrivileged":
            suggest = "allow_privileged"
        elif key == "anonymousAuth":
            suggest = "anonymous_auth"
        elif key == "apiAudiences":
            suggest = "api_audiences"
        elif key == "apiServerCount":
            suggest = "api_server_count"
        elif key == "appendAdmissionPlugins":
            suggest = "append_admission_plugins"
        elif key == "auditDynamicConfiguration":
            suggest = "audit_dynamic_configuration"
        elif key == "auditLogFormat":
            suggest = "audit_log_format"
        elif key == "auditLogMaxAge":
            suggest = "audit_log_max_age"
        elif key == "auditLogMaxBackups":
            suggest = "audit_log_max_backups"
        elif key == "auditLogMaxSize":
            suggest = "audit_log_max_size"
        elif key == "auditLogPath":
            suggest = "audit_log_path"
        elif key == "auditPolicyFile":
            suggest = "audit_policy_file"
        elif key == "auditWebhookBatchBufferSize":
            suggest = "audit_webhook_batch_buffer_size"
        elif key == "auditWebhookBatchMaxSize":
            suggest = "audit_webhook_batch_max_size"
        elif key == "auditWebhookBatchMaxWait":
            suggest = "audit_webhook_batch_max_wait"
        elif key == "auditWebhookBatchThrottleBurst":
            suggest = "audit_webhook_batch_throttle_burst"
        elif key == "auditWebhookBatchThrottleEnable":
            suggest = "audit_webhook_batch_throttle_enable"
        elif key == "auditWebhookBatchThrottleQps":
            suggest = "audit_webhook_batch_throttle_qps"
        elif key == "auditWebhookConfigFile":
            suggest = "audit_webhook_config_file"
        elif key == "auditWebhookInitialBackoff":
            suggest = "audit_webhook_initial_backoff"
        elif key == "auditWebhookMode":
            suggest = "audit_webhook_mode"
        elif key == "authenticationTokenWebhookCacheTtl":
            suggest = "authentication_token_webhook_cache_ttl"
        elif key == "authenticationTokenWebhookConfigFile":
            suggest = "authentication_token_webhook_config_file"
        elif key == "authorizationMode":
            suggest = "authorization_mode"
        elif key == "authorizationRbacSuperUser":
            suggest = "authorization_rbac_super_user"
        elif key == "authorizationWebhookCacheAuthorizedTtl":
            suggest = "authorization_webhook_cache_authorized_ttl"
        elif key == "authorizationWebhookCacheUnauthorizedTtl":
            suggest = "authorization_webhook_cache_unauthorized_ttl"
        elif key == "authorizationWebhookConfigFile":
            suggest = "authorization_webhook_config_file"
        elif key == "basicAuthFile":
            suggest = "basic_auth_file"
        elif key == "bindAddress":
            suggest = "bind_address"
        elif key == "clientCaFile":
            suggest = "client_ca_file"
        elif key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "corsAllowedOrigins":
            suggest = "cors_allowed_origins"
        elif key == "cpuLimit":
            suggest = "cpu_limit"
        elif key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "defaultNotReadyTolerationSeconds":
            suggest = "default_not_ready_toleration_seconds"
        elif key == "defaultUnreachableTolerationSeconds":
            suggest = "default_unreachable_toleration_seconds"
        elif key == "disableAdmissionPlugins":
            suggest = "disable_admission_plugins"
        elif key == "disableBasicAuth":
            suggest = "disable_basic_auth"
        elif key == "enableAdmissionPlugins":
            suggest = "enable_admission_plugins"
        elif key == "enableAggregatorRouting":
            suggest = "enable_aggregator_routing"
        elif key == "enableBootstrapAuthToken":
            suggest = "enable_bootstrap_auth_token"
        elif key == "enableProfiling":
            suggest = "enable_profiling"
        elif key == "encryptionProviderConfig":
            suggest = "encryption_provider_config"
        elif key == "etcdCaFile":
            suggest = "etcd_ca_file"
        elif key == "etcdCertFile":
            suggest = "etcd_cert_file"
        elif key == "etcdKeyFile":
            suggest = "etcd_key_file"
        elif key == "etcdQuorumRead":
            suggest = "etcd_quorum_read"
        elif key == "etcdServers":
            suggest = "etcd_servers"
        elif key == "etcdServersOverrides":
            suggest = "etcd_servers_overrides"
        elif key == "eventTtl":
            suggest = "event_ttl"
        elif key == "experimentalEncryptionProviderConfig":
            suggest = "experimental_encryption_provider_config"
        elif key == "featureGates":
            suggest = "feature_gates"
        elif key == "http2MaxStreamsPerConnection":
            suggest = "http2_max_streams_per_connection"
        elif key == "insecureBindAddress":
            suggest = "insecure_bind_address"
        elif key == "insecurePort":
            suggest = "insecure_port"
        elif key == "kubeletCertificateAuthority":
            suggest = "kubelet_certificate_authority"
        elif key == "kubeletClientCertificate":
            suggest = "kubelet_client_certificate"
        elif key == "kubeletClientKey":
            suggest = "kubelet_client_key"
        elif key == "kubeletPreferredAddressTypes":
            suggest = "kubelet_preferred_address_types"
        elif key == "logFormat":
            suggest = "log_format"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "maxMutatingRequestsInflight":
            suggest = "max_mutating_requests_inflight"
        elif key == "maxRequestsInflight":
            suggest = "max_requests_inflight"
        elif key == "memoryLimit":
            suggest = "memory_limit"
        elif key == "memoryRequest":
            suggest = "memory_request"
        elif key == "minRequestTimeout":
            suggest = "min_request_timeout"
        elif key == "oidcCaFile":
            suggest = "oidc_ca_file"
        elif key == "oidcClientId":
            suggest = "oidc_client_id"
        elif key == "oidcGroupsClaim":
            suggest = "oidc_groups_claim"
        elif key == "oidcGroupsPrefix":
            suggest = "oidc_groups_prefix"
        elif key == "oidcIssuerUrl":
            suggest = "oidc_issuer_url"
        elif key == "oidcRequiredClaims":
            suggest = "oidc_required_claims"
        elif key == "oidcUsernameClaim":
            suggest = "oidc_username_claim"
        elif key == "oidcUsernamePrefix":
            suggest = "oidc_username_prefix"
        elif key == "proxyClientCertFile":
            suggest = "proxy_client_cert_file"
        elif key == "proxyClientKeyFile":
            suggest = "proxy_client_key_file"
        elif key == "requestTimeout":
            suggest = "request_timeout"
        elif key == "requestheaderAllowedNames":
            suggest = "requestheader_allowed_names"
        elif key == "requestheaderClientCaFile":
            suggest = "requestheader_client_ca_file"
        elif key == "requestheaderExtraHeaderPrefixes":
            suggest = "requestheader_extra_header_prefixes"
        elif key == "requestheaderGroupHeaders":
            suggest = "requestheader_group_headers"
        elif key == "requestheaderUsernameHeaders":
            suggest = "requestheader_username_headers"
        elif key == "runtimeConfig":
            suggest = "runtime_config"
        elif key == "securePort":
            suggest = "secure_port"
        elif key == "serviceAccountIssuer":
            suggest = "service_account_issuer"
        elif key == "serviceAccountJwksuri":
            suggest = "service_account_jwksuri"
        elif key == "serviceAccountKeyFiles":
            suggest = "service_account_key_files"
        elif key == "serviceAccountSigningKeyFile":
            suggest = "service_account_signing_key_file"
        elif key == "serviceClusterIpRange":
            suggest = "service_cluster_ip_range"
        elif key == "serviceNodePortRange":
            suggest = "service_node_port_range"
        elif key == "storageBackend":
            suggest = "storage_backend"
        elif key == "targetRamMb":
            suggest = "target_ram_mb"
        elif key == "tlsCertFile":
            suggest = "tls_cert_file"
        elif key == "tlsCipherSuites":
            suggest = "tls_cipher_suites"
        elif key == "tlsMinVersion":
            suggest = "tls_min_version"
        elif key == "tlsPrivateKeyFile":
            suggest = "tls_private_key_file"
        elif key == "tokenAuthFile":
            suggest = "token_auth_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeApiServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeApiServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeApiServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 admission_control_config_file: Optional[str] = None,
                 admission_controls: Optional[Sequence[str]] = None,
                 advertise_address: Optional[str] = None,
                 allow_privileged: Optional[bool] = None,
                 anonymous_auth: Optional['outputs.ClusterKubeApiServerAnonymousAuth'] = None,
                 api_audiences: Optional[Sequence[str]] = None,
                 api_server_count: Optional[int] = None,
                 append_admission_plugins: Optional[Sequence[str]] = None,
                 audit_dynamic_configuration: Optional[bool] = None,
                 audit_log_format: Optional[str] = None,
                 audit_log_max_age: Optional[int] = None,
                 audit_log_max_backups: Optional[int] = None,
                 audit_log_max_size: Optional[int] = None,
                 audit_log_path: Optional[str] = None,
                 audit_policy_file: Optional[str] = None,
                 audit_webhook_batch_buffer_size: Optional[int] = None,
                 audit_webhook_batch_max_size: Optional[int] = None,
                 audit_webhook_batch_max_wait: Optional[str] = None,
                 audit_webhook_batch_throttle_burst: Optional[int] = None,
                 audit_webhook_batch_throttle_enable: Optional[bool] = None,
                 audit_webhook_batch_throttle_qps: Optional[str] = None,
                 audit_webhook_config_file: Optional[str] = None,
                 audit_webhook_initial_backoff: Optional[str] = None,
                 audit_webhook_mode: Optional[str] = None,
                 authentication_token_webhook_cache_ttl: Optional[str] = None,
                 authentication_token_webhook_config_file: Optional[str] = None,
                 authorization_mode: Optional[str] = None,
                 authorization_rbac_super_user: Optional[str] = None,
                 authorization_webhook_cache_authorized_ttl: Optional[str] = None,
                 authorization_webhook_cache_unauthorized_ttl: Optional[str] = None,
                 authorization_webhook_config_file: Optional[str] = None,
                 basic_auth_file: Optional[str] = None,
                 bind_address: Optional[str] = None,
                 client_ca_file: Optional[str] = None,
                 cloud_provider: Optional[str] = None,
                 cors_allowed_origins: Optional[Sequence[str]] = None,
                 cpu_limit: Optional[str] = None,
                 cpu_request: Optional[str] = None,
                 default_not_ready_toleration_seconds: Optional[int] = None,
                 default_unreachable_toleration_seconds: Optional[int] = None,
                 disable_admission_plugins: Optional[Sequence[str]] = None,
                 disable_basic_auth: Optional[bool] = None,
                 enable_admission_plugins: Optional[Sequence[str]] = None,
                 enable_aggregator_routing: Optional[bool] = None,
                 enable_bootstrap_auth_token: Optional[bool] = None,
                 enable_profiling: Optional[bool] = None,
                 encryption_provider_config: Optional[str] = None,
                 etcd_ca_file: Optional[str] = None,
                 etcd_cert_file: Optional[str] = None,
                 etcd_key_file: Optional[str] = None,
                 etcd_quorum_read: Optional[bool] = None,
                 etcd_servers: Optional[Sequence[str]] = None,
                 etcd_servers_overrides: Optional[Sequence[str]] = None,
                 event_ttl: Optional[str] = None,
                 experimental_encryption_provider_config: Optional[str] = None,
                 feature_gates: Optional[Mapping[str, str]] = None,
                 http2_max_streams_per_connection: Optional[int] = None,
                 image: Optional[str] = None,
                 insecure_bind_address: Optional[str] = None,
                 insecure_port: Optional[int] = None,
                 kubelet_certificate_authority: Optional[str] = None,
                 kubelet_client_certificate: Optional[str] = None,
                 kubelet_client_key: Optional[str] = None,
                 kubelet_preferred_address_types: Optional[Sequence[str]] = None,
                 log_format: Optional[str] = None,
                 log_level: Optional[int] = None,
                 max_mutating_requests_inflight: Optional[int] = None,
                 max_requests_inflight: Optional[int] = None,
                 memory_limit: Optional[str] = None,
                 memory_request: Optional[str] = None,
                 min_request_timeout: Optional[int] = None,
                 oidc_ca_file: Optional[str] = None,
                 oidc_client_id: Optional[str] = None,
                 oidc_groups_claim: Optional[str] = None,
                 oidc_groups_prefix: Optional[str] = None,
                 oidc_issuer_url: Optional[str] = None,
                 oidc_required_claims: Optional[Sequence[str]] = None,
                 oidc_username_claim: Optional[str] = None,
                 oidc_username_prefix: Optional[str] = None,
                 proxy_client_cert_file: Optional[str] = None,
                 proxy_client_key_file: Optional[str] = None,
                 request_timeout: Optional[str] = None,
                 requestheader_allowed_names: Optional[Sequence[str]] = None,
                 requestheader_client_ca_file: Optional[str] = None,
                 requestheader_extra_header_prefixes: Optional[Sequence[str]] = None,
                 requestheader_group_headers: Optional[Sequence[str]] = None,
                 requestheader_username_headers: Optional[Sequence[str]] = None,
                 runtime_config: Optional[Mapping[str, str]] = None,
                 secure_port: Optional[int] = None,
                 service_account_issuer: Optional[str] = None,
                 service_account_jwksuri: Optional[str] = None,
                 service_account_key_files: Optional[Sequence[str]] = None,
                 service_account_signing_key_file: Optional[str] = None,
                 service_cluster_ip_range: Optional[str] = None,
                 service_node_port_range: Optional[str] = None,
                 storage_backend: Optional[str] = None,
                 target_ram_mb: Optional[int] = None,
                 tls_cert_file: Optional[str] = None,
                 tls_cipher_suites: Optional[Sequence[str]] = None,
                 tls_min_version: Optional[str] = None,
                 tls_private_key_file: Optional[str] = None,
                 token_auth_file: Optional[str] = None):
        """
        :param str cloud_provider: - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        :param str service_cluster_ip_range: - String - ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if admission_control_config_file is not None:
            pulumi.set(__self__, "admission_control_config_file", admission_control_config_file)
        if admission_controls is not None:
            pulumi.set(__self__, "admission_controls", admission_controls)
        if advertise_address is not None:
            pulumi.set(__self__, "advertise_address", advertise_address)
        if allow_privileged is not None:
            pulumi.set(__self__, "allow_privileged", allow_privileged)
        if anonymous_auth is not None:
            pulumi.set(__self__, "anonymous_auth", anonymous_auth)
        if api_audiences is not None:
            pulumi.set(__self__, "api_audiences", api_audiences)
        if api_server_count is not None:
            pulumi.set(__self__, "api_server_count", api_server_count)
        if append_admission_plugins is not None:
            pulumi.set(__self__, "append_admission_plugins", append_admission_plugins)
        if audit_dynamic_configuration is not None:
            pulumi.set(__self__, "audit_dynamic_configuration", audit_dynamic_configuration)
        if audit_log_format is not None:
            pulumi.set(__self__, "audit_log_format", audit_log_format)
        if audit_log_max_age is not None:
            pulumi.set(__self__, "audit_log_max_age", audit_log_max_age)
        if audit_log_max_backups is not None:
            pulumi.set(__self__, "audit_log_max_backups", audit_log_max_backups)
        if audit_log_max_size is not None:
            pulumi.set(__self__, "audit_log_max_size", audit_log_max_size)
        if audit_log_path is not None:
            pulumi.set(__self__, "audit_log_path", audit_log_path)
        if audit_policy_file is not None:
            pulumi.set(__self__, "audit_policy_file", audit_policy_file)
        if audit_webhook_batch_buffer_size is not None:
            pulumi.set(__self__, "audit_webhook_batch_buffer_size", audit_webhook_batch_buffer_size)
        if audit_webhook_batch_max_size is not None:
            pulumi.set(__self__, "audit_webhook_batch_max_size", audit_webhook_batch_max_size)
        if audit_webhook_batch_max_wait is not None:
            pulumi.set(__self__, "audit_webhook_batch_max_wait", audit_webhook_batch_max_wait)
        if audit_webhook_batch_throttle_burst is not None:
            pulumi.set(__self__, "audit_webhook_batch_throttle_burst", audit_webhook_batch_throttle_burst)
        if audit_webhook_batch_throttle_enable is not None:
            pulumi.set(__self__, "audit_webhook_batch_throttle_enable", audit_webhook_batch_throttle_enable)
        if audit_webhook_batch_throttle_qps is not None:
            pulumi.set(__self__, "audit_webhook_batch_throttle_qps", audit_webhook_batch_throttle_qps)
        if audit_webhook_config_file is not None:
            pulumi.set(__self__, "audit_webhook_config_file", audit_webhook_config_file)
        if audit_webhook_initial_backoff is not None:
            pulumi.set(__self__, "audit_webhook_initial_backoff", audit_webhook_initial_backoff)
        if audit_webhook_mode is not None:
            pulumi.set(__self__, "audit_webhook_mode", audit_webhook_mode)
        if authentication_token_webhook_cache_ttl is not None:
            pulumi.set(__self__, "authentication_token_webhook_cache_ttl", authentication_token_webhook_cache_ttl)
        if authentication_token_webhook_config_file is not None:
            pulumi.set(__self__, "authentication_token_webhook_config_file", authentication_token_webhook_config_file)
        if authorization_mode is not None:
            pulumi.set(__self__, "authorization_mode", authorization_mode)
        if authorization_rbac_super_user is not None:
            pulumi.set(__self__, "authorization_rbac_super_user", authorization_rbac_super_user)
        if authorization_webhook_cache_authorized_ttl is not None:
            pulumi.set(__self__, "authorization_webhook_cache_authorized_ttl", authorization_webhook_cache_authorized_ttl)
        if authorization_webhook_cache_unauthorized_ttl is not None:
            pulumi.set(__self__, "authorization_webhook_cache_unauthorized_ttl", authorization_webhook_cache_unauthorized_ttl)
        if authorization_webhook_config_file is not None:
            pulumi.set(__self__, "authorization_webhook_config_file", authorization_webhook_config_file)
        if basic_auth_file is not None:
            pulumi.set(__self__, "basic_auth_file", basic_auth_file)
        if bind_address is not None:
            pulumi.set(__self__, "bind_address", bind_address)
        if client_ca_file is not None:
            pulumi.set(__self__, "client_ca_file", client_ca_file)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if cors_allowed_origins is not None:
            pulumi.set(__self__, "cors_allowed_origins", cors_allowed_origins)
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if default_not_ready_toleration_seconds is not None:
            pulumi.set(__self__, "default_not_ready_toleration_seconds", default_not_ready_toleration_seconds)
        if default_unreachable_toleration_seconds is not None:
            pulumi.set(__self__, "default_unreachable_toleration_seconds", default_unreachable_toleration_seconds)
        if disable_admission_plugins is not None:
            pulumi.set(__self__, "disable_admission_plugins", disable_admission_plugins)
        if disable_basic_auth is not None:
            pulumi.set(__self__, "disable_basic_auth", disable_basic_auth)
        if enable_admission_plugins is not None:
            pulumi.set(__self__, "enable_admission_plugins", enable_admission_plugins)
        if enable_aggregator_routing is not None:
            pulumi.set(__self__, "enable_aggregator_routing", enable_aggregator_routing)
        if enable_bootstrap_auth_token is not None:
            pulumi.set(__self__, "enable_bootstrap_auth_token", enable_bootstrap_auth_token)
        if enable_profiling is not None:
            pulumi.set(__self__, "enable_profiling", enable_profiling)
        if encryption_provider_config is not None:
            pulumi.set(__self__, "encryption_provider_config", encryption_provider_config)
        if etcd_ca_file is not None:
            pulumi.set(__self__, "etcd_ca_file", etcd_ca_file)
        if etcd_cert_file is not None:
            pulumi.set(__self__, "etcd_cert_file", etcd_cert_file)
        if etcd_key_file is not None:
            pulumi.set(__self__, "etcd_key_file", etcd_key_file)
        if etcd_quorum_read is not None:
            pulumi.set(__self__, "etcd_quorum_read", etcd_quorum_read)
        if etcd_servers is not None:
            pulumi.set(__self__, "etcd_servers", etcd_servers)
        if etcd_servers_overrides is not None:
            pulumi.set(__self__, "etcd_servers_overrides", etcd_servers_overrides)
        if event_ttl is not None:
            pulumi.set(__self__, "event_ttl", event_ttl)
        if experimental_encryption_provider_config is not None:
            pulumi.set(__self__, "experimental_encryption_provider_config", experimental_encryption_provider_config)
        if feature_gates is not None:
            pulumi.set(__self__, "feature_gates", feature_gates)
        if http2_max_streams_per_connection is not None:
            pulumi.set(__self__, "http2_max_streams_per_connection", http2_max_streams_per_connection)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if insecure_bind_address is not None:
            pulumi.set(__self__, "insecure_bind_address", insecure_bind_address)
        if insecure_port is not None:
            pulumi.set(__self__, "insecure_port", insecure_port)
        if kubelet_certificate_authority is not None:
            pulumi.set(__self__, "kubelet_certificate_authority", kubelet_certificate_authority)
        if kubelet_client_certificate is not None:
            pulumi.set(__self__, "kubelet_client_certificate", kubelet_client_certificate)
        if kubelet_client_key is not None:
            pulumi.set(__self__, "kubelet_client_key", kubelet_client_key)
        if kubelet_preferred_address_types is not None:
            pulumi.set(__self__, "kubelet_preferred_address_types", kubelet_preferred_address_types)
        if log_format is not None:
            pulumi.set(__self__, "log_format", log_format)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if max_mutating_requests_inflight is not None:
            pulumi.set(__self__, "max_mutating_requests_inflight", max_mutating_requests_inflight)
        if max_requests_inflight is not None:
            pulumi.set(__self__, "max_requests_inflight", max_requests_inflight)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)
        if min_request_timeout is not None:
            pulumi.set(__self__, "min_request_timeout", min_request_timeout)
        if oidc_ca_file is not None:
            pulumi.set(__self__, "oidc_ca_file", oidc_ca_file)
        if oidc_client_id is not None:
            pulumi.set(__self__, "oidc_client_id", oidc_client_id)
        if oidc_groups_claim is not None:
            pulumi.set(__self__, "oidc_groups_claim", oidc_groups_claim)
        if oidc_groups_prefix is not None:
            pulumi.set(__self__, "oidc_groups_prefix", oidc_groups_prefix)
        if oidc_issuer_url is not None:
            pulumi.set(__self__, "oidc_issuer_url", oidc_issuer_url)
        if oidc_required_claims is not None:
            pulumi.set(__self__, "oidc_required_claims", oidc_required_claims)
        if oidc_username_claim is not None:
            pulumi.set(__self__, "oidc_username_claim", oidc_username_claim)
        if oidc_username_prefix is not None:
            pulumi.set(__self__, "oidc_username_prefix", oidc_username_prefix)
        if proxy_client_cert_file is not None:
            pulumi.set(__self__, "proxy_client_cert_file", proxy_client_cert_file)
        if proxy_client_key_file is not None:
            pulumi.set(__self__, "proxy_client_key_file", proxy_client_key_file)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)
        if requestheader_allowed_names is not None:
            pulumi.set(__self__, "requestheader_allowed_names", requestheader_allowed_names)
        if requestheader_client_ca_file is not None:
            pulumi.set(__self__, "requestheader_client_ca_file", requestheader_client_ca_file)
        if requestheader_extra_header_prefixes is not None:
            pulumi.set(__self__, "requestheader_extra_header_prefixes", requestheader_extra_header_prefixes)
        if requestheader_group_headers is not None:
            pulumi.set(__self__, "requestheader_group_headers", requestheader_group_headers)
        if requestheader_username_headers is not None:
            pulumi.set(__self__, "requestheader_username_headers", requestheader_username_headers)
        if runtime_config is not None:
            pulumi.set(__self__, "runtime_config", runtime_config)
        if secure_port is not None:
            pulumi.set(__self__, "secure_port", secure_port)
        if service_account_issuer is not None:
            pulumi.set(__self__, "service_account_issuer", service_account_issuer)
        if service_account_jwksuri is not None:
            pulumi.set(__self__, "service_account_jwksuri", service_account_jwksuri)
        if service_account_key_files is not None:
            pulumi.set(__self__, "service_account_key_files", service_account_key_files)
        if service_account_signing_key_file is not None:
            pulumi.set(__self__, "service_account_signing_key_file", service_account_signing_key_file)
        if service_cluster_ip_range is not None:
            pulumi.set(__self__, "service_cluster_ip_range", service_cluster_ip_range)
        if service_node_port_range is not None:
            pulumi.set(__self__, "service_node_port_range", service_node_port_range)
        if storage_backend is not None:
            pulumi.set(__self__, "storage_backend", storage_backend)
        if target_ram_mb is not None:
            pulumi.set(__self__, "target_ram_mb", target_ram_mb)
        if tls_cert_file is not None:
            pulumi.set(__self__, "tls_cert_file", tls_cert_file)
        if tls_cipher_suites is not None:
            pulumi.set(__self__, "tls_cipher_suites", tls_cipher_suites)
        if tls_min_version is not None:
            pulumi.set(__self__, "tls_min_version", tls_min_version)
        if tls_private_key_file is not None:
            pulumi.set(__self__, "tls_private_key_file", tls_private_key_file)
        if token_auth_file is not None:
            pulumi.set(__self__, "token_auth_file", token_auth_file)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="admissionControlConfigFile")
    def admission_control_config_file(self) -> Optional[str]:
        return pulumi.get(self, "admission_control_config_file")

    @property
    @pulumi.getter(name="admissionControls")
    def admission_controls(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "admission_controls")

    @property
    @pulumi.getter(name="advertiseAddress")
    def advertise_address(self) -> Optional[str]:
        return pulumi.get(self, "advertise_address")

    @property
    @pulumi.getter(name="allowPrivileged")
    def allow_privileged(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privileged")

    @property
    @pulumi.getter(name="anonymousAuth")
    def anonymous_auth(self) -> Optional['outputs.ClusterKubeApiServerAnonymousAuth']:
        return pulumi.get(self, "anonymous_auth")

    @property
    @pulumi.getter(name="apiAudiences")
    def api_audiences(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "api_audiences")

    @property
    @pulumi.getter(name="apiServerCount")
    def api_server_count(self) -> Optional[int]:
        return pulumi.get(self, "api_server_count")

    @property
    @pulumi.getter(name="appendAdmissionPlugins")
    def append_admission_plugins(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "append_admission_plugins")

    @property
    @pulumi.getter(name="auditDynamicConfiguration")
    def audit_dynamic_configuration(self) -> Optional[bool]:
        return pulumi.get(self, "audit_dynamic_configuration")

    @property
    @pulumi.getter(name="auditLogFormat")
    def audit_log_format(self) -> Optional[str]:
        return pulumi.get(self, "audit_log_format")

    @property
    @pulumi.getter(name="auditLogMaxAge")
    def audit_log_max_age(self) -> Optional[int]:
        return pulumi.get(self, "audit_log_max_age")

    @property
    @pulumi.getter(name="auditLogMaxBackups")
    def audit_log_max_backups(self) -> Optional[int]:
        return pulumi.get(self, "audit_log_max_backups")

    @property
    @pulumi.getter(name="auditLogMaxSize")
    def audit_log_max_size(self) -> Optional[int]:
        return pulumi.get(self, "audit_log_max_size")

    @property
    @pulumi.getter(name="auditLogPath")
    def audit_log_path(self) -> Optional[str]:
        return pulumi.get(self, "audit_log_path")

    @property
    @pulumi.getter(name="auditPolicyFile")
    def audit_policy_file(self) -> Optional[str]:
        return pulumi.get(self, "audit_policy_file")

    @property
    @pulumi.getter(name="auditWebhookBatchBufferSize")
    def audit_webhook_batch_buffer_size(self) -> Optional[int]:
        return pulumi.get(self, "audit_webhook_batch_buffer_size")

    @property
    @pulumi.getter(name="auditWebhookBatchMaxSize")
    def audit_webhook_batch_max_size(self) -> Optional[int]:
        return pulumi.get(self, "audit_webhook_batch_max_size")

    @property
    @pulumi.getter(name="auditWebhookBatchMaxWait")
    def audit_webhook_batch_max_wait(self) -> Optional[str]:
        return pulumi.get(self, "audit_webhook_batch_max_wait")

    @property
    @pulumi.getter(name="auditWebhookBatchThrottleBurst")
    def audit_webhook_batch_throttle_burst(self) -> Optional[int]:
        return pulumi.get(self, "audit_webhook_batch_throttle_burst")

    @property
    @pulumi.getter(name="auditWebhookBatchThrottleEnable")
    def audit_webhook_batch_throttle_enable(self) -> Optional[bool]:
        return pulumi.get(self, "audit_webhook_batch_throttle_enable")

    @property
    @pulumi.getter(name="auditWebhookBatchThrottleQps")
    def audit_webhook_batch_throttle_qps(self) -> Optional[str]:
        return pulumi.get(self, "audit_webhook_batch_throttle_qps")

    @property
    @pulumi.getter(name="auditWebhookConfigFile")
    def audit_webhook_config_file(self) -> Optional[str]:
        return pulumi.get(self, "audit_webhook_config_file")

    @property
    @pulumi.getter(name="auditWebhookInitialBackoff")
    def audit_webhook_initial_backoff(self) -> Optional[str]:
        return pulumi.get(self, "audit_webhook_initial_backoff")

    @property
    @pulumi.getter(name="auditWebhookMode")
    def audit_webhook_mode(self) -> Optional[str]:
        return pulumi.get(self, "audit_webhook_mode")

    @property
    @pulumi.getter(name="authenticationTokenWebhookCacheTtl")
    def authentication_token_webhook_cache_ttl(self) -> Optional[str]:
        return pulumi.get(self, "authentication_token_webhook_cache_ttl")

    @property
    @pulumi.getter(name="authenticationTokenWebhookConfigFile")
    def authentication_token_webhook_config_file(self) -> Optional[str]:
        return pulumi.get(self, "authentication_token_webhook_config_file")

    @property
    @pulumi.getter(name="authorizationMode")
    def authorization_mode(self) -> Optional[str]:
        return pulumi.get(self, "authorization_mode")

    @property
    @pulumi.getter(name="authorizationRbacSuperUser")
    def authorization_rbac_super_user(self) -> Optional[str]:
        return pulumi.get(self, "authorization_rbac_super_user")

    @property
    @pulumi.getter(name="authorizationWebhookCacheAuthorizedTtl")
    def authorization_webhook_cache_authorized_ttl(self) -> Optional[str]:
        return pulumi.get(self, "authorization_webhook_cache_authorized_ttl")

    @property
    @pulumi.getter(name="authorizationWebhookCacheUnauthorizedTtl")
    def authorization_webhook_cache_unauthorized_ttl(self) -> Optional[str]:
        return pulumi.get(self, "authorization_webhook_cache_unauthorized_ttl")

    @property
    @pulumi.getter(name="authorizationWebhookConfigFile")
    def authorization_webhook_config_file(self) -> Optional[str]:
        return pulumi.get(self, "authorization_webhook_config_file")

    @property
    @pulumi.getter(name="basicAuthFile")
    def basic_auth_file(self) -> Optional[str]:
        return pulumi.get(self, "basic_auth_file")

    @property
    @pulumi.getter(name="bindAddress")
    def bind_address(self) -> Optional[str]:
        return pulumi.get(self, "bind_address")

    @property
    @pulumi.getter(name="clientCaFile")
    def client_ca_file(self) -> Optional[str]:
        return pulumi.get(self, "client_ca_file")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[str]:
        """
        - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="corsAllowedOrigins")
    def cors_allowed_origins(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cors_allowed_origins")

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[str]:
        return pulumi.get(self, "cpu_limit")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[str]:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter(name="defaultNotReadyTolerationSeconds")
    def default_not_ready_toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "default_not_ready_toleration_seconds")

    @property
    @pulumi.getter(name="defaultUnreachableTolerationSeconds")
    def default_unreachable_toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "default_unreachable_toleration_seconds")

    @property
    @pulumi.getter(name="disableAdmissionPlugins")
    def disable_admission_plugins(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "disable_admission_plugins")

    @property
    @pulumi.getter(name="disableBasicAuth")
    def disable_basic_auth(self) -> Optional[bool]:
        return pulumi.get(self, "disable_basic_auth")

    @property
    @pulumi.getter(name="enableAdmissionPlugins")
    def enable_admission_plugins(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "enable_admission_plugins")

    @property
    @pulumi.getter(name="enableAggregatorRouting")
    def enable_aggregator_routing(self) -> Optional[bool]:
        return pulumi.get(self, "enable_aggregator_routing")

    @property
    @pulumi.getter(name="enableBootstrapAuthToken")
    def enable_bootstrap_auth_token(self) -> Optional[bool]:
        return pulumi.get(self, "enable_bootstrap_auth_token")

    @property
    @pulumi.getter(name="enableProfiling")
    def enable_profiling(self) -> Optional[bool]:
        return pulumi.get(self, "enable_profiling")

    @property
    @pulumi.getter(name="encryptionProviderConfig")
    def encryption_provider_config(self) -> Optional[str]:
        return pulumi.get(self, "encryption_provider_config")

    @property
    @pulumi.getter(name="etcdCaFile")
    def etcd_ca_file(self) -> Optional[str]:
        return pulumi.get(self, "etcd_ca_file")

    @property
    @pulumi.getter(name="etcdCertFile")
    def etcd_cert_file(self) -> Optional[str]:
        return pulumi.get(self, "etcd_cert_file")

    @property
    @pulumi.getter(name="etcdKeyFile")
    def etcd_key_file(self) -> Optional[str]:
        return pulumi.get(self, "etcd_key_file")

    @property
    @pulumi.getter(name="etcdQuorumRead")
    def etcd_quorum_read(self) -> Optional[bool]:
        return pulumi.get(self, "etcd_quorum_read")

    @property
    @pulumi.getter(name="etcdServers")
    def etcd_servers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "etcd_servers")

    @property
    @pulumi.getter(name="etcdServersOverrides")
    def etcd_servers_overrides(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "etcd_servers_overrides")

    @property
    @pulumi.getter(name="eventTtl")
    def event_ttl(self) -> Optional[str]:
        return pulumi.get(self, "event_ttl")

    @property
    @pulumi.getter(name="experimentalEncryptionProviderConfig")
    def experimental_encryption_provider_config(self) -> Optional[str]:
        return pulumi.get(self, "experimental_encryption_provider_config")

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "feature_gates")

    @property
    @pulumi.getter(name="http2MaxStreamsPerConnection")
    def http2_max_streams_per_connection(self) -> Optional[int]:
        return pulumi.get(self, "http2_max_streams_per_connection")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="insecureBindAddress")
    def insecure_bind_address(self) -> Optional[str]:
        return pulumi.get(self, "insecure_bind_address")

    @property
    @pulumi.getter(name="insecurePort")
    def insecure_port(self) -> Optional[int]:
        return pulumi.get(self, "insecure_port")

    @property
    @pulumi.getter(name="kubeletCertificateAuthority")
    def kubelet_certificate_authority(self) -> Optional[str]:
        return pulumi.get(self, "kubelet_certificate_authority")

    @property
    @pulumi.getter(name="kubeletClientCertificate")
    def kubelet_client_certificate(self) -> Optional[str]:
        return pulumi.get(self, "kubelet_client_certificate")

    @property
    @pulumi.getter(name="kubeletClientKey")
    def kubelet_client_key(self) -> Optional[str]:
        return pulumi.get(self, "kubelet_client_key")

    @property
    @pulumi.getter(name="kubeletPreferredAddressTypes")
    def kubelet_preferred_address_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "kubelet_preferred_address_types")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> Optional[str]:
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[int]:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="maxMutatingRequestsInflight")
    def max_mutating_requests_inflight(self) -> Optional[int]:
        return pulumi.get(self, "max_mutating_requests_inflight")

    @property
    @pulumi.getter(name="maxRequestsInflight")
    def max_requests_inflight(self) -> Optional[int]:
        return pulumi.get(self, "max_requests_inflight")

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[str]:
        return pulumi.get(self, "memory_limit")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[str]:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter(name="minRequestTimeout")
    def min_request_timeout(self) -> Optional[int]:
        return pulumi.get(self, "min_request_timeout")

    @property
    @pulumi.getter(name="oidcCaFile")
    def oidc_ca_file(self) -> Optional[str]:
        return pulumi.get(self, "oidc_ca_file")

    @property
    @pulumi.getter(name="oidcClientId")
    def oidc_client_id(self) -> Optional[str]:
        return pulumi.get(self, "oidc_client_id")

    @property
    @pulumi.getter(name="oidcGroupsClaim")
    def oidc_groups_claim(self) -> Optional[str]:
        return pulumi.get(self, "oidc_groups_claim")

    @property
    @pulumi.getter(name="oidcGroupsPrefix")
    def oidc_groups_prefix(self) -> Optional[str]:
        return pulumi.get(self, "oidc_groups_prefix")

    @property
    @pulumi.getter(name="oidcIssuerUrl")
    def oidc_issuer_url(self) -> Optional[str]:
        return pulumi.get(self, "oidc_issuer_url")

    @property
    @pulumi.getter(name="oidcRequiredClaims")
    def oidc_required_claims(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "oidc_required_claims")

    @property
    @pulumi.getter(name="oidcUsernameClaim")
    def oidc_username_claim(self) -> Optional[str]:
        return pulumi.get(self, "oidc_username_claim")

    @property
    @pulumi.getter(name="oidcUsernamePrefix")
    def oidc_username_prefix(self) -> Optional[str]:
        return pulumi.get(self, "oidc_username_prefix")

    @property
    @pulumi.getter(name="proxyClientCertFile")
    def proxy_client_cert_file(self) -> Optional[str]:
        return pulumi.get(self, "proxy_client_cert_file")

    @property
    @pulumi.getter(name="proxyClientKeyFile")
    def proxy_client_key_file(self) -> Optional[str]:
        return pulumi.get(self, "proxy_client_key_file")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[str]:
        return pulumi.get(self, "request_timeout")

    @property
    @pulumi.getter(name="requestheaderAllowedNames")
    def requestheader_allowed_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "requestheader_allowed_names")

    @property
    @pulumi.getter(name="requestheaderClientCaFile")
    def requestheader_client_ca_file(self) -> Optional[str]:
        return pulumi.get(self, "requestheader_client_ca_file")

    @property
    @pulumi.getter(name="requestheaderExtraHeaderPrefixes")
    def requestheader_extra_header_prefixes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "requestheader_extra_header_prefixes")

    @property
    @pulumi.getter(name="requestheaderGroupHeaders")
    def requestheader_group_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "requestheader_group_headers")

    @property
    @pulumi.getter(name="requestheaderUsernameHeaders")
    def requestheader_username_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "requestheader_username_headers")

    @property
    @pulumi.getter(name="runtimeConfig")
    def runtime_config(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "runtime_config")

    @property
    @pulumi.getter(name="securePort")
    def secure_port(self) -> Optional[int]:
        return pulumi.get(self, "secure_port")

    @property
    @pulumi.getter(name="serviceAccountIssuer")
    def service_account_issuer(self) -> Optional[str]:
        return pulumi.get(self, "service_account_issuer")

    @property
    @pulumi.getter(name="serviceAccountJwksuri")
    def service_account_jwksuri(self) -> Optional[str]:
        return pulumi.get(self, "service_account_jwksuri")

    @property
    @pulumi.getter(name="serviceAccountKeyFiles")
    def service_account_key_files(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "service_account_key_files")

    @property
    @pulumi.getter(name="serviceAccountSigningKeyFile")
    def service_account_signing_key_file(self) -> Optional[str]:
        return pulumi.get(self, "service_account_signing_key_file")

    @property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> Optional[str]:
        """
        - String - ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services.
        """
        return pulumi.get(self, "service_cluster_ip_range")

    @property
    @pulumi.getter(name="serviceNodePortRange")
    def service_node_port_range(self) -> Optional[str]:
        return pulumi.get(self, "service_node_port_range")

    @property
    @pulumi.getter(name="storageBackend")
    def storage_backend(self) -> Optional[str]:
        return pulumi.get(self, "storage_backend")

    @property
    @pulumi.getter(name="targetRamMb")
    def target_ram_mb(self) -> Optional[int]:
        return pulumi.get(self, "target_ram_mb")

    @property
    @pulumi.getter(name="tlsCertFile")
    def tls_cert_file(self) -> Optional[str]:
        return pulumi.get(self, "tls_cert_file")

    @property
    @pulumi.getter(name="tlsCipherSuites")
    def tls_cipher_suites(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tls_cipher_suites")

    @property
    @pulumi.getter(name="tlsMinVersion")
    def tls_min_version(self) -> Optional[str]:
        return pulumi.get(self, "tls_min_version")

    @property
    @pulumi.getter(name="tlsPrivateKeyFile")
    def tls_private_key_file(self) -> Optional[str]:
        return pulumi.get(self, "tls_private_key_file")

    @property
    @pulumi.getter(name="tokenAuthFile")
    def token_auth_file(self) -> Optional[str]:
        return pulumi.get(self, "token_auth_file")


@pulumi.output_type
class ClusterKubeApiServerAnonymousAuth(dict):
    def __init__(__self__, *,
                 value: Optional[bool] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[bool]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterKubeControllerManager(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocateNodeCidrs":
            suggest = "allocate_node_cidrs"
        elif key == "attachDetachReconcileSyncPeriod":
            suggest = "attach_detach_reconcile_sync_period"
        elif key == "authenticationKubeconfig":
            suggest = "authentication_kubeconfig"
        elif key == "authorizationAlwaysAllowPaths":
            suggest = "authorization_always_allow_paths"
        elif key == "authorizationKubeconfig":
            suggest = "authorization_kubeconfig"
        elif key == "cidrAllocatorType":
            suggest = "cidr_allocator_type"
        elif key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "clusterCidr":
            suggest = "cluster_cidr"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "concurrentDeploymentSyncs":
            suggest = "concurrent_deployment_syncs"
        elif key == "concurrentEndpointSyncs":
            suggest = "concurrent_endpoint_syncs"
        elif key == "concurrentNamespaceSyncs":
            suggest = "concurrent_namespace_syncs"
        elif key == "concurrentRcSyncs":
            suggest = "concurrent_rc_syncs"
        elif key == "concurrentReplicasetSyncs":
            suggest = "concurrent_replicaset_syncs"
        elif key == "concurrentResourceQuotaSyncs":
            suggest = "concurrent_resource_quota_syncs"
        elif key == "concurrentServiceSyncs":
            suggest = "concurrent_service_syncs"
        elif key == "concurrentServiceaccountTokenSyncs":
            suggest = "concurrent_serviceaccount_token_syncs"
        elif key == "configureCloudRoutes":
            suggest = "configure_cloud_routes"
        elif key == "disableAttachDetachReconcileSync":
            suggest = "disable_attach_detach_reconcile_sync"
        elif key == "enableLeaderMigration":
            suggest = "enable_leader_migration"
        elif key == "enableProfiling":
            suggest = "enable_profiling"
        elif key == "experimentalClusterSigningDuration":
            suggest = "experimental_cluster_signing_duration"
        elif key == "externalCloudVolumePlugin":
            suggest = "external_cloud_volume_plugin"
        elif key == "featureGates":
            suggest = "feature_gates"
        elif key == "horizontalPodAutoscalerCpuInitializationPeriod":
            suggest = "horizontal_pod_autoscaler_cpu_initialization_period"
        elif key == "horizontalPodAutoscalerDownscaleDelay":
            suggest = "horizontal_pod_autoscaler_downscale_delay"
        elif key == "horizontalPodAutoscalerDownscaleStabilization":
            suggest = "horizontal_pod_autoscaler_downscale_stabilization"
        elif key == "horizontalPodAutoscalerInitialReadinessDelay":
            suggest = "horizontal_pod_autoscaler_initial_readiness_delay"
        elif key == "horizontalPodAutoscalerSyncPeriod":
            suggest = "horizontal_pod_autoscaler_sync_period"
        elif key == "horizontalPodAutoscalerTolerance":
            suggest = "horizontal_pod_autoscaler_tolerance"
        elif key == "horizontalPodAutoscalerUpscaleDelay":
            suggest = "horizontal_pod_autoscaler_upscale_delay"
        elif key == "horizontalPodAutoscalerUseRestClients":
            suggest = "horizontal_pod_autoscaler_use_rest_clients"
        elif key == "kubeApiBurst":
            suggest = "kube_api_burst"
        elif key == "kubeApiQps":
            suggest = "kube_api_qps"
        elif key == "leaderElection":
            suggest = "leader_election"
        elif key == "logFormat":
            suggest = "log_format"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "minResyncPeriod":
            suggest = "min_resync_period"
        elif key == "nodeCidrMaskSize":
            suggest = "node_cidr_mask_size"
        elif key == "nodeMonitorGracePeriod":
            suggest = "node_monitor_grace_period"
        elif key == "nodeMonitorPeriod":
            suggest = "node_monitor_period"
        elif key == "podEvictionTimeout":
            suggest = "pod_eviction_timeout"
        elif key == "rootCaFile":
            suggest = "root_ca_file"
        elif key == "serviceAccountPrivateKeyFile":
            suggest = "service_account_private_key_file"
        elif key == "terminatedPodGcThreshold":
            suggest = "terminated_pod_gc_threshold"
        elif key == "tlsCertFile":
            suggest = "tls_cert_file"
        elif key == "tlsCipherSuites":
            suggest = "tls_cipher_suites"
        elif key == "tlsMinVersion":
            suggest = "tls_min_version"
        elif key == "tlsPrivateKeyFile":
            suggest = "tls_private_key_file"
        elif key == "useServiceAccountCredentials":
            suggest = "use_service_account_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeControllerManager. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeControllerManager.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeControllerManager.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocate_node_cidrs: Optional[bool] = None,
                 attach_detach_reconcile_sync_period: Optional[str] = None,
                 authentication_kubeconfig: Optional[str] = None,
                 authorization_always_allow_paths: Optional[Sequence[str]] = None,
                 authorization_kubeconfig: Optional[str] = None,
                 cidr_allocator_type: Optional[str] = None,
                 cloud_provider: Optional[str] = None,
                 cluster_cidr: Optional[str] = None,
                 cluster_name: Optional[str] = None,
                 concurrent_deployment_syncs: Optional[int] = None,
                 concurrent_endpoint_syncs: Optional[int] = None,
                 concurrent_namespace_syncs: Optional[int] = None,
                 concurrent_rc_syncs: Optional[int] = None,
                 concurrent_replicaset_syncs: Optional[int] = None,
                 concurrent_resource_quota_syncs: Optional[int] = None,
                 concurrent_service_syncs: Optional[int] = None,
                 concurrent_serviceaccount_token_syncs: Optional[int] = None,
                 configure_cloud_routes: Optional[bool] = None,
                 controllers: Optional[Sequence[str]] = None,
                 disable_attach_detach_reconcile_sync: Optional[bool] = None,
                 enable_leader_migration: Optional[bool] = None,
                 enable_profiling: Optional[bool] = None,
                 experimental_cluster_signing_duration: Optional[str] = None,
                 external_cloud_volume_plugin: Optional[str] = None,
                 feature_gates: Optional[Mapping[str, str]] = None,
                 horizontal_pod_autoscaler_cpu_initialization_period: Optional[str] = None,
                 horizontal_pod_autoscaler_downscale_delay: Optional[str] = None,
                 horizontal_pod_autoscaler_downscale_stabilization: Optional[str] = None,
                 horizontal_pod_autoscaler_initial_readiness_delay: Optional[str] = None,
                 horizontal_pod_autoscaler_sync_period: Optional[str] = None,
                 horizontal_pod_autoscaler_tolerance: Optional[str] = None,
                 horizontal_pod_autoscaler_upscale_delay: Optional[str] = None,
                 horizontal_pod_autoscaler_use_rest_clients: Optional[bool] = None,
                 image: Optional[str] = None,
                 kube_api_burst: Optional[int] = None,
                 kube_api_qps: Optional[str] = None,
                 leader_election: Optional['outputs.ClusterKubeControllerManagerLeaderElection'] = None,
                 log_format: Optional[str] = None,
                 log_level: Optional[int] = None,
                 master: Optional[str] = None,
                 min_resync_period: Optional[str] = None,
                 node_cidr_mask_size: Optional[int] = None,
                 node_monitor_grace_period: Optional[str] = None,
                 node_monitor_period: Optional[str] = None,
                 pod_eviction_timeout: Optional[str] = None,
                 root_ca_file: Optional[str] = None,
                 service_account_private_key_file: Optional[str] = None,
                 terminated_pod_gc_threshold: Optional[int] = None,
                 tls_cert_file: Optional[str] = None,
                 tls_cipher_suites: Optional[Sequence[str]] = None,
                 tls_min_version: Optional[str] = None,
                 tls_private_key_file: Optional[str] = None,
                 use_service_account_credentials: Optional[bool] = None):
        """
        :param str cloud_provider: - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        """
        if allocate_node_cidrs is not None:
            pulumi.set(__self__, "allocate_node_cidrs", allocate_node_cidrs)
        if attach_detach_reconcile_sync_period is not None:
            pulumi.set(__self__, "attach_detach_reconcile_sync_period", attach_detach_reconcile_sync_period)
        if authentication_kubeconfig is not None:
            pulumi.set(__self__, "authentication_kubeconfig", authentication_kubeconfig)
        if authorization_always_allow_paths is not None:
            pulumi.set(__self__, "authorization_always_allow_paths", authorization_always_allow_paths)
        if authorization_kubeconfig is not None:
            pulumi.set(__self__, "authorization_kubeconfig", authorization_kubeconfig)
        if cidr_allocator_type is not None:
            pulumi.set(__self__, "cidr_allocator_type", cidr_allocator_type)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if cluster_cidr is not None:
            pulumi.set(__self__, "cluster_cidr", cluster_cidr)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if concurrent_deployment_syncs is not None:
            pulumi.set(__self__, "concurrent_deployment_syncs", concurrent_deployment_syncs)
        if concurrent_endpoint_syncs is not None:
            pulumi.set(__self__, "concurrent_endpoint_syncs", concurrent_endpoint_syncs)
        if concurrent_namespace_syncs is not None:
            pulumi.set(__self__, "concurrent_namespace_syncs", concurrent_namespace_syncs)
        if concurrent_rc_syncs is not None:
            pulumi.set(__self__, "concurrent_rc_syncs", concurrent_rc_syncs)
        if concurrent_replicaset_syncs is not None:
            pulumi.set(__self__, "concurrent_replicaset_syncs", concurrent_replicaset_syncs)
        if concurrent_resource_quota_syncs is not None:
            pulumi.set(__self__, "concurrent_resource_quota_syncs", concurrent_resource_quota_syncs)
        if concurrent_service_syncs is not None:
            pulumi.set(__self__, "concurrent_service_syncs", concurrent_service_syncs)
        if concurrent_serviceaccount_token_syncs is not None:
            pulumi.set(__self__, "concurrent_serviceaccount_token_syncs", concurrent_serviceaccount_token_syncs)
        if configure_cloud_routes is not None:
            pulumi.set(__self__, "configure_cloud_routes", configure_cloud_routes)
        if controllers is not None:
            pulumi.set(__self__, "controllers", controllers)
        if disable_attach_detach_reconcile_sync is not None:
            pulumi.set(__self__, "disable_attach_detach_reconcile_sync", disable_attach_detach_reconcile_sync)
        if enable_leader_migration is not None:
            pulumi.set(__self__, "enable_leader_migration", enable_leader_migration)
        if enable_profiling is not None:
            pulumi.set(__self__, "enable_profiling", enable_profiling)
        if experimental_cluster_signing_duration is not None:
            pulumi.set(__self__, "experimental_cluster_signing_duration", experimental_cluster_signing_duration)
        if external_cloud_volume_plugin is not None:
            pulumi.set(__self__, "external_cloud_volume_plugin", external_cloud_volume_plugin)
        if feature_gates is not None:
            pulumi.set(__self__, "feature_gates", feature_gates)
        if horizontal_pod_autoscaler_cpu_initialization_period is not None:
            pulumi.set(__self__, "horizontal_pod_autoscaler_cpu_initialization_period", horizontal_pod_autoscaler_cpu_initialization_period)
        if horizontal_pod_autoscaler_downscale_delay is not None:
            pulumi.set(__self__, "horizontal_pod_autoscaler_downscale_delay", horizontal_pod_autoscaler_downscale_delay)
        if horizontal_pod_autoscaler_downscale_stabilization is not None:
            pulumi.set(__self__, "horizontal_pod_autoscaler_downscale_stabilization", horizontal_pod_autoscaler_downscale_stabilization)
        if horizontal_pod_autoscaler_initial_readiness_delay is not None:
            pulumi.set(__self__, "horizontal_pod_autoscaler_initial_readiness_delay", horizontal_pod_autoscaler_initial_readiness_delay)
        if horizontal_pod_autoscaler_sync_period is not None:
            pulumi.set(__self__, "horizontal_pod_autoscaler_sync_period", horizontal_pod_autoscaler_sync_period)
        if horizontal_pod_autoscaler_tolerance is not None:
            pulumi.set(__self__, "horizontal_pod_autoscaler_tolerance", horizontal_pod_autoscaler_tolerance)
        if horizontal_pod_autoscaler_upscale_delay is not None:
            pulumi.set(__self__, "horizontal_pod_autoscaler_upscale_delay", horizontal_pod_autoscaler_upscale_delay)
        if horizontal_pod_autoscaler_use_rest_clients is not None:
            pulumi.set(__self__, "horizontal_pod_autoscaler_use_rest_clients", horizontal_pod_autoscaler_use_rest_clients)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if kube_api_burst is not None:
            pulumi.set(__self__, "kube_api_burst", kube_api_burst)
        if kube_api_qps is not None:
            pulumi.set(__self__, "kube_api_qps", kube_api_qps)
        if leader_election is not None:
            pulumi.set(__self__, "leader_election", leader_election)
        if log_format is not None:
            pulumi.set(__self__, "log_format", log_format)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if master is not None:
            pulumi.set(__self__, "master", master)
        if min_resync_period is not None:
            pulumi.set(__self__, "min_resync_period", min_resync_period)
        if node_cidr_mask_size is not None:
            pulumi.set(__self__, "node_cidr_mask_size", node_cidr_mask_size)
        if node_monitor_grace_period is not None:
            pulumi.set(__self__, "node_monitor_grace_period", node_monitor_grace_period)
        if node_monitor_period is not None:
            pulumi.set(__self__, "node_monitor_period", node_monitor_period)
        if pod_eviction_timeout is not None:
            pulumi.set(__self__, "pod_eviction_timeout", pod_eviction_timeout)
        if root_ca_file is not None:
            pulumi.set(__self__, "root_ca_file", root_ca_file)
        if service_account_private_key_file is not None:
            pulumi.set(__self__, "service_account_private_key_file", service_account_private_key_file)
        if terminated_pod_gc_threshold is not None:
            pulumi.set(__self__, "terminated_pod_gc_threshold", terminated_pod_gc_threshold)
        if tls_cert_file is not None:
            pulumi.set(__self__, "tls_cert_file", tls_cert_file)
        if tls_cipher_suites is not None:
            pulumi.set(__self__, "tls_cipher_suites", tls_cipher_suites)
        if tls_min_version is not None:
            pulumi.set(__self__, "tls_min_version", tls_min_version)
        if tls_private_key_file is not None:
            pulumi.set(__self__, "tls_private_key_file", tls_private_key_file)
        if use_service_account_credentials is not None:
            pulumi.set(__self__, "use_service_account_credentials", use_service_account_credentials)

    @property
    @pulumi.getter(name="allocateNodeCidrs")
    def allocate_node_cidrs(self) -> Optional[bool]:
        return pulumi.get(self, "allocate_node_cidrs")

    @property
    @pulumi.getter(name="attachDetachReconcileSyncPeriod")
    def attach_detach_reconcile_sync_period(self) -> Optional[str]:
        return pulumi.get(self, "attach_detach_reconcile_sync_period")

    @property
    @pulumi.getter(name="authenticationKubeconfig")
    def authentication_kubeconfig(self) -> Optional[str]:
        return pulumi.get(self, "authentication_kubeconfig")

    @property
    @pulumi.getter(name="authorizationAlwaysAllowPaths")
    def authorization_always_allow_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "authorization_always_allow_paths")

    @property
    @pulumi.getter(name="authorizationKubeconfig")
    def authorization_kubeconfig(self) -> Optional[str]:
        return pulumi.get(self, "authorization_kubeconfig")

    @property
    @pulumi.getter(name="cidrAllocatorType")
    def cidr_allocator_type(self) -> Optional[str]:
        return pulumi.get(self, "cidr_allocator_type")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[str]:
        """
        - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="clusterCidr")
    def cluster_cidr(self) -> Optional[str]:
        return pulumi.get(self, "cluster_cidr")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="concurrentDeploymentSyncs")
    def concurrent_deployment_syncs(self) -> Optional[int]:
        return pulumi.get(self, "concurrent_deployment_syncs")

    @property
    @pulumi.getter(name="concurrentEndpointSyncs")
    def concurrent_endpoint_syncs(self) -> Optional[int]:
        return pulumi.get(self, "concurrent_endpoint_syncs")

    @property
    @pulumi.getter(name="concurrentNamespaceSyncs")
    def concurrent_namespace_syncs(self) -> Optional[int]:
        return pulumi.get(self, "concurrent_namespace_syncs")

    @property
    @pulumi.getter(name="concurrentRcSyncs")
    def concurrent_rc_syncs(self) -> Optional[int]:
        return pulumi.get(self, "concurrent_rc_syncs")

    @property
    @pulumi.getter(name="concurrentReplicasetSyncs")
    def concurrent_replicaset_syncs(self) -> Optional[int]:
        return pulumi.get(self, "concurrent_replicaset_syncs")

    @property
    @pulumi.getter(name="concurrentResourceQuotaSyncs")
    def concurrent_resource_quota_syncs(self) -> Optional[int]:
        return pulumi.get(self, "concurrent_resource_quota_syncs")

    @property
    @pulumi.getter(name="concurrentServiceSyncs")
    def concurrent_service_syncs(self) -> Optional[int]:
        return pulumi.get(self, "concurrent_service_syncs")

    @property
    @pulumi.getter(name="concurrentServiceaccountTokenSyncs")
    def concurrent_serviceaccount_token_syncs(self) -> Optional[int]:
        return pulumi.get(self, "concurrent_serviceaccount_token_syncs")

    @property
    @pulumi.getter(name="configureCloudRoutes")
    def configure_cloud_routes(self) -> Optional[bool]:
        return pulumi.get(self, "configure_cloud_routes")

    @property
    @pulumi.getter
    def controllers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "controllers")

    @property
    @pulumi.getter(name="disableAttachDetachReconcileSync")
    def disable_attach_detach_reconcile_sync(self) -> Optional[bool]:
        return pulumi.get(self, "disable_attach_detach_reconcile_sync")

    @property
    @pulumi.getter(name="enableLeaderMigration")
    def enable_leader_migration(self) -> Optional[bool]:
        return pulumi.get(self, "enable_leader_migration")

    @property
    @pulumi.getter(name="enableProfiling")
    def enable_profiling(self) -> Optional[bool]:
        return pulumi.get(self, "enable_profiling")

    @property
    @pulumi.getter(name="experimentalClusterSigningDuration")
    def experimental_cluster_signing_duration(self) -> Optional[str]:
        return pulumi.get(self, "experimental_cluster_signing_duration")

    @property
    @pulumi.getter(name="externalCloudVolumePlugin")
    def external_cloud_volume_plugin(self) -> Optional[str]:
        return pulumi.get(self, "external_cloud_volume_plugin")

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "feature_gates")

    @property
    @pulumi.getter(name="horizontalPodAutoscalerCpuInitializationPeriod")
    def horizontal_pod_autoscaler_cpu_initialization_period(self) -> Optional[str]:
        return pulumi.get(self, "horizontal_pod_autoscaler_cpu_initialization_period")

    @property
    @pulumi.getter(name="horizontalPodAutoscalerDownscaleDelay")
    def horizontal_pod_autoscaler_downscale_delay(self) -> Optional[str]:
        return pulumi.get(self, "horizontal_pod_autoscaler_downscale_delay")

    @property
    @pulumi.getter(name="horizontalPodAutoscalerDownscaleStabilization")
    def horizontal_pod_autoscaler_downscale_stabilization(self) -> Optional[str]:
        return pulumi.get(self, "horizontal_pod_autoscaler_downscale_stabilization")

    @property
    @pulumi.getter(name="horizontalPodAutoscalerInitialReadinessDelay")
    def horizontal_pod_autoscaler_initial_readiness_delay(self) -> Optional[str]:
        return pulumi.get(self, "horizontal_pod_autoscaler_initial_readiness_delay")

    @property
    @pulumi.getter(name="horizontalPodAutoscalerSyncPeriod")
    def horizontal_pod_autoscaler_sync_period(self) -> Optional[str]:
        return pulumi.get(self, "horizontal_pod_autoscaler_sync_period")

    @property
    @pulumi.getter(name="horizontalPodAutoscalerTolerance")
    def horizontal_pod_autoscaler_tolerance(self) -> Optional[str]:
        return pulumi.get(self, "horizontal_pod_autoscaler_tolerance")

    @property
    @pulumi.getter(name="horizontalPodAutoscalerUpscaleDelay")
    def horizontal_pod_autoscaler_upscale_delay(self) -> Optional[str]:
        return pulumi.get(self, "horizontal_pod_autoscaler_upscale_delay")

    @property
    @pulumi.getter(name="horizontalPodAutoscalerUseRestClients")
    def horizontal_pod_autoscaler_use_rest_clients(self) -> Optional[bool]:
        return pulumi.get(self, "horizontal_pod_autoscaler_use_rest_clients")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="kubeApiBurst")
    def kube_api_burst(self) -> Optional[int]:
        return pulumi.get(self, "kube_api_burst")

    @property
    @pulumi.getter(name="kubeApiQps")
    def kube_api_qps(self) -> Optional[str]:
        return pulumi.get(self, "kube_api_qps")

    @property
    @pulumi.getter(name="leaderElection")
    def leader_election(self) -> Optional['outputs.ClusterKubeControllerManagerLeaderElection']:
        return pulumi.get(self, "leader_election")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> Optional[str]:
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[int]:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter
    def master(self) -> Optional[str]:
        return pulumi.get(self, "master")

    @property
    @pulumi.getter(name="minResyncPeriod")
    def min_resync_period(self) -> Optional[str]:
        return pulumi.get(self, "min_resync_period")

    @property
    @pulumi.getter(name="nodeCidrMaskSize")
    def node_cidr_mask_size(self) -> Optional[int]:
        return pulumi.get(self, "node_cidr_mask_size")

    @property
    @pulumi.getter(name="nodeMonitorGracePeriod")
    def node_monitor_grace_period(self) -> Optional[str]:
        return pulumi.get(self, "node_monitor_grace_period")

    @property
    @pulumi.getter(name="nodeMonitorPeriod")
    def node_monitor_period(self) -> Optional[str]:
        return pulumi.get(self, "node_monitor_period")

    @property
    @pulumi.getter(name="podEvictionTimeout")
    def pod_eviction_timeout(self) -> Optional[str]:
        return pulumi.get(self, "pod_eviction_timeout")

    @property
    @pulumi.getter(name="rootCaFile")
    def root_ca_file(self) -> Optional[str]:
        return pulumi.get(self, "root_ca_file")

    @property
    @pulumi.getter(name="serviceAccountPrivateKeyFile")
    def service_account_private_key_file(self) -> Optional[str]:
        return pulumi.get(self, "service_account_private_key_file")

    @property
    @pulumi.getter(name="terminatedPodGcThreshold")
    def terminated_pod_gc_threshold(self) -> Optional[int]:
        return pulumi.get(self, "terminated_pod_gc_threshold")

    @property
    @pulumi.getter(name="tlsCertFile")
    def tls_cert_file(self) -> Optional[str]:
        return pulumi.get(self, "tls_cert_file")

    @property
    @pulumi.getter(name="tlsCipherSuites")
    def tls_cipher_suites(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tls_cipher_suites")

    @property
    @pulumi.getter(name="tlsMinVersion")
    def tls_min_version(self) -> Optional[str]:
        return pulumi.get(self, "tls_min_version")

    @property
    @pulumi.getter(name="tlsPrivateKeyFile")
    def tls_private_key_file(self) -> Optional[str]:
        return pulumi.get(self, "tls_private_key_file")

    @property
    @pulumi.getter(name="useServiceAccountCredentials")
    def use_service_account_credentials(self) -> Optional[bool]:
        return pulumi.get(self, "use_service_account_credentials")


@pulumi.output_type
class ClusterKubeControllerManagerLeaderElection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "leaderElect":
            suggest = "leader_elect"
        elif key == "leaderElectLeaseDuration":
            suggest = "leader_elect_lease_duration"
        elif key == "leaderElectRenewDeadlineDuration":
            suggest = "leader_elect_renew_deadline_duration"
        elif key == "leaderElectResourceLock":
            suggest = "leader_elect_resource_lock"
        elif key == "leaderElectResourceName":
            suggest = "leader_elect_resource_name"
        elif key == "leaderElectResourceNamespace":
            suggest = "leader_elect_resource_namespace"
        elif key == "leaderElectRetryPeriod":
            suggest = "leader_elect_retry_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeControllerManagerLeaderElection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeControllerManagerLeaderElection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeControllerManagerLeaderElection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 leader_elect: Optional[bool] = None,
                 leader_elect_lease_duration: Optional[str] = None,
                 leader_elect_renew_deadline_duration: Optional[str] = None,
                 leader_elect_resource_lock: Optional[str] = None,
                 leader_elect_resource_name: Optional[str] = None,
                 leader_elect_resource_namespace: Optional[str] = None,
                 leader_elect_retry_period: Optional[str] = None):
        if leader_elect is not None:
            pulumi.set(__self__, "leader_elect", leader_elect)
        if leader_elect_lease_duration is not None:
            pulumi.set(__self__, "leader_elect_lease_duration", leader_elect_lease_duration)
        if leader_elect_renew_deadline_duration is not None:
            pulumi.set(__self__, "leader_elect_renew_deadline_duration", leader_elect_renew_deadline_duration)
        if leader_elect_resource_lock is not None:
            pulumi.set(__self__, "leader_elect_resource_lock", leader_elect_resource_lock)
        if leader_elect_resource_name is not None:
            pulumi.set(__self__, "leader_elect_resource_name", leader_elect_resource_name)
        if leader_elect_resource_namespace is not None:
            pulumi.set(__self__, "leader_elect_resource_namespace", leader_elect_resource_namespace)
        if leader_elect_retry_period is not None:
            pulumi.set(__self__, "leader_elect_retry_period", leader_elect_retry_period)

    @property
    @pulumi.getter(name="leaderElect")
    def leader_elect(self) -> Optional[bool]:
        return pulumi.get(self, "leader_elect")

    @property
    @pulumi.getter(name="leaderElectLeaseDuration")
    def leader_elect_lease_duration(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_lease_duration")

    @property
    @pulumi.getter(name="leaderElectRenewDeadlineDuration")
    def leader_elect_renew_deadline_duration(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_renew_deadline_duration")

    @property
    @pulumi.getter(name="leaderElectResourceLock")
    def leader_elect_resource_lock(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_resource_lock")

    @property
    @pulumi.getter(name="leaderElectResourceName")
    def leader_elect_resource_name(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_resource_name")

    @property
    @pulumi.getter(name="leaderElectResourceNamespace")
    def leader_elect_resource_namespace(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_resource_namespace")

    @property
    @pulumi.getter(name="leaderElectRetryPeriod")
    def leader_elect_retry_period(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_retry_period")


@pulumi.output_type
class ClusterKubeDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheMaxConcurrent":
            suggest = "cache_max_concurrent"
        elif key == "cacheMaxSize":
            suggest = "cache_max_size"
        elif key == "coreDnsImage":
            suggest = "core_dns_image"
        elif key == "cpaImage":
            suggest = "cpa_image"
        elif key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "externalCoreFile":
            suggest = "external_core_file"
        elif key == "memoryLimit":
            suggest = "memory_limit"
        elif key == "memoryRequest":
            suggest = "memory_request"
        elif key == "nodeLocalDns":
            suggest = "node_local_dns"
        elif key == "serverIp":
            suggest = "server_ip"
        elif key == "stubDomains":
            suggest = "stub_domains"
        elif key == "upstreamNameservers":
            suggest = "upstream_nameservers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affinity: Optional['outputs.ClusterKubeDnsAffinity'] = None,
                 cache_max_concurrent: Optional[int] = None,
                 cache_max_size: Optional[int] = None,
                 core_dns_image: Optional[str] = None,
                 cpa_image: Optional[str] = None,
                 cpu_request: Optional[str] = None,
                 domain: Optional[str] = None,
                 external_core_file: Optional[str] = None,
                 memory_limit: Optional[str] = None,
                 memory_request: Optional[str] = None,
                 node_local_dns: Optional['outputs.ClusterKubeDnsNodeLocalDns'] = None,
                 provider: Optional[str] = None,
                 server_ip: Optional[str] = None,
                 stub_domains: Optional[Sequence['outputs.ClusterKubeDnsStubDomain']] = None,
                 tolerations: Optional[Sequence['outputs.ClusterKubeDnsToleration']] = None,
                 upstream_nameservers: Optional[Sequence[str]] = None):
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if cache_max_concurrent is not None:
            pulumi.set(__self__, "cache_max_concurrent", cache_max_concurrent)
        if cache_max_size is not None:
            pulumi.set(__self__, "cache_max_size", cache_max_size)
        if core_dns_image is not None:
            pulumi.set(__self__, "core_dns_image", core_dns_image)
        if cpa_image is not None:
            pulumi.set(__self__, "cpa_image", cpa_image)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if external_core_file is not None:
            pulumi.set(__self__, "external_core_file", external_core_file)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)
        if node_local_dns is not None:
            pulumi.set(__self__, "node_local_dns", node_local_dns)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if server_ip is not None:
            pulumi.set(__self__, "server_ip", server_ip)
        if stub_domains is not None:
            pulumi.set(__self__, "stub_domains", stub_domains)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if upstream_nameservers is not None:
            pulumi.set(__self__, "upstream_nameservers", upstream_nameservers)

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.ClusterKubeDnsAffinity']:
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="cacheMaxConcurrent")
    def cache_max_concurrent(self) -> Optional[int]:
        return pulumi.get(self, "cache_max_concurrent")

    @property
    @pulumi.getter(name="cacheMaxSize")
    def cache_max_size(self) -> Optional[int]:
        return pulumi.get(self, "cache_max_size")

    @property
    @pulumi.getter(name="coreDnsImage")
    def core_dns_image(self) -> Optional[str]:
        return pulumi.get(self, "core_dns_image")

    @property
    @pulumi.getter(name="cpaImage")
    def cpa_image(self) -> Optional[str]:
        return pulumi.get(self, "cpa_image")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[str]:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="externalCoreFile")
    def external_core_file(self) -> Optional[str]:
        return pulumi.get(self, "external_core_file")

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[str]:
        return pulumi.get(self, "memory_limit")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[str]:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter(name="nodeLocalDns")
    def node_local_dns(self) -> Optional['outputs.ClusterKubeDnsNodeLocalDns']:
        return pulumi.get(self, "node_local_dns")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="serverIp")
    def server_ip(self) -> Optional[str]:
        return pulumi.get(self, "server_ip")

    @property
    @pulumi.getter(name="stubDomains")
    def stub_domains(self) -> Optional[Sequence['outputs.ClusterKubeDnsStubDomain']]:
        return pulumi.get(self, "stub_domains")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.ClusterKubeDnsToleration']]:
        return pulumi.get(self, "tolerations")

    @property
    @pulumi.getter(name="upstreamNameservers")
    def upstream_nameservers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "upstream_nameservers")


@pulumi.output_type
class ClusterKubeDnsAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeAffinity":
            suggest = "node_affinity"
        elif key == "podAffinity":
            suggest = "pod_affinity"
        elif key == "podAntiAffinity":
            suggest = "pod_anti_affinity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_affinity: Optional['outputs.ClusterKubeDnsAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.ClusterKubeDnsAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.ClusterKubeDnsAffinityPodAntiAffinity'] = None):
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.ClusterKubeDnsAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.ClusterKubeDnsAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.ClusterKubeDnsAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")


@pulumi.output_type
class ClusterKubeDnsAffinityNodeAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferredDuringSchedulingIgnoredDuringExecutions":
            suggest = "preferred_during_scheduling_ignored_during_executions"
        elif key == "requiredDuringSchedulingIgnoredDuringExecution":
            suggest = "required_during_scheduling_ignored_during_execution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityNodeAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityNodeAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityNodeAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")


@pulumi.output_type
class ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchFields":
            suggest = "match_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression']] = None,
                 match_fields: Optional[Sequence['outputs.ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField']]:
        return pulumi.get(self, "match_fields")


@pulumi.output_type
class ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterKubeDnsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeSelectorTerms":
            suggest = "node_selector_terms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm']]:
        return pulumi.get(self, "node_selector_terms")


@pulumi.output_type
class ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchFields":
            suggest = "match_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression']] = None,
                 match_fields: Optional[Sequence['outputs.ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField']]:
        return pulumi.get(self, "match_fields")


@pulumi.output_type
class ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterKubeDnsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferredDuringSchedulingIgnoredDuringExecutions":
            suggest = "preferred_during_scheduling_ignored_during_executions"
        elif key == "requiredDuringSchedulingIgnoredDuringExecutions":
            suggest = "required_during_scheduling_ignored_during_executions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityPodAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityPodAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityPodAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        if required_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_executions", required_during_scheduling_ignored_during_executions)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecutions")
    def required_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_executions")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podAffinityTerm":
            suggest = "pod_affinity_term"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSelector":
            suggest = "label_selector"
        elif key == "namespaceSelector":
            suggest = "namespace_selector"
        elif key == "topologyKey":
            suggest = "topology_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_selector: Optional['outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespace_selector: Optional['outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespace_selector is not None:
            pulumi.set(__self__, "namespace_selector", namespace_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter(name="namespaceSelector")
    def namespace_selector(self) -> Optional['outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector']:
        return pulumi.get(self, "namespace_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSelector":
            suggest = "label_selector"
        elif key == "namespaceSelector":
            suggest = "namespace_selector"
        elif key == "topologyKey":
            suggest = "topology_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_selector: Optional['outputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespace_selector: Optional['outputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespace_selector is not None:
            pulumi.set(__self__, "namespace_selector", namespace_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter(name="namespaceSelector")
    def namespace_selector(self) -> Optional['outputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector']:
        return pulumi.get(self, "namespace_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAntiAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferredDuringSchedulingIgnoredDuringExecutions":
            suggest = "preferred_during_scheduling_ignored_during_executions"
        elif key == "requiredDuringSchedulingIgnoredDuringExecutions":
            suggest = "required_during_scheduling_ignored_during_executions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityPodAntiAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityPodAntiAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityPodAntiAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        if required_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_executions", required_during_scheduling_ignored_during_executions)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecutions")
    def required_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_executions")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podAffinityTerm":
            suggest = "pod_affinity_term"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSelector":
            suggest = "label_selector"
        elif key == "namespaceSelector":
            suggest = "namespace_selector"
        elif key == "topologyKey":
            suggest = "topology_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_selector: Optional['outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespace_selector: Optional['outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespace_selector is not None:
            pulumi.set(__self__, "namespace_selector", namespace_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter(name="namespaceSelector")
    def namespace_selector(self) -> Optional['outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector']:
        return pulumi.get(self, "namespace_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSelector":
            suggest = "label_selector"
        elif key == "namespaceSelector":
            suggest = "namespace_selector"
        elif key == "topologyKey":
            suggest = "topology_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_selector: Optional['outputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespace_selector: Optional['outputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespace_selector is not None:
            pulumi.set(__self__, "namespace_selector", namespace_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter(name="namespaceSelector")
    def namespace_selector(self) -> Optional['outputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector']:
        return pulumi.get(self, "namespace_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class ClusterKubeDnsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterKubeDnsNodeLocalDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "forwardToKubeDns":
            suggest = "forward_to_kube_dns"
        elif key == "localIp":
            suggest = "local_ip"
        elif key == "memoryRequest":
            suggest = "memory_request"
        elif key == "podAnnotations":
            suggest = "pod_annotations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsNodeLocalDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsNodeLocalDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsNodeLocalDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_request: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 forward_to_kube_dns: Optional[bool] = None,
                 image: Optional[str] = None,
                 local_ip: Optional[str] = None,
                 memory_request: Optional[str] = None,
                 pod_annotations: Optional[Mapping[str, str]] = None):
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if forward_to_kube_dns is not None:
            pulumi.set(__self__, "forward_to_kube_dns", forward_to_kube_dns)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if local_ip is not None:
            pulumi.set(__self__, "local_ip", local_ip)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)
        if pod_annotations is not None:
            pulumi.set(__self__, "pod_annotations", pod_annotations)

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[str]:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="forwardToKubeDns")
    def forward_to_kube_dns(self) -> Optional[bool]:
        return pulumi.get(self, "forward_to_kube_dns")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="localIp")
    def local_ip(self) -> Optional[str]:
        return pulumi.get(self, "local_ip")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[str]:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter(name="podAnnotations")
    def pod_annotations(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "pod_annotations")


@pulumi.output_type
class ClusterKubeDnsStubDomain(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterKubeDnsToleration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tolerationSeconds":
            suggest = "toleration_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeDnsToleration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeDnsToleration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeDnsToleration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterKubeProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindAddress":
            suggest = "bind_address"
        elif key == "clusterCidr":
            suggest = "cluster_cidr"
        elif key == "conntrackMaxPerCore":
            suggest = "conntrack_max_per_core"
        elif key == "conntrackMin":
            suggest = "conntrack_min"
        elif key == "cpuLimit":
            suggest = "cpu_limit"
        elif key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "featureGates":
            suggest = "feature_gates"
        elif key == "hostnameOverride":
            suggest = "hostname_override"
        elif key == "ipVsExcludeCidrs":
            suggest = "ip_vs_exclude_cidrs"
        elif key == "ipVsMinSyncPeriod":
            suggest = "ip_vs_min_sync_period"
        elif key == "ipVsScheduler":
            suggest = "ip_vs_scheduler"
        elif key == "ipVsSyncPeriod":
            suggest = "ip_vs_sync_period"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "memoryLimit":
            suggest = "memory_limit"
        elif key == "memoryRequest":
            suggest = "memory_request"
        elif key == "metricsBindAddress":
            suggest = "metrics_bind_address"
        elif key == "proxyMode":
            suggest = "proxy_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 bind_address: Optional[str] = None,
                 cluster_cidr: Optional[str] = None,
                 conntrack_max_per_core: Optional[int] = None,
                 conntrack_min: Optional[int] = None,
                 cpu_limit: Optional[str] = None,
                 cpu_request: Optional[str] = None,
                 feature_gates: Optional[Mapping[str, str]] = None,
                 hostname_override: Optional[str] = None,
                 image: Optional[str] = None,
                 ip_vs_exclude_cidrs: Optional[Sequence[str]] = None,
                 ip_vs_min_sync_period: Optional[str] = None,
                 ip_vs_scheduler: Optional[str] = None,
                 ip_vs_sync_period: Optional[str] = None,
                 log_level: Optional[int] = None,
                 master: Optional[str] = None,
                 memory_limit: Optional[str] = None,
                 memory_request: Optional[str] = None,
                 metrics_bind_address: Optional[str] = None,
                 proxy_mode: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if bind_address is not None:
            pulumi.set(__self__, "bind_address", bind_address)
        if cluster_cidr is not None:
            pulumi.set(__self__, "cluster_cidr", cluster_cidr)
        if conntrack_max_per_core is not None:
            pulumi.set(__self__, "conntrack_max_per_core", conntrack_max_per_core)
        if conntrack_min is not None:
            pulumi.set(__self__, "conntrack_min", conntrack_min)
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if feature_gates is not None:
            pulumi.set(__self__, "feature_gates", feature_gates)
        if hostname_override is not None:
            pulumi.set(__self__, "hostname_override", hostname_override)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if ip_vs_exclude_cidrs is not None:
            pulumi.set(__self__, "ip_vs_exclude_cidrs", ip_vs_exclude_cidrs)
        if ip_vs_min_sync_period is not None:
            pulumi.set(__self__, "ip_vs_min_sync_period", ip_vs_min_sync_period)
        if ip_vs_scheduler is not None:
            pulumi.set(__self__, "ip_vs_scheduler", ip_vs_scheduler)
        if ip_vs_sync_period is not None:
            pulumi.set(__self__, "ip_vs_sync_period", ip_vs_sync_period)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if master is not None:
            pulumi.set(__self__, "master", master)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)
        if metrics_bind_address is not None:
            pulumi.set(__self__, "metrics_bind_address", metrics_bind_address)
        if proxy_mode is not None:
            pulumi.set(__self__, "proxy_mode", proxy_mode)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="bindAddress")
    def bind_address(self) -> Optional[str]:
        return pulumi.get(self, "bind_address")

    @property
    @pulumi.getter(name="clusterCidr")
    def cluster_cidr(self) -> Optional[str]:
        return pulumi.get(self, "cluster_cidr")

    @property
    @pulumi.getter(name="conntrackMaxPerCore")
    def conntrack_max_per_core(self) -> Optional[int]:
        return pulumi.get(self, "conntrack_max_per_core")

    @property
    @pulumi.getter(name="conntrackMin")
    def conntrack_min(self) -> Optional[int]:
        return pulumi.get(self, "conntrack_min")

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[str]:
        return pulumi.get(self, "cpu_limit")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[str]:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "feature_gates")

    @property
    @pulumi.getter(name="hostnameOverride")
    def hostname_override(self) -> Optional[str]:
        return pulumi.get(self, "hostname_override")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="ipVsExcludeCidrs")
    def ip_vs_exclude_cidrs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ip_vs_exclude_cidrs")

    @property
    @pulumi.getter(name="ipVsMinSyncPeriod")
    def ip_vs_min_sync_period(self) -> Optional[str]:
        return pulumi.get(self, "ip_vs_min_sync_period")

    @property
    @pulumi.getter(name="ipVsScheduler")
    def ip_vs_scheduler(self) -> Optional[str]:
        return pulumi.get(self, "ip_vs_scheduler")

    @property
    @pulumi.getter(name="ipVsSyncPeriod")
    def ip_vs_sync_period(self) -> Optional[str]:
        return pulumi.get(self, "ip_vs_sync_period")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[int]:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter
    def master(self) -> Optional[str]:
        return pulumi.get(self, "master")

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[str]:
        return pulumi.get(self, "memory_limit")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[str]:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter(name="metricsBindAddress")
    def metrics_bind_address(self) -> Optional[str]:
        return pulumi.get(self, "metrics_bind_address")

    @property
    @pulumi.getter(name="proxyMode")
    def proxy_mode(self) -> Optional[str]:
        return pulumi.get(self, "proxy_mode")


@pulumi.output_type
class ClusterKubeScheduler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationKubeconfig":
            suggest = "authentication_kubeconfig"
        elif key == "authorizationAlwaysAllowPaths":
            suggest = "authorization_always_allow_paths"
        elif key == "authorizationKubeconfig":
            suggest = "authorization_kubeconfig"
        elif key == "enableProfiling":
            suggest = "enable_profiling"
        elif key == "featureGates":
            suggest = "feature_gates"
        elif key == "leaderElection":
            suggest = "leader_election"
        elif key == "logFormat":
            suggest = "log_format"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "maxPersistentVolumes":
            suggest = "max_persistent_volumes"
        elif key == "tlsCertFile":
            suggest = "tls_cert_file"
        elif key == "tlsPrivateKeyFile":
            suggest = "tls_private_key_file"
        elif key == "usePolicyConfigMap":
            suggest = "use_policy_config_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeScheduler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeScheduler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeScheduler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_kubeconfig: Optional[str] = None,
                 authorization_always_allow_paths: Optional[Sequence[str]] = None,
                 authorization_kubeconfig: Optional[str] = None,
                 burst: Optional[int] = None,
                 enable_profiling: Optional[bool] = None,
                 feature_gates: Optional[Mapping[str, str]] = None,
                 image: Optional[str] = None,
                 leader_election: Optional['outputs.ClusterKubeSchedulerLeaderElection'] = None,
                 log_format: Optional[str] = None,
                 log_level: Optional[int] = None,
                 master: Optional[str] = None,
                 max_persistent_volumes: Optional[int] = None,
                 qps: Optional[str] = None,
                 tls_cert_file: Optional[str] = None,
                 tls_private_key_file: Optional[str] = None,
                 use_policy_config_map: Optional[bool] = None):
        if authentication_kubeconfig is not None:
            pulumi.set(__self__, "authentication_kubeconfig", authentication_kubeconfig)
        if authorization_always_allow_paths is not None:
            pulumi.set(__self__, "authorization_always_allow_paths", authorization_always_allow_paths)
        if authorization_kubeconfig is not None:
            pulumi.set(__self__, "authorization_kubeconfig", authorization_kubeconfig)
        if burst is not None:
            pulumi.set(__self__, "burst", burst)
        if enable_profiling is not None:
            pulumi.set(__self__, "enable_profiling", enable_profiling)
        if feature_gates is not None:
            pulumi.set(__self__, "feature_gates", feature_gates)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if leader_election is not None:
            pulumi.set(__self__, "leader_election", leader_election)
        if log_format is not None:
            pulumi.set(__self__, "log_format", log_format)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if master is not None:
            pulumi.set(__self__, "master", master)
        if max_persistent_volumes is not None:
            pulumi.set(__self__, "max_persistent_volumes", max_persistent_volumes)
        if qps is not None:
            pulumi.set(__self__, "qps", qps)
        if tls_cert_file is not None:
            pulumi.set(__self__, "tls_cert_file", tls_cert_file)
        if tls_private_key_file is not None:
            pulumi.set(__self__, "tls_private_key_file", tls_private_key_file)
        if use_policy_config_map is not None:
            pulumi.set(__self__, "use_policy_config_map", use_policy_config_map)

    @property
    @pulumi.getter(name="authenticationKubeconfig")
    def authentication_kubeconfig(self) -> Optional[str]:
        return pulumi.get(self, "authentication_kubeconfig")

    @property
    @pulumi.getter(name="authorizationAlwaysAllowPaths")
    def authorization_always_allow_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "authorization_always_allow_paths")

    @property
    @pulumi.getter(name="authorizationKubeconfig")
    def authorization_kubeconfig(self) -> Optional[str]:
        return pulumi.get(self, "authorization_kubeconfig")

    @property
    @pulumi.getter
    def burst(self) -> Optional[int]:
        return pulumi.get(self, "burst")

    @property
    @pulumi.getter(name="enableProfiling")
    def enable_profiling(self) -> Optional[bool]:
        return pulumi.get(self, "enable_profiling")

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "feature_gates")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="leaderElection")
    def leader_election(self) -> Optional['outputs.ClusterKubeSchedulerLeaderElection']:
        return pulumi.get(self, "leader_election")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> Optional[str]:
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[int]:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter
    def master(self) -> Optional[str]:
        return pulumi.get(self, "master")

    @property
    @pulumi.getter(name="maxPersistentVolumes")
    def max_persistent_volumes(self) -> Optional[int]:
        return pulumi.get(self, "max_persistent_volumes")

    @property
    @pulumi.getter
    def qps(self) -> Optional[str]:
        return pulumi.get(self, "qps")

    @property
    @pulumi.getter(name="tlsCertFile")
    def tls_cert_file(self) -> Optional[str]:
        return pulumi.get(self, "tls_cert_file")

    @property
    @pulumi.getter(name="tlsPrivateKeyFile")
    def tls_private_key_file(self) -> Optional[str]:
        return pulumi.get(self, "tls_private_key_file")

    @property
    @pulumi.getter(name="usePolicyConfigMap")
    def use_policy_config_map(self) -> Optional[bool]:
        return pulumi.get(self, "use_policy_config_map")


@pulumi.output_type
class ClusterKubeSchedulerLeaderElection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "leaderElect":
            suggest = "leader_elect"
        elif key == "leaderElectLeaseDuration":
            suggest = "leader_elect_lease_duration"
        elif key == "leaderElectRenewDeadlineDuration":
            suggest = "leader_elect_renew_deadline_duration"
        elif key == "leaderElectResourceLock":
            suggest = "leader_elect_resource_lock"
        elif key == "leaderElectResourceName":
            suggest = "leader_elect_resource_name"
        elif key == "leaderElectResourceNamespace":
            suggest = "leader_elect_resource_namespace"
        elif key == "leaderElectRetryPeriod":
            suggest = "leader_elect_retry_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeSchedulerLeaderElection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeSchedulerLeaderElection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeSchedulerLeaderElection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 leader_elect: Optional[bool] = None,
                 leader_elect_lease_duration: Optional[str] = None,
                 leader_elect_renew_deadline_duration: Optional[str] = None,
                 leader_elect_resource_lock: Optional[str] = None,
                 leader_elect_resource_name: Optional[str] = None,
                 leader_elect_resource_namespace: Optional[str] = None,
                 leader_elect_retry_period: Optional[str] = None):
        if leader_elect is not None:
            pulumi.set(__self__, "leader_elect", leader_elect)
        if leader_elect_lease_duration is not None:
            pulumi.set(__self__, "leader_elect_lease_duration", leader_elect_lease_duration)
        if leader_elect_renew_deadline_duration is not None:
            pulumi.set(__self__, "leader_elect_renew_deadline_duration", leader_elect_renew_deadline_duration)
        if leader_elect_resource_lock is not None:
            pulumi.set(__self__, "leader_elect_resource_lock", leader_elect_resource_lock)
        if leader_elect_resource_name is not None:
            pulumi.set(__self__, "leader_elect_resource_name", leader_elect_resource_name)
        if leader_elect_resource_namespace is not None:
            pulumi.set(__self__, "leader_elect_resource_namespace", leader_elect_resource_namespace)
        if leader_elect_retry_period is not None:
            pulumi.set(__self__, "leader_elect_retry_period", leader_elect_retry_period)

    @property
    @pulumi.getter(name="leaderElect")
    def leader_elect(self) -> Optional[bool]:
        return pulumi.get(self, "leader_elect")

    @property
    @pulumi.getter(name="leaderElectLeaseDuration")
    def leader_elect_lease_duration(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_lease_duration")

    @property
    @pulumi.getter(name="leaderElectRenewDeadlineDuration")
    def leader_elect_renew_deadline_duration(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_renew_deadline_duration")

    @property
    @pulumi.getter(name="leaderElectResourceLock")
    def leader_elect_resource_lock(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_resource_lock")

    @property
    @pulumi.getter(name="leaderElectResourceName")
    def leader_elect_resource_name(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_resource_name")

    @property
    @pulumi.getter(name="leaderElectResourceNamespace")
    def leader_elect_resource_namespace(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_resource_namespace")

    @property
    @pulumi.getter(name="leaderElectRetryPeriod")
    def leader_elect_retry_period(self) -> Optional[str]:
        return pulumi.get(self, "leader_elect_retry_period")


@pulumi.output_type
class ClusterKubelet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPrivileged":
            suggest = "allow_privileged"
        elif key == "allowedUnsafeSysctls":
            suggest = "allowed_unsafe_sysctls"
        elif key == "anonymousAuth":
            suggest = "anonymous_auth"
        elif key == "apiServers":
            suggest = "api_servers"
        elif key == "authenticationTokenWebhook":
            suggest = "authentication_token_webhook"
        elif key == "authenticationTokenWebhookCacheTtl":
            suggest = "authentication_token_webhook_cache_ttl"
        elif key == "authorizationMode":
            suggest = "authorization_mode"
        elif key == "babysitDaemons":
            suggest = "babysit_daemons"
        elif key == "bootstrapKubeconfig":
            suggest = "bootstrap_kubeconfig"
        elif key == "cgroupDriver":
            suggest = "cgroup_driver"
        elif key == "cgroupRoot":
            suggest = "cgroup_root"
        elif key == "clientCaFile":
            suggest = "client_ca_file"
        elif key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "clusterDns":
            suggest = "cluster_dns"
        elif key == "clusterDomain":
            suggest = "cluster_domain"
        elif key == "configureCbr0":
            suggest = "configure_cbr0"
        elif key == "containerLogMaxFiles":
            suggest = "container_log_max_files"
        elif key == "containerLogMaxSize":
            suggest = "container_log_max_size"
        elif key == "cpuCfsQuota":
            suggest = "cpu_cfs_quota"
        elif key == "cpuCfsQuotaPeriod":
            suggest = "cpu_cfs_quota_period"
        elif key == "cpuManagerPolicy":
            suggest = "cpu_manager_policy"
        elif key == "dockerDisableSharedPid":
            suggest = "docker_disable_shared_pid"
        elif key == "enableCadvisorJsonEndpoints":
            suggest = "enable_cadvisor_json_endpoints"
        elif key == "enableCustomMetrics":
            suggest = "enable_custom_metrics"
        elif key == "enableDebuggingHandlers":
            suggest = "enable_debugging_handlers"
        elif key == "enforceNodeAllocatable":
            suggest = "enforce_node_allocatable"
        elif key == "eventBurst":
            suggest = "event_burst"
        elif key == "eventQps":
            suggest = "event_qps"
        elif key == "evictionHard":
            suggest = "eviction_hard"
        elif key == "evictionMaxPodGracePeriod":
            suggest = "eviction_max_pod_grace_period"
        elif key == "evictionMinimumReclaim":
            suggest = "eviction_minimum_reclaim"
        elif key == "evictionPressureTransitionPeriod":
            suggest = "eviction_pressure_transition_period"
        elif key == "evictionSoft":
            suggest = "eviction_soft"
        elif key == "evictionSoftGracePeriod":
            suggest = "eviction_soft_grace_period"
        elif key == "experimentalAllowedUnsafeSysctls":
            suggest = "experimental_allowed_unsafe_sysctls"
        elif key == "failSwapOn":
            suggest = "fail_swap_on"
        elif key == "featureGates":
            suggest = "feature_gates"
        elif key == "hairpinMode":
            suggest = "hairpin_mode"
        elif key == "hostnameOverride":
            suggest = "hostname_override"
        elif key == "housekeepingInterval":
            suggest = "housekeeping_interval"
        elif key == "imageGcHighThresholdPercent":
            suggest = "image_gc_high_threshold_percent"
        elif key == "imageGcLowThresholdPercent":
            suggest = "image_gc_low_threshold_percent"
        elif key == "imagePullProgressDeadline":
            suggest = "image_pull_progress_deadline"
        elif key == "kernelMemcgNotification":
            suggest = "kernel_memcg_notification"
        elif key == "kubeReserved":
            suggest = "kube_reserved"
        elif key == "kubeReservedCgroup":
            suggest = "kube_reserved_cgroup"
        elif key == "kubeconfigPath":
            suggest = "kubeconfig_path"
        elif key == "kubeletCgroups":
            suggest = "kubelet_cgroups"
        elif key == "logFormat":
            suggest = "log_format"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "maxPods":
            suggest = "max_pods"
        elif key == "networkPluginMtu":
            suggest = "network_plugin_mtu"
        elif key == "networkPluginName":
            suggest = "network_plugin_name"
        elif key == "nodeLabels":
            suggest = "node_labels"
        elif key == "nodeStatusUpdateFrequency":
            suggest = "node_status_update_frequency"
        elif key == "nonMasqueradeCidr":
            suggest = "non_masquerade_cidr"
        elif key == "nvidiaGpUs":
            suggest = "nvidia_gp_us"
        elif key == "podCidr":
            suggest = "pod_cidr"
        elif key == "podInfraContainerImage":
            suggest = "pod_infra_container_image"
        elif key == "podManifestPath":
            suggest = "pod_manifest_path"
        elif key == "podPidsLimit":
            suggest = "pod_pids_limit"
        elif key == "protectKernelDefaults":
            suggest = "protect_kernel_defaults"
        elif key == "readOnlyPort":
            suggest = "read_only_port"
        elif key == "reconcileCidr":
            suggest = "reconcile_cidr"
        elif key == "registerNode":
            suggest = "register_node"
        elif key == "registerSchedulable":
            suggest = "register_schedulable"
        elif key == "registryBurst":
            suggest = "registry_burst"
        elif key == "registryPullQps":
            suggest = "registry_pull_qps"
        elif key == "requireKubeconfig":
            suggest = "require_kubeconfig"
        elif key == "resolverConfig":
            suggest = "resolver_config"
        elif key == "rootDir":
            suggest = "root_dir"
        elif key == "rotateCertificates":
            suggest = "rotate_certificates"
        elif key == "runtimeCgroups":
            suggest = "runtime_cgroups"
        elif key == "runtimeRequestTimeout":
            suggest = "runtime_request_timeout"
        elif key == "seccompProfileRoot":
            suggest = "seccomp_profile_root"
        elif key == "serializeImagePulls":
            suggest = "serialize_image_pulls"
        elif key == "shutdownGracePeriod":
            suggest = "shutdown_grace_period"
        elif key == "shutdownGracePeriodCriticalPods":
            suggest = "shutdown_grace_period_critical_pods"
        elif key == "streamingConnectionIdleTimeout":
            suggest = "streaming_connection_idle_timeout"
        elif key == "systemCgroups":
            suggest = "system_cgroups"
        elif key == "systemReserved":
            suggest = "system_reserved"
        elif key == "systemReservedCgroup":
            suggest = "system_reserved_cgroup"
        elif key == "tlsCertFile":
            suggest = "tls_cert_file"
        elif key == "tlsCipherSuites":
            suggest = "tls_cipher_suites"
        elif key == "tlsMinVersion":
            suggest = "tls_min_version"
        elif key == "tlsPrivateKeyFile":
            suggest = "tls_private_key_file"
        elif key == "topologyManagerPolicy":
            suggest = "topology_manager_policy"
        elif key == "volumePluginDirectory":
            suggest = "volume_plugin_directory"
        elif key == "volumeStatsAggPeriod":
            suggest = "volume_stats_agg_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubelet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubelet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubelet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_privileged: Optional[bool] = None,
                 allowed_unsafe_sysctls: Optional[Sequence[str]] = None,
                 anonymous_auth: Optional['outputs.ClusterKubeletAnonymousAuth'] = None,
                 api_servers: Optional[str] = None,
                 authentication_token_webhook: Optional[bool] = None,
                 authentication_token_webhook_cache_ttl: Optional[str] = None,
                 authorization_mode: Optional[str] = None,
                 babysit_daemons: Optional[bool] = None,
                 bootstrap_kubeconfig: Optional[str] = None,
                 cgroup_driver: Optional[str] = None,
                 cgroup_root: Optional[str] = None,
                 client_ca_file: Optional[str] = None,
                 cloud_provider: Optional[str] = None,
                 cluster_dns: Optional[str] = None,
                 cluster_domain: Optional[str] = None,
                 configure_cbr0: Optional[bool] = None,
                 container_log_max_files: Optional[int] = None,
                 container_log_max_size: Optional[str] = None,
                 cpu_cfs_quota: Optional['outputs.ClusterKubeletCpuCfsQuota'] = None,
                 cpu_cfs_quota_period: Optional[str] = None,
                 cpu_manager_policy: Optional[str] = None,
                 docker_disable_shared_pid: Optional[bool] = None,
                 enable_cadvisor_json_endpoints: Optional[bool] = None,
                 enable_custom_metrics: Optional[bool] = None,
                 enable_debugging_handlers: Optional[bool] = None,
                 enforce_node_allocatable: Optional[str] = None,
                 event_burst: Optional[int] = None,
                 event_qps: Optional[int] = None,
                 eviction_hard: Optional[str] = None,
                 eviction_max_pod_grace_period: Optional[int] = None,
                 eviction_minimum_reclaim: Optional[str] = None,
                 eviction_pressure_transition_period: Optional[str] = None,
                 eviction_soft: Optional[str] = None,
                 eviction_soft_grace_period: Optional[str] = None,
                 experimental_allowed_unsafe_sysctls: Optional[Sequence[str]] = None,
                 fail_swap_on: Optional[bool] = None,
                 feature_gates: Optional[Mapping[str, str]] = None,
                 hairpin_mode: Optional[str] = None,
                 hostname_override: Optional[str] = None,
                 housekeeping_interval: Optional[str] = None,
                 image_gc_high_threshold_percent: Optional[int] = None,
                 image_gc_low_threshold_percent: Optional[int] = None,
                 image_pull_progress_deadline: Optional[str] = None,
                 kernel_memcg_notification: Optional[bool] = None,
                 kube_reserved: Optional[Mapping[str, str]] = None,
                 kube_reserved_cgroup: Optional[str] = None,
                 kubeconfig_path: Optional[str] = None,
                 kubelet_cgroups: Optional[str] = None,
                 log_format: Optional[str] = None,
                 log_level: Optional[int] = None,
                 max_pods: Optional[int] = None,
                 network_plugin_mtu: Optional[int] = None,
                 network_plugin_name: Optional[str] = None,
                 node_labels: Optional[Mapping[str, str]] = None,
                 node_status_update_frequency: Optional[str] = None,
                 non_masquerade_cidr: Optional[str] = None,
                 nvidia_gp_us: Optional[int] = None,
                 pod_cidr: Optional[str] = None,
                 pod_infra_container_image: Optional[str] = None,
                 pod_manifest_path: Optional[str] = None,
                 pod_pids_limit: Optional[int] = None,
                 protect_kernel_defaults: Optional[bool] = None,
                 read_only_port: Optional[int] = None,
                 reconcile_cidr: Optional[bool] = None,
                 register_node: Optional[bool] = None,
                 register_schedulable: Optional[bool] = None,
                 registry_burst: Optional[int] = None,
                 registry_pull_qps: Optional[int] = None,
                 require_kubeconfig: Optional[bool] = None,
                 resolver_config: Optional[str] = None,
                 root_dir: Optional[str] = None,
                 rotate_certificates: Optional[bool] = None,
                 runtime_cgroups: Optional[str] = None,
                 runtime_request_timeout: Optional[str] = None,
                 seccomp_profile_root: Optional[str] = None,
                 serialize_image_pulls: Optional[bool] = None,
                 shutdown_grace_period: Optional[str] = None,
                 shutdown_grace_period_critical_pods: Optional[str] = None,
                 streaming_connection_idle_timeout: Optional[str] = None,
                 system_cgroups: Optional[str] = None,
                 system_reserved: Optional[Mapping[str, str]] = None,
                 system_reserved_cgroup: Optional[str] = None,
                 taints: Optional[Sequence[str]] = None,
                 tls_cert_file: Optional[str] = None,
                 tls_cipher_suites: Optional[Sequence[str]] = None,
                 tls_min_version: Optional[str] = None,
                 tls_private_key_file: Optional[str] = None,
                 topology_manager_policy: Optional[str] = None,
                 volume_plugin_directory: Optional[str] = None,
                 volume_stats_agg_period: Optional[str] = None):
        """
        :param str cloud_provider: - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        :param str non_masquerade_cidr: - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
        :param str pod_cidr: - String - PodCIDR is the CIDR from which we allocate IPs for pods.
        """
        if allow_privileged is not None:
            pulumi.set(__self__, "allow_privileged", allow_privileged)
        if allowed_unsafe_sysctls is not None:
            pulumi.set(__self__, "allowed_unsafe_sysctls", allowed_unsafe_sysctls)
        if anonymous_auth is not None:
            pulumi.set(__self__, "anonymous_auth", anonymous_auth)
        if api_servers is not None:
            pulumi.set(__self__, "api_servers", api_servers)
        if authentication_token_webhook is not None:
            pulumi.set(__self__, "authentication_token_webhook", authentication_token_webhook)
        if authentication_token_webhook_cache_ttl is not None:
            pulumi.set(__self__, "authentication_token_webhook_cache_ttl", authentication_token_webhook_cache_ttl)
        if authorization_mode is not None:
            pulumi.set(__self__, "authorization_mode", authorization_mode)
        if babysit_daemons is not None:
            pulumi.set(__self__, "babysit_daemons", babysit_daemons)
        if bootstrap_kubeconfig is not None:
            pulumi.set(__self__, "bootstrap_kubeconfig", bootstrap_kubeconfig)
        if cgroup_driver is not None:
            pulumi.set(__self__, "cgroup_driver", cgroup_driver)
        if cgroup_root is not None:
            pulumi.set(__self__, "cgroup_root", cgroup_root)
        if client_ca_file is not None:
            pulumi.set(__self__, "client_ca_file", client_ca_file)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if cluster_dns is not None:
            pulumi.set(__self__, "cluster_dns", cluster_dns)
        if cluster_domain is not None:
            pulumi.set(__self__, "cluster_domain", cluster_domain)
        if configure_cbr0 is not None:
            pulumi.set(__self__, "configure_cbr0", configure_cbr0)
        if container_log_max_files is not None:
            pulumi.set(__self__, "container_log_max_files", container_log_max_files)
        if container_log_max_size is not None:
            pulumi.set(__self__, "container_log_max_size", container_log_max_size)
        if cpu_cfs_quota is not None:
            pulumi.set(__self__, "cpu_cfs_quota", cpu_cfs_quota)
        if cpu_cfs_quota_period is not None:
            pulumi.set(__self__, "cpu_cfs_quota_period", cpu_cfs_quota_period)
        if cpu_manager_policy is not None:
            pulumi.set(__self__, "cpu_manager_policy", cpu_manager_policy)
        if docker_disable_shared_pid is not None:
            pulumi.set(__self__, "docker_disable_shared_pid", docker_disable_shared_pid)
        if enable_cadvisor_json_endpoints is not None:
            pulumi.set(__self__, "enable_cadvisor_json_endpoints", enable_cadvisor_json_endpoints)
        if enable_custom_metrics is not None:
            pulumi.set(__self__, "enable_custom_metrics", enable_custom_metrics)
        if enable_debugging_handlers is not None:
            pulumi.set(__self__, "enable_debugging_handlers", enable_debugging_handlers)
        if enforce_node_allocatable is not None:
            pulumi.set(__self__, "enforce_node_allocatable", enforce_node_allocatable)
        if event_burst is not None:
            pulumi.set(__self__, "event_burst", event_burst)
        if event_qps is not None:
            pulumi.set(__self__, "event_qps", event_qps)
        if eviction_hard is not None:
            pulumi.set(__self__, "eviction_hard", eviction_hard)
        if eviction_max_pod_grace_period is not None:
            pulumi.set(__self__, "eviction_max_pod_grace_period", eviction_max_pod_grace_period)
        if eviction_minimum_reclaim is not None:
            pulumi.set(__self__, "eviction_minimum_reclaim", eviction_minimum_reclaim)
        if eviction_pressure_transition_period is not None:
            pulumi.set(__self__, "eviction_pressure_transition_period", eviction_pressure_transition_period)
        if eviction_soft is not None:
            pulumi.set(__self__, "eviction_soft", eviction_soft)
        if eviction_soft_grace_period is not None:
            pulumi.set(__self__, "eviction_soft_grace_period", eviction_soft_grace_period)
        if experimental_allowed_unsafe_sysctls is not None:
            pulumi.set(__self__, "experimental_allowed_unsafe_sysctls", experimental_allowed_unsafe_sysctls)
        if fail_swap_on is not None:
            pulumi.set(__self__, "fail_swap_on", fail_swap_on)
        if feature_gates is not None:
            pulumi.set(__self__, "feature_gates", feature_gates)
        if hairpin_mode is not None:
            pulumi.set(__self__, "hairpin_mode", hairpin_mode)
        if hostname_override is not None:
            pulumi.set(__self__, "hostname_override", hostname_override)
        if housekeeping_interval is not None:
            pulumi.set(__self__, "housekeeping_interval", housekeeping_interval)
        if image_gc_high_threshold_percent is not None:
            pulumi.set(__self__, "image_gc_high_threshold_percent", image_gc_high_threshold_percent)
        if image_gc_low_threshold_percent is not None:
            pulumi.set(__self__, "image_gc_low_threshold_percent", image_gc_low_threshold_percent)
        if image_pull_progress_deadline is not None:
            pulumi.set(__self__, "image_pull_progress_deadline", image_pull_progress_deadline)
        if kernel_memcg_notification is not None:
            pulumi.set(__self__, "kernel_memcg_notification", kernel_memcg_notification)
        if kube_reserved is not None:
            pulumi.set(__self__, "kube_reserved", kube_reserved)
        if kube_reserved_cgroup is not None:
            pulumi.set(__self__, "kube_reserved_cgroup", kube_reserved_cgroup)
        if kubeconfig_path is not None:
            pulumi.set(__self__, "kubeconfig_path", kubeconfig_path)
        if kubelet_cgroups is not None:
            pulumi.set(__self__, "kubelet_cgroups", kubelet_cgroups)
        if log_format is not None:
            pulumi.set(__self__, "log_format", log_format)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if network_plugin_mtu is not None:
            pulumi.set(__self__, "network_plugin_mtu", network_plugin_mtu)
        if network_plugin_name is not None:
            pulumi.set(__self__, "network_plugin_name", network_plugin_name)
        if node_labels is not None:
            pulumi.set(__self__, "node_labels", node_labels)
        if node_status_update_frequency is not None:
            pulumi.set(__self__, "node_status_update_frequency", node_status_update_frequency)
        if non_masquerade_cidr is not None:
            pulumi.set(__self__, "non_masquerade_cidr", non_masquerade_cidr)
        if nvidia_gp_us is not None:
            pulumi.set(__self__, "nvidia_gp_us", nvidia_gp_us)
        if pod_cidr is not None:
            pulumi.set(__self__, "pod_cidr", pod_cidr)
        if pod_infra_container_image is not None:
            pulumi.set(__self__, "pod_infra_container_image", pod_infra_container_image)
        if pod_manifest_path is not None:
            pulumi.set(__self__, "pod_manifest_path", pod_manifest_path)
        if pod_pids_limit is not None:
            pulumi.set(__self__, "pod_pids_limit", pod_pids_limit)
        if protect_kernel_defaults is not None:
            pulumi.set(__self__, "protect_kernel_defaults", protect_kernel_defaults)
        if read_only_port is not None:
            pulumi.set(__self__, "read_only_port", read_only_port)
        if reconcile_cidr is not None:
            pulumi.set(__self__, "reconcile_cidr", reconcile_cidr)
        if register_node is not None:
            pulumi.set(__self__, "register_node", register_node)
        if register_schedulable is not None:
            pulumi.set(__self__, "register_schedulable", register_schedulable)
        if registry_burst is not None:
            pulumi.set(__self__, "registry_burst", registry_burst)
        if registry_pull_qps is not None:
            pulumi.set(__self__, "registry_pull_qps", registry_pull_qps)
        if require_kubeconfig is not None:
            pulumi.set(__self__, "require_kubeconfig", require_kubeconfig)
        if resolver_config is not None:
            pulumi.set(__self__, "resolver_config", resolver_config)
        if root_dir is not None:
            pulumi.set(__self__, "root_dir", root_dir)
        if rotate_certificates is not None:
            pulumi.set(__self__, "rotate_certificates", rotate_certificates)
        if runtime_cgroups is not None:
            pulumi.set(__self__, "runtime_cgroups", runtime_cgroups)
        if runtime_request_timeout is not None:
            pulumi.set(__self__, "runtime_request_timeout", runtime_request_timeout)
        if seccomp_profile_root is not None:
            pulumi.set(__self__, "seccomp_profile_root", seccomp_profile_root)
        if serialize_image_pulls is not None:
            pulumi.set(__self__, "serialize_image_pulls", serialize_image_pulls)
        if shutdown_grace_period is not None:
            pulumi.set(__self__, "shutdown_grace_period", shutdown_grace_period)
        if shutdown_grace_period_critical_pods is not None:
            pulumi.set(__self__, "shutdown_grace_period_critical_pods", shutdown_grace_period_critical_pods)
        if streaming_connection_idle_timeout is not None:
            pulumi.set(__self__, "streaming_connection_idle_timeout", streaming_connection_idle_timeout)
        if system_cgroups is not None:
            pulumi.set(__self__, "system_cgroups", system_cgroups)
        if system_reserved is not None:
            pulumi.set(__self__, "system_reserved", system_reserved)
        if system_reserved_cgroup is not None:
            pulumi.set(__self__, "system_reserved_cgroup", system_reserved_cgroup)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if tls_cert_file is not None:
            pulumi.set(__self__, "tls_cert_file", tls_cert_file)
        if tls_cipher_suites is not None:
            pulumi.set(__self__, "tls_cipher_suites", tls_cipher_suites)
        if tls_min_version is not None:
            pulumi.set(__self__, "tls_min_version", tls_min_version)
        if tls_private_key_file is not None:
            pulumi.set(__self__, "tls_private_key_file", tls_private_key_file)
        if topology_manager_policy is not None:
            pulumi.set(__self__, "topology_manager_policy", topology_manager_policy)
        if volume_plugin_directory is not None:
            pulumi.set(__self__, "volume_plugin_directory", volume_plugin_directory)
        if volume_stats_agg_period is not None:
            pulumi.set(__self__, "volume_stats_agg_period", volume_stats_agg_period)

    @property
    @pulumi.getter(name="allowPrivileged")
    def allow_privileged(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privileged")

    @property
    @pulumi.getter(name="allowedUnsafeSysctls")
    def allowed_unsafe_sysctls(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_unsafe_sysctls")

    @property
    @pulumi.getter(name="anonymousAuth")
    def anonymous_auth(self) -> Optional['outputs.ClusterKubeletAnonymousAuth']:
        return pulumi.get(self, "anonymous_auth")

    @property
    @pulumi.getter(name="apiServers")
    def api_servers(self) -> Optional[str]:
        return pulumi.get(self, "api_servers")

    @property
    @pulumi.getter(name="authenticationTokenWebhook")
    def authentication_token_webhook(self) -> Optional[bool]:
        return pulumi.get(self, "authentication_token_webhook")

    @property
    @pulumi.getter(name="authenticationTokenWebhookCacheTtl")
    def authentication_token_webhook_cache_ttl(self) -> Optional[str]:
        return pulumi.get(self, "authentication_token_webhook_cache_ttl")

    @property
    @pulumi.getter(name="authorizationMode")
    def authorization_mode(self) -> Optional[str]:
        return pulumi.get(self, "authorization_mode")

    @property
    @pulumi.getter(name="babysitDaemons")
    def babysit_daemons(self) -> Optional[bool]:
        return pulumi.get(self, "babysit_daemons")

    @property
    @pulumi.getter(name="bootstrapKubeconfig")
    def bootstrap_kubeconfig(self) -> Optional[str]:
        return pulumi.get(self, "bootstrap_kubeconfig")

    @property
    @pulumi.getter(name="cgroupDriver")
    def cgroup_driver(self) -> Optional[str]:
        return pulumi.get(self, "cgroup_driver")

    @property
    @pulumi.getter(name="cgroupRoot")
    def cgroup_root(self) -> Optional[str]:
        return pulumi.get(self, "cgroup_root")

    @property
    @pulumi.getter(name="clientCaFile")
    def client_ca_file(self) -> Optional[str]:
        return pulumi.get(self, "client_ca_file")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[str]:
        """
        - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="clusterDns")
    def cluster_dns(self) -> Optional[str]:
        return pulumi.get(self, "cluster_dns")

    @property
    @pulumi.getter(name="clusterDomain")
    def cluster_domain(self) -> Optional[str]:
        return pulumi.get(self, "cluster_domain")

    @property
    @pulumi.getter(name="configureCbr0")
    def configure_cbr0(self) -> Optional[bool]:
        return pulumi.get(self, "configure_cbr0")

    @property
    @pulumi.getter(name="containerLogMaxFiles")
    def container_log_max_files(self) -> Optional[int]:
        return pulumi.get(self, "container_log_max_files")

    @property
    @pulumi.getter(name="containerLogMaxSize")
    def container_log_max_size(self) -> Optional[str]:
        return pulumi.get(self, "container_log_max_size")

    @property
    @pulumi.getter(name="cpuCfsQuota")
    def cpu_cfs_quota(self) -> Optional['outputs.ClusterKubeletCpuCfsQuota']:
        return pulumi.get(self, "cpu_cfs_quota")

    @property
    @pulumi.getter(name="cpuCfsQuotaPeriod")
    def cpu_cfs_quota_period(self) -> Optional[str]:
        return pulumi.get(self, "cpu_cfs_quota_period")

    @property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> Optional[str]:
        return pulumi.get(self, "cpu_manager_policy")

    @property
    @pulumi.getter(name="dockerDisableSharedPid")
    def docker_disable_shared_pid(self) -> Optional[bool]:
        return pulumi.get(self, "docker_disable_shared_pid")

    @property
    @pulumi.getter(name="enableCadvisorJsonEndpoints")
    def enable_cadvisor_json_endpoints(self) -> Optional[bool]:
        return pulumi.get(self, "enable_cadvisor_json_endpoints")

    @property
    @pulumi.getter(name="enableCustomMetrics")
    def enable_custom_metrics(self) -> Optional[bool]:
        return pulumi.get(self, "enable_custom_metrics")

    @property
    @pulumi.getter(name="enableDebuggingHandlers")
    def enable_debugging_handlers(self) -> Optional[bool]:
        return pulumi.get(self, "enable_debugging_handlers")

    @property
    @pulumi.getter(name="enforceNodeAllocatable")
    def enforce_node_allocatable(self) -> Optional[str]:
        return pulumi.get(self, "enforce_node_allocatable")

    @property
    @pulumi.getter(name="eventBurst")
    def event_burst(self) -> Optional[int]:
        return pulumi.get(self, "event_burst")

    @property
    @pulumi.getter(name="eventQps")
    def event_qps(self) -> Optional[int]:
        return pulumi.get(self, "event_qps")

    @property
    @pulumi.getter(name="evictionHard")
    def eviction_hard(self) -> Optional[str]:
        return pulumi.get(self, "eviction_hard")

    @property
    @pulumi.getter(name="evictionMaxPodGracePeriod")
    def eviction_max_pod_grace_period(self) -> Optional[int]:
        return pulumi.get(self, "eviction_max_pod_grace_period")

    @property
    @pulumi.getter(name="evictionMinimumReclaim")
    def eviction_minimum_reclaim(self) -> Optional[str]:
        return pulumi.get(self, "eviction_minimum_reclaim")

    @property
    @pulumi.getter(name="evictionPressureTransitionPeriod")
    def eviction_pressure_transition_period(self) -> Optional[str]:
        return pulumi.get(self, "eviction_pressure_transition_period")

    @property
    @pulumi.getter(name="evictionSoft")
    def eviction_soft(self) -> Optional[str]:
        return pulumi.get(self, "eviction_soft")

    @property
    @pulumi.getter(name="evictionSoftGracePeriod")
    def eviction_soft_grace_period(self) -> Optional[str]:
        return pulumi.get(self, "eviction_soft_grace_period")

    @property
    @pulumi.getter(name="experimentalAllowedUnsafeSysctls")
    def experimental_allowed_unsafe_sysctls(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "experimental_allowed_unsafe_sysctls")

    @property
    @pulumi.getter(name="failSwapOn")
    def fail_swap_on(self) -> Optional[bool]:
        return pulumi.get(self, "fail_swap_on")

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "feature_gates")

    @property
    @pulumi.getter(name="hairpinMode")
    def hairpin_mode(self) -> Optional[str]:
        return pulumi.get(self, "hairpin_mode")

    @property
    @pulumi.getter(name="hostnameOverride")
    def hostname_override(self) -> Optional[str]:
        return pulumi.get(self, "hostname_override")

    @property
    @pulumi.getter(name="housekeepingInterval")
    def housekeeping_interval(self) -> Optional[str]:
        return pulumi.get(self, "housekeeping_interval")

    @property
    @pulumi.getter(name="imageGcHighThresholdPercent")
    def image_gc_high_threshold_percent(self) -> Optional[int]:
        return pulumi.get(self, "image_gc_high_threshold_percent")

    @property
    @pulumi.getter(name="imageGcLowThresholdPercent")
    def image_gc_low_threshold_percent(self) -> Optional[int]:
        return pulumi.get(self, "image_gc_low_threshold_percent")

    @property
    @pulumi.getter(name="imagePullProgressDeadline")
    def image_pull_progress_deadline(self) -> Optional[str]:
        return pulumi.get(self, "image_pull_progress_deadline")

    @property
    @pulumi.getter(name="kernelMemcgNotification")
    def kernel_memcg_notification(self) -> Optional[bool]:
        return pulumi.get(self, "kernel_memcg_notification")

    @property
    @pulumi.getter(name="kubeReserved")
    def kube_reserved(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "kube_reserved")

    @property
    @pulumi.getter(name="kubeReservedCgroup")
    def kube_reserved_cgroup(self) -> Optional[str]:
        return pulumi.get(self, "kube_reserved_cgroup")

    @property
    @pulumi.getter(name="kubeconfigPath")
    def kubeconfig_path(self) -> Optional[str]:
        return pulumi.get(self, "kubeconfig_path")

    @property
    @pulumi.getter(name="kubeletCgroups")
    def kubelet_cgroups(self) -> Optional[str]:
        return pulumi.get(self, "kubelet_cgroups")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> Optional[str]:
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[int]:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[int]:
        return pulumi.get(self, "max_pods")

    @property
    @pulumi.getter(name="networkPluginMtu")
    def network_plugin_mtu(self) -> Optional[int]:
        return pulumi.get(self, "network_plugin_mtu")

    @property
    @pulumi.getter(name="networkPluginName")
    def network_plugin_name(self) -> Optional[str]:
        return pulumi.get(self, "network_plugin_name")

    @property
    @pulumi.getter(name="nodeLabels")
    def node_labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "node_labels")

    @property
    @pulumi.getter(name="nodeStatusUpdateFrequency")
    def node_status_update_frequency(self) -> Optional[str]:
        return pulumi.get(self, "node_status_update_frequency")

    @property
    @pulumi.getter(name="nonMasqueradeCidr")
    def non_masquerade_cidr(self) -> Optional[str]:
        """
        - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
        """
        return pulumi.get(self, "non_masquerade_cidr")

    @property
    @pulumi.getter(name="nvidiaGpUs")
    def nvidia_gp_us(self) -> Optional[int]:
        return pulumi.get(self, "nvidia_gp_us")

    @property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> Optional[str]:
        """
        - String - PodCIDR is the CIDR from which we allocate IPs for pods.
        """
        return pulumi.get(self, "pod_cidr")

    @property
    @pulumi.getter(name="podInfraContainerImage")
    def pod_infra_container_image(self) -> Optional[str]:
        return pulumi.get(self, "pod_infra_container_image")

    @property
    @pulumi.getter(name="podManifestPath")
    def pod_manifest_path(self) -> Optional[str]:
        return pulumi.get(self, "pod_manifest_path")

    @property
    @pulumi.getter(name="podPidsLimit")
    def pod_pids_limit(self) -> Optional[int]:
        return pulumi.get(self, "pod_pids_limit")

    @property
    @pulumi.getter(name="protectKernelDefaults")
    def protect_kernel_defaults(self) -> Optional[bool]:
        return pulumi.get(self, "protect_kernel_defaults")

    @property
    @pulumi.getter(name="readOnlyPort")
    def read_only_port(self) -> Optional[int]:
        return pulumi.get(self, "read_only_port")

    @property
    @pulumi.getter(name="reconcileCidr")
    def reconcile_cidr(self) -> Optional[bool]:
        return pulumi.get(self, "reconcile_cidr")

    @property
    @pulumi.getter(name="registerNode")
    def register_node(self) -> Optional[bool]:
        return pulumi.get(self, "register_node")

    @property
    @pulumi.getter(name="registerSchedulable")
    def register_schedulable(self) -> Optional[bool]:
        return pulumi.get(self, "register_schedulable")

    @property
    @pulumi.getter(name="registryBurst")
    def registry_burst(self) -> Optional[int]:
        return pulumi.get(self, "registry_burst")

    @property
    @pulumi.getter(name="registryPullQps")
    def registry_pull_qps(self) -> Optional[int]:
        return pulumi.get(self, "registry_pull_qps")

    @property
    @pulumi.getter(name="requireKubeconfig")
    def require_kubeconfig(self) -> Optional[bool]:
        return pulumi.get(self, "require_kubeconfig")

    @property
    @pulumi.getter(name="resolverConfig")
    def resolver_config(self) -> Optional[str]:
        return pulumi.get(self, "resolver_config")

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> Optional[str]:
        return pulumi.get(self, "root_dir")

    @property
    @pulumi.getter(name="rotateCertificates")
    def rotate_certificates(self) -> Optional[bool]:
        return pulumi.get(self, "rotate_certificates")

    @property
    @pulumi.getter(name="runtimeCgroups")
    def runtime_cgroups(self) -> Optional[str]:
        return pulumi.get(self, "runtime_cgroups")

    @property
    @pulumi.getter(name="runtimeRequestTimeout")
    def runtime_request_timeout(self) -> Optional[str]:
        return pulumi.get(self, "runtime_request_timeout")

    @property
    @pulumi.getter(name="seccompProfileRoot")
    def seccomp_profile_root(self) -> Optional[str]:
        return pulumi.get(self, "seccomp_profile_root")

    @property
    @pulumi.getter(name="serializeImagePulls")
    def serialize_image_pulls(self) -> Optional[bool]:
        return pulumi.get(self, "serialize_image_pulls")

    @property
    @pulumi.getter(name="shutdownGracePeriod")
    def shutdown_grace_period(self) -> Optional[str]:
        return pulumi.get(self, "shutdown_grace_period")

    @property
    @pulumi.getter(name="shutdownGracePeriodCriticalPods")
    def shutdown_grace_period_critical_pods(self) -> Optional[str]:
        return pulumi.get(self, "shutdown_grace_period_critical_pods")

    @property
    @pulumi.getter(name="streamingConnectionIdleTimeout")
    def streaming_connection_idle_timeout(self) -> Optional[str]:
        return pulumi.get(self, "streaming_connection_idle_timeout")

    @property
    @pulumi.getter(name="systemCgroups")
    def system_cgroups(self) -> Optional[str]:
        return pulumi.get(self, "system_cgroups")

    @property
    @pulumi.getter(name="systemReserved")
    def system_reserved(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "system_reserved")

    @property
    @pulumi.getter(name="systemReservedCgroup")
    def system_reserved_cgroup(self) -> Optional[str]:
        return pulumi.get(self, "system_reserved_cgroup")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "taints")

    @property
    @pulumi.getter(name="tlsCertFile")
    def tls_cert_file(self) -> Optional[str]:
        return pulumi.get(self, "tls_cert_file")

    @property
    @pulumi.getter(name="tlsCipherSuites")
    def tls_cipher_suites(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tls_cipher_suites")

    @property
    @pulumi.getter(name="tlsMinVersion")
    def tls_min_version(self) -> Optional[str]:
        return pulumi.get(self, "tls_min_version")

    @property
    @pulumi.getter(name="tlsPrivateKeyFile")
    def tls_private_key_file(self) -> Optional[str]:
        return pulumi.get(self, "tls_private_key_file")

    @property
    @pulumi.getter(name="topologyManagerPolicy")
    def topology_manager_policy(self) -> Optional[str]:
        return pulumi.get(self, "topology_manager_policy")

    @property
    @pulumi.getter(name="volumePluginDirectory")
    def volume_plugin_directory(self) -> Optional[str]:
        return pulumi.get(self, "volume_plugin_directory")

    @property
    @pulumi.getter(name="volumeStatsAggPeriod")
    def volume_stats_agg_period(self) -> Optional[str]:
        return pulumi.get(self, "volume_stats_agg_period")


@pulumi.output_type
class ClusterKubeletAnonymousAuth(dict):
    def __init__(__self__, *,
                 value: Optional[bool] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[bool]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterKubeletCpuCfsQuota(dict):
    def __init__(__self__, *,
                 value: Optional[bool] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[bool]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterMasterKubelet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPrivileged":
            suggest = "allow_privileged"
        elif key == "allowedUnsafeSysctls":
            suggest = "allowed_unsafe_sysctls"
        elif key == "anonymousAuth":
            suggest = "anonymous_auth"
        elif key == "apiServers":
            suggest = "api_servers"
        elif key == "authenticationTokenWebhook":
            suggest = "authentication_token_webhook"
        elif key == "authenticationTokenWebhookCacheTtl":
            suggest = "authentication_token_webhook_cache_ttl"
        elif key == "authorizationMode":
            suggest = "authorization_mode"
        elif key == "babysitDaemons":
            suggest = "babysit_daemons"
        elif key == "bootstrapKubeconfig":
            suggest = "bootstrap_kubeconfig"
        elif key == "cgroupDriver":
            suggest = "cgroup_driver"
        elif key == "cgroupRoot":
            suggest = "cgroup_root"
        elif key == "clientCaFile":
            suggest = "client_ca_file"
        elif key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "clusterDns":
            suggest = "cluster_dns"
        elif key == "clusterDomain":
            suggest = "cluster_domain"
        elif key == "configureCbr0":
            suggest = "configure_cbr0"
        elif key == "containerLogMaxFiles":
            suggest = "container_log_max_files"
        elif key == "containerLogMaxSize":
            suggest = "container_log_max_size"
        elif key == "cpuCfsQuota":
            suggest = "cpu_cfs_quota"
        elif key == "cpuCfsQuotaPeriod":
            suggest = "cpu_cfs_quota_period"
        elif key == "cpuManagerPolicy":
            suggest = "cpu_manager_policy"
        elif key == "dockerDisableSharedPid":
            suggest = "docker_disable_shared_pid"
        elif key == "enableCadvisorJsonEndpoints":
            suggest = "enable_cadvisor_json_endpoints"
        elif key == "enableCustomMetrics":
            suggest = "enable_custom_metrics"
        elif key == "enableDebuggingHandlers":
            suggest = "enable_debugging_handlers"
        elif key == "enforceNodeAllocatable":
            suggest = "enforce_node_allocatable"
        elif key == "eventBurst":
            suggest = "event_burst"
        elif key == "eventQps":
            suggest = "event_qps"
        elif key == "evictionHard":
            suggest = "eviction_hard"
        elif key == "evictionMaxPodGracePeriod":
            suggest = "eviction_max_pod_grace_period"
        elif key == "evictionMinimumReclaim":
            suggest = "eviction_minimum_reclaim"
        elif key == "evictionPressureTransitionPeriod":
            suggest = "eviction_pressure_transition_period"
        elif key == "evictionSoft":
            suggest = "eviction_soft"
        elif key == "evictionSoftGracePeriod":
            suggest = "eviction_soft_grace_period"
        elif key == "experimentalAllowedUnsafeSysctls":
            suggest = "experimental_allowed_unsafe_sysctls"
        elif key == "failSwapOn":
            suggest = "fail_swap_on"
        elif key == "featureGates":
            suggest = "feature_gates"
        elif key == "hairpinMode":
            suggest = "hairpin_mode"
        elif key == "hostnameOverride":
            suggest = "hostname_override"
        elif key == "housekeepingInterval":
            suggest = "housekeeping_interval"
        elif key == "imageGcHighThresholdPercent":
            suggest = "image_gc_high_threshold_percent"
        elif key == "imageGcLowThresholdPercent":
            suggest = "image_gc_low_threshold_percent"
        elif key == "imagePullProgressDeadline":
            suggest = "image_pull_progress_deadline"
        elif key == "kernelMemcgNotification":
            suggest = "kernel_memcg_notification"
        elif key == "kubeReserved":
            suggest = "kube_reserved"
        elif key == "kubeReservedCgroup":
            suggest = "kube_reserved_cgroup"
        elif key == "kubeconfigPath":
            suggest = "kubeconfig_path"
        elif key == "kubeletCgroups":
            suggest = "kubelet_cgroups"
        elif key == "logFormat":
            suggest = "log_format"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "maxPods":
            suggest = "max_pods"
        elif key == "networkPluginMtu":
            suggest = "network_plugin_mtu"
        elif key == "networkPluginName":
            suggest = "network_plugin_name"
        elif key == "nodeLabels":
            suggest = "node_labels"
        elif key == "nodeStatusUpdateFrequency":
            suggest = "node_status_update_frequency"
        elif key == "nonMasqueradeCidr":
            suggest = "non_masquerade_cidr"
        elif key == "nvidiaGpUs":
            suggest = "nvidia_gp_us"
        elif key == "podCidr":
            suggest = "pod_cidr"
        elif key == "podInfraContainerImage":
            suggest = "pod_infra_container_image"
        elif key == "podManifestPath":
            suggest = "pod_manifest_path"
        elif key == "podPidsLimit":
            suggest = "pod_pids_limit"
        elif key == "protectKernelDefaults":
            suggest = "protect_kernel_defaults"
        elif key == "readOnlyPort":
            suggest = "read_only_port"
        elif key == "reconcileCidr":
            suggest = "reconcile_cidr"
        elif key == "registerNode":
            suggest = "register_node"
        elif key == "registerSchedulable":
            suggest = "register_schedulable"
        elif key == "registryBurst":
            suggest = "registry_burst"
        elif key == "registryPullQps":
            suggest = "registry_pull_qps"
        elif key == "requireKubeconfig":
            suggest = "require_kubeconfig"
        elif key == "resolverConfig":
            suggest = "resolver_config"
        elif key == "rootDir":
            suggest = "root_dir"
        elif key == "rotateCertificates":
            suggest = "rotate_certificates"
        elif key == "runtimeCgroups":
            suggest = "runtime_cgroups"
        elif key == "runtimeRequestTimeout":
            suggest = "runtime_request_timeout"
        elif key == "seccompProfileRoot":
            suggest = "seccomp_profile_root"
        elif key == "serializeImagePulls":
            suggest = "serialize_image_pulls"
        elif key == "shutdownGracePeriod":
            suggest = "shutdown_grace_period"
        elif key == "shutdownGracePeriodCriticalPods":
            suggest = "shutdown_grace_period_critical_pods"
        elif key == "streamingConnectionIdleTimeout":
            suggest = "streaming_connection_idle_timeout"
        elif key == "systemCgroups":
            suggest = "system_cgroups"
        elif key == "systemReserved":
            suggest = "system_reserved"
        elif key == "systemReservedCgroup":
            suggest = "system_reserved_cgroup"
        elif key == "tlsCertFile":
            suggest = "tls_cert_file"
        elif key == "tlsCipherSuites":
            suggest = "tls_cipher_suites"
        elif key == "tlsMinVersion":
            suggest = "tls_min_version"
        elif key == "tlsPrivateKeyFile":
            suggest = "tls_private_key_file"
        elif key == "topologyManagerPolicy":
            suggest = "topology_manager_policy"
        elif key == "volumePluginDirectory":
            suggest = "volume_plugin_directory"
        elif key == "volumeStatsAggPeriod":
            suggest = "volume_stats_agg_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterMasterKubelet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterMasterKubelet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterMasterKubelet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_privileged: Optional[bool] = None,
                 allowed_unsafe_sysctls: Optional[Sequence[str]] = None,
                 anonymous_auth: Optional['outputs.ClusterMasterKubeletAnonymousAuth'] = None,
                 api_servers: Optional[str] = None,
                 authentication_token_webhook: Optional[bool] = None,
                 authentication_token_webhook_cache_ttl: Optional[str] = None,
                 authorization_mode: Optional[str] = None,
                 babysit_daemons: Optional[bool] = None,
                 bootstrap_kubeconfig: Optional[str] = None,
                 cgroup_driver: Optional[str] = None,
                 cgroup_root: Optional[str] = None,
                 client_ca_file: Optional[str] = None,
                 cloud_provider: Optional[str] = None,
                 cluster_dns: Optional[str] = None,
                 cluster_domain: Optional[str] = None,
                 configure_cbr0: Optional[bool] = None,
                 container_log_max_files: Optional[int] = None,
                 container_log_max_size: Optional[str] = None,
                 cpu_cfs_quota: Optional['outputs.ClusterMasterKubeletCpuCfsQuota'] = None,
                 cpu_cfs_quota_period: Optional[str] = None,
                 cpu_manager_policy: Optional[str] = None,
                 docker_disable_shared_pid: Optional[bool] = None,
                 enable_cadvisor_json_endpoints: Optional[bool] = None,
                 enable_custom_metrics: Optional[bool] = None,
                 enable_debugging_handlers: Optional[bool] = None,
                 enforce_node_allocatable: Optional[str] = None,
                 event_burst: Optional[int] = None,
                 event_qps: Optional[int] = None,
                 eviction_hard: Optional[str] = None,
                 eviction_max_pod_grace_period: Optional[int] = None,
                 eviction_minimum_reclaim: Optional[str] = None,
                 eviction_pressure_transition_period: Optional[str] = None,
                 eviction_soft: Optional[str] = None,
                 eviction_soft_grace_period: Optional[str] = None,
                 experimental_allowed_unsafe_sysctls: Optional[Sequence[str]] = None,
                 fail_swap_on: Optional[bool] = None,
                 feature_gates: Optional[Mapping[str, str]] = None,
                 hairpin_mode: Optional[str] = None,
                 hostname_override: Optional[str] = None,
                 housekeeping_interval: Optional[str] = None,
                 image_gc_high_threshold_percent: Optional[int] = None,
                 image_gc_low_threshold_percent: Optional[int] = None,
                 image_pull_progress_deadline: Optional[str] = None,
                 kernel_memcg_notification: Optional[bool] = None,
                 kube_reserved: Optional[Mapping[str, str]] = None,
                 kube_reserved_cgroup: Optional[str] = None,
                 kubeconfig_path: Optional[str] = None,
                 kubelet_cgroups: Optional[str] = None,
                 log_format: Optional[str] = None,
                 log_level: Optional[int] = None,
                 max_pods: Optional[int] = None,
                 network_plugin_mtu: Optional[int] = None,
                 network_plugin_name: Optional[str] = None,
                 node_labels: Optional[Mapping[str, str]] = None,
                 node_status_update_frequency: Optional[str] = None,
                 non_masquerade_cidr: Optional[str] = None,
                 nvidia_gp_us: Optional[int] = None,
                 pod_cidr: Optional[str] = None,
                 pod_infra_container_image: Optional[str] = None,
                 pod_manifest_path: Optional[str] = None,
                 pod_pids_limit: Optional[int] = None,
                 protect_kernel_defaults: Optional[bool] = None,
                 read_only_port: Optional[int] = None,
                 reconcile_cidr: Optional[bool] = None,
                 register_node: Optional[bool] = None,
                 register_schedulable: Optional[bool] = None,
                 registry_burst: Optional[int] = None,
                 registry_pull_qps: Optional[int] = None,
                 require_kubeconfig: Optional[bool] = None,
                 resolver_config: Optional[str] = None,
                 root_dir: Optional[str] = None,
                 rotate_certificates: Optional[bool] = None,
                 runtime_cgroups: Optional[str] = None,
                 runtime_request_timeout: Optional[str] = None,
                 seccomp_profile_root: Optional[str] = None,
                 serialize_image_pulls: Optional[bool] = None,
                 shutdown_grace_period: Optional[str] = None,
                 shutdown_grace_period_critical_pods: Optional[str] = None,
                 streaming_connection_idle_timeout: Optional[str] = None,
                 system_cgroups: Optional[str] = None,
                 system_reserved: Optional[Mapping[str, str]] = None,
                 system_reserved_cgroup: Optional[str] = None,
                 taints: Optional[Sequence[str]] = None,
                 tls_cert_file: Optional[str] = None,
                 tls_cipher_suites: Optional[Sequence[str]] = None,
                 tls_min_version: Optional[str] = None,
                 tls_private_key_file: Optional[str] = None,
                 topology_manager_policy: Optional[str] = None,
                 volume_plugin_directory: Optional[str] = None,
                 volume_stats_agg_period: Optional[str] = None):
        """
        :param str cloud_provider: - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        :param str non_masquerade_cidr: - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
        :param str pod_cidr: - String - PodCIDR is the CIDR from which we allocate IPs for pods.
        """
        if allow_privileged is not None:
            pulumi.set(__self__, "allow_privileged", allow_privileged)
        if allowed_unsafe_sysctls is not None:
            pulumi.set(__self__, "allowed_unsafe_sysctls", allowed_unsafe_sysctls)
        if anonymous_auth is not None:
            pulumi.set(__self__, "anonymous_auth", anonymous_auth)
        if api_servers is not None:
            pulumi.set(__self__, "api_servers", api_servers)
        if authentication_token_webhook is not None:
            pulumi.set(__self__, "authentication_token_webhook", authentication_token_webhook)
        if authentication_token_webhook_cache_ttl is not None:
            pulumi.set(__self__, "authentication_token_webhook_cache_ttl", authentication_token_webhook_cache_ttl)
        if authorization_mode is not None:
            pulumi.set(__self__, "authorization_mode", authorization_mode)
        if babysit_daemons is not None:
            pulumi.set(__self__, "babysit_daemons", babysit_daemons)
        if bootstrap_kubeconfig is not None:
            pulumi.set(__self__, "bootstrap_kubeconfig", bootstrap_kubeconfig)
        if cgroup_driver is not None:
            pulumi.set(__self__, "cgroup_driver", cgroup_driver)
        if cgroup_root is not None:
            pulumi.set(__self__, "cgroup_root", cgroup_root)
        if client_ca_file is not None:
            pulumi.set(__self__, "client_ca_file", client_ca_file)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if cluster_dns is not None:
            pulumi.set(__self__, "cluster_dns", cluster_dns)
        if cluster_domain is not None:
            pulumi.set(__self__, "cluster_domain", cluster_domain)
        if configure_cbr0 is not None:
            pulumi.set(__self__, "configure_cbr0", configure_cbr0)
        if container_log_max_files is not None:
            pulumi.set(__self__, "container_log_max_files", container_log_max_files)
        if container_log_max_size is not None:
            pulumi.set(__self__, "container_log_max_size", container_log_max_size)
        if cpu_cfs_quota is not None:
            pulumi.set(__self__, "cpu_cfs_quota", cpu_cfs_quota)
        if cpu_cfs_quota_period is not None:
            pulumi.set(__self__, "cpu_cfs_quota_period", cpu_cfs_quota_period)
        if cpu_manager_policy is not None:
            pulumi.set(__self__, "cpu_manager_policy", cpu_manager_policy)
        if docker_disable_shared_pid is not None:
            pulumi.set(__self__, "docker_disable_shared_pid", docker_disable_shared_pid)
        if enable_cadvisor_json_endpoints is not None:
            pulumi.set(__self__, "enable_cadvisor_json_endpoints", enable_cadvisor_json_endpoints)
        if enable_custom_metrics is not None:
            pulumi.set(__self__, "enable_custom_metrics", enable_custom_metrics)
        if enable_debugging_handlers is not None:
            pulumi.set(__self__, "enable_debugging_handlers", enable_debugging_handlers)
        if enforce_node_allocatable is not None:
            pulumi.set(__self__, "enforce_node_allocatable", enforce_node_allocatable)
        if event_burst is not None:
            pulumi.set(__self__, "event_burst", event_burst)
        if event_qps is not None:
            pulumi.set(__self__, "event_qps", event_qps)
        if eviction_hard is not None:
            pulumi.set(__self__, "eviction_hard", eviction_hard)
        if eviction_max_pod_grace_period is not None:
            pulumi.set(__self__, "eviction_max_pod_grace_period", eviction_max_pod_grace_period)
        if eviction_minimum_reclaim is not None:
            pulumi.set(__self__, "eviction_minimum_reclaim", eviction_minimum_reclaim)
        if eviction_pressure_transition_period is not None:
            pulumi.set(__self__, "eviction_pressure_transition_period", eviction_pressure_transition_period)
        if eviction_soft is not None:
            pulumi.set(__self__, "eviction_soft", eviction_soft)
        if eviction_soft_grace_period is not None:
            pulumi.set(__self__, "eviction_soft_grace_period", eviction_soft_grace_period)
        if experimental_allowed_unsafe_sysctls is not None:
            pulumi.set(__self__, "experimental_allowed_unsafe_sysctls", experimental_allowed_unsafe_sysctls)
        if fail_swap_on is not None:
            pulumi.set(__self__, "fail_swap_on", fail_swap_on)
        if feature_gates is not None:
            pulumi.set(__self__, "feature_gates", feature_gates)
        if hairpin_mode is not None:
            pulumi.set(__self__, "hairpin_mode", hairpin_mode)
        if hostname_override is not None:
            pulumi.set(__self__, "hostname_override", hostname_override)
        if housekeeping_interval is not None:
            pulumi.set(__self__, "housekeeping_interval", housekeeping_interval)
        if image_gc_high_threshold_percent is not None:
            pulumi.set(__self__, "image_gc_high_threshold_percent", image_gc_high_threshold_percent)
        if image_gc_low_threshold_percent is not None:
            pulumi.set(__self__, "image_gc_low_threshold_percent", image_gc_low_threshold_percent)
        if image_pull_progress_deadline is not None:
            pulumi.set(__self__, "image_pull_progress_deadline", image_pull_progress_deadline)
        if kernel_memcg_notification is not None:
            pulumi.set(__self__, "kernel_memcg_notification", kernel_memcg_notification)
        if kube_reserved is not None:
            pulumi.set(__self__, "kube_reserved", kube_reserved)
        if kube_reserved_cgroup is not None:
            pulumi.set(__self__, "kube_reserved_cgroup", kube_reserved_cgroup)
        if kubeconfig_path is not None:
            pulumi.set(__self__, "kubeconfig_path", kubeconfig_path)
        if kubelet_cgroups is not None:
            pulumi.set(__self__, "kubelet_cgroups", kubelet_cgroups)
        if log_format is not None:
            pulumi.set(__self__, "log_format", log_format)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if network_plugin_mtu is not None:
            pulumi.set(__self__, "network_plugin_mtu", network_plugin_mtu)
        if network_plugin_name is not None:
            pulumi.set(__self__, "network_plugin_name", network_plugin_name)
        if node_labels is not None:
            pulumi.set(__self__, "node_labels", node_labels)
        if node_status_update_frequency is not None:
            pulumi.set(__self__, "node_status_update_frequency", node_status_update_frequency)
        if non_masquerade_cidr is not None:
            pulumi.set(__self__, "non_masquerade_cidr", non_masquerade_cidr)
        if nvidia_gp_us is not None:
            pulumi.set(__self__, "nvidia_gp_us", nvidia_gp_us)
        if pod_cidr is not None:
            pulumi.set(__self__, "pod_cidr", pod_cidr)
        if pod_infra_container_image is not None:
            pulumi.set(__self__, "pod_infra_container_image", pod_infra_container_image)
        if pod_manifest_path is not None:
            pulumi.set(__self__, "pod_manifest_path", pod_manifest_path)
        if pod_pids_limit is not None:
            pulumi.set(__self__, "pod_pids_limit", pod_pids_limit)
        if protect_kernel_defaults is not None:
            pulumi.set(__self__, "protect_kernel_defaults", protect_kernel_defaults)
        if read_only_port is not None:
            pulumi.set(__self__, "read_only_port", read_only_port)
        if reconcile_cidr is not None:
            pulumi.set(__self__, "reconcile_cidr", reconcile_cidr)
        if register_node is not None:
            pulumi.set(__self__, "register_node", register_node)
        if register_schedulable is not None:
            pulumi.set(__self__, "register_schedulable", register_schedulable)
        if registry_burst is not None:
            pulumi.set(__self__, "registry_burst", registry_burst)
        if registry_pull_qps is not None:
            pulumi.set(__self__, "registry_pull_qps", registry_pull_qps)
        if require_kubeconfig is not None:
            pulumi.set(__self__, "require_kubeconfig", require_kubeconfig)
        if resolver_config is not None:
            pulumi.set(__self__, "resolver_config", resolver_config)
        if root_dir is not None:
            pulumi.set(__self__, "root_dir", root_dir)
        if rotate_certificates is not None:
            pulumi.set(__self__, "rotate_certificates", rotate_certificates)
        if runtime_cgroups is not None:
            pulumi.set(__self__, "runtime_cgroups", runtime_cgroups)
        if runtime_request_timeout is not None:
            pulumi.set(__self__, "runtime_request_timeout", runtime_request_timeout)
        if seccomp_profile_root is not None:
            pulumi.set(__self__, "seccomp_profile_root", seccomp_profile_root)
        if serialize_image_pulls is not None:
            pulumi.set(__self__, "serialize_image_pulls", serialize_image_pulls)
        if shutdown_grace_period is not None:
            pulumi.set(__self__, "shutdown_grace_period", shutdown_grace_period)
        if shutdown_grace_period_critical_pods is not None:
            pulumi.set(__self__, "shutdown_grace_period_critical_pods", shutdown_grace_period_critical_pods)
        if streaming_connection_idle_timeout is not None:
            pulumi.set(__self__, "streaming_connection_idle_timeout", streaming_connection_idle_timeout)
        if system_cgroups is not None:
            pulumi.set(__self__, "system_cgroups", system_cgroups)
        if system_reserved is not None:
            pulumi.set(__self__, "system_reserved", system_reserved)
        if system_reserved_cgroup is not None:
            pulumi.set(__self__, "system_reserved_cgroup", system_reserved_cgroup)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if tls_cert_file is not None:
            pulumi.set(__self__, "tls_cert_file", tls_cert_file)
        if tls_cipher_suites is not None:
            pulumi.set(__self__, "tls_cipher_suites", tls_cipher_suites)
        if tls_min_version is not None:
            pulumi.set(__self__, "tls_min_version", tls_min_version)
        if tls_private_key_file is not None:
            pulumi.set(__self__, "tls_private_key_file", tls_private_key_file)
        if topology_manager_policy is not None:
            pulumi.set(__self__, "topology_manager_policy", topology_manager_policy)
        if volume_plugin_directory is not None:
            pulumi.set(__self__, "volume_plugin_directory", volume_plugin_directory)
        if volume_stats_agg_period is not None:
            pulumi.set(__self__, "volume_stats_agg_period", volume_stats_agg_period)

    @property
    @pulumi.getter(name="allowPrivileged")
    def allow_privileged(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privileged")

    @property
    @pulumi.getter(name="allowedUnsafeSysctls")
    def allowed_unsafe_sysctls(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_unsafe_sysctls")

    @property
    @pulumi.getter(name="anonymousAuth")
    def anonymous_auth(self) -> Optional['outputs.ClusterMasterKubeletAnonymousAuth']:
        return pulumi.get(self, "anonymous_auth")

    @property
    @pulumi.getter(name="apiServers")
    def api_servers(self) -> Optional[str]:
        return pulumi.get(self, "api_servers")

    @property
    @pulumi.getter(name="authenticationTokenWebhook")
    def authentication_token_webhook(self) -> Optional[bool]:
        return pulumi.get(self, "authentication_token_webhook")

    @property
    @pulumi.getter(name="authenticationTokenWebhookCacheTtl")
    def authentication_token_webhook_cache_ttl(self) -> Optional[str]:
        return pulumi.get(self, "authentication_token_webhook_cache_ttl")

    @property
    @pulumi.getter(name="authorizationMode")
    def authorization_mode(self) -> Optional[str]:
        return pulumi.get(self, "authorization_mode")

    @property
    @pulumi.getter(name="babysitDaemons")
    def babysit_daemons(self) -> Optional[bool]:
        return pulumi.get(self, "babysit_daemons")

    @property
    @pulumi.getter(name="bootstrapKubeconfig")
    def bootstrap_kubeconfig(self) -> Optional[str]:
        return pulumi.get(self, "bootstrap_kubeconfig")

    @property
    @pulumi.getter(name="cgroupDriver")
    def cgroup_driver(self) -> Optional[str]:
        return pulumi.get(self, "cgroup_driver")

    @property
    @pulumi.getter(name="cgroupRoot")
    def cgroup_root(self) -> Optional[str]:
        return pulumi.get(self, "cgroup_root")

    @property
    @pulumi.getter(name="clientCaFile")
    def client_ca_file(self) -> Optional[str]:
        return pulumi.get(self, "client_ca_file")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[str]:
        """
        - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="clusterDns")
    def cluster_dns(self) -> Optional[str]:
        return pulumi.get(self, "cluster_dns")

    @property
    @pulumi.getter(name="clusterDomain")
    def cluster_domain(self) -> Optional[str]:
        return pulumi.get(self, "cluster_domain")

    @property
    @pulumi.getter(name="configureCbr0")
    def configure_cbr0(self) -> Optional[bool]:
        return pulumi.get(self, "configure_cbr0")

    @property
    @pulumi.getter(name="containerLogMaxFiles")
    def container_log_max_files(self) -> Optional[int]:
        return pulumi.get(self, "container_log_max_files")

    @property
    @pulumi.getter(name="containerLogMaxSize")
    def container_log_max_size(self) -> Optional[str]:
        return pulumi.get(self, "container_log_max_size")

    @property
    @pulumi.getter(name="cpuCfsQuota")
    def cpu_cfs_quota(self) -> Optional['outputs.ClusterMasterKubeletCpuCfsQuota']:
        return pulumi.get(self, "cpu_cfs_quota")

    @property
    @pulumi.getter(name="cpuCfsQuotaPeriod")
    def cpu_cfs_quota_period(self) -> Optional[str]:
        return pulumi.get(self, "cpu_cfs_quota_period")

    @property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> Optional[str]:
        return pulumi.get(self, "cpu_manager_policy")

    @property
    @pulumi.getter(name="dockerDisableSharedPid")
    def docker_disable_shared_pid(self) -> Optional[bool]:
        return pulumi.get(self, "docker_disable_shared_pid")

    @property
    @pulumi.getter(name="enableCadvisorJsonEndpoints")
    def enable_cadvisor_json_endpoints(self) -> Optional[bool]:
        return pulumi.get(self, "enable_cadvisor_json_endpoints")

    @property
    @pulumi.getter(name="enableCustomMetrics")
    def enable_custom_metrics(self) -> Optional[bool]:
        return pulumi.get(self, "enable_custom_metrics")

    @property
    @pulumi.getter(name="enableDebuggingHandlers")
    def enable_debugging_handlers(self) -> Optional[bool]:
        return pulumi.get(self, "enable_debugging_handlers")

    @property
    @pulumi.getter(name="enforceNodeAllocatable")
    def enforce_node_allocatable(self) -> Optional[str]:
        return pulumi.get(self, "enforce_node_allocatable")

    @property
    @pulumi.getter(name="eventBurst")
    def event_burst(self) -> Optional[int]:
        return pulumi.get(self, "event_burst")

    @property
    @pulumi.getter(name="eventQps")
    def event_qps(self) -> Optional[int]:
        return pulumi.get(self, "event_qps")

    @property
    @pulumi.getter(name="evictionHard")
    def eviction_hard(self) -> Optional[str]:
        return pulumi.get(self, "eviction_hard")

    @property
    @pulumi.getter(name="evictionMaxPodGracePeriod")
    def eviction_max_pod_grace_period(self) -> Optional[int]:
        return pulumi.get(self, "eviction_max_pod_grace_period")

    @property
    @pulumi.getter(name="evictionMinimumReclaim")
    def eviction_minimum_reclaim(self) -> Optional[str]:
        return pulumi.get(self, "eviction_minimum_reclaim")

    @property
    @pulumi.getter(name="evictionPressureTransitionPeriod")
    def eviction_pressure_transition_period(self) -> Optional[str]:
        return pulumi.get(self, "eviction_pressure_transition_period")

    @property
    @pulumi.getter(name="evictionSoft")
    def eviction_soft(self) -> Optional[str]:
        return pulumi.get(self, "eviction_soft")

    @property
    @pulumi.getter(name="evictionSoftGracePeriod")
    def eviction_soft_grace_period(self) -> Optional[str]:
        return pulumi.get(self, "eviction_soft_grace_period")

    @property
    @pulumi.getter(name="experimentalAllowedUnsafeSysctls")
    def experimental_allowed_unsafe_sysctls(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "experimental_allowed_unsafe_sysctls")

    @property
    @pulumi.getter(name="failSwapOn")
    def fail_swap_on(self) -> Optional[bool]:
        return pulumi.get(self, "fail_swap_on")

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "feature_gates")

    @property
    @pulumi.getter(name="hairpinMode")
    def hairpin_mode(self) -> Optional[str]:
        return pulumi.get(self, "hairpin_mode")

    @property
    @pulumi.getter(name="hostnameOverride")
    def hostname_override(self) -> Optional[str]:
        return pulumi.get(self, "hostname_override")

    @property
    @pulumi.getter(name="housekeepingInterval")
    def housekeeping_interval(self) -> Optional[str]:
        return pulumi.get(self, "housekeeping_interval")

    @property
    @pulumi.getter(name="imageGcHighThresholdPercent")
    def image_gc_high_threshold_percent(self) -> Optional[int]:
        return pulumi.get(self, "image_gc_high_threshold_percent")

    @property
    @pulumi.getter(name="imageGcLowThresholdPercent")
    def image_gc_low_threshold_percent(self) -> Optional[int]:
        return pulumi.get(self, "image_gc_low_threshold_percent")

    @property
    @pulumi.getter(name="imagePullProgressDeadline")
    def image_pull_progress_deadline(self) -> Optional[str]:
        return pulumi.get(self, "image_pull_progress_deadline")

    @property
    @pulumi.getter(name="kernelMemcgNotification")
    def kernel_memcg_notification(self) -> Optional[bool]:
        return pulumi.get(self, "kernel_memcg_notification")

    @property
    @pulumi.getter(name="kubeReserved")
    def kube_reserved(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "kube_reserved")

    @property
    @pulumi.getter(name="kubeReservedCgroup")
    def kube_reserved_cgroup(self) -> Optional[str]:
        return pulumi.get(self, "kube_reserved_cgroup")

    @property
    @pulumi.getter(name="kubeconfigPath")
    def kubeconfig_path(self) -> Optional[str]:
        return pulumi.get(self, "kubeconfig_path")

    @property
    @pulumi.getter(name="kubeletCgroups")
    def kubelet_cgroups(self) -> Optional[str]:
        return pulumi.get(self, "kubelet_cgroups")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> Optional[str]:
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[int]:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[int]:
        return pulumi.get(self, "max_pods")

    @property
    @pulumi.getter(name="networkPluginMtu")
    def network_plugin_mtu(self) -> Optional[int]:
        return pulumi.get(self, "network_plugin_mtu")

    @property
    @pulumi.getter(name="networkPluginName")
    def network_plugin_name(self) -> Optional[str]:
        return pulumi.get(self, "network_plugin_name")

    @property
    @pulumi.getter(name="nodeLabels")
    def node_labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "node_labels")

    @property
    @pulumi.getter(name="nodeStatusUpdateFrequency")
    def node_status_update_frequency(self) -> Optional[str]:
        return pulumi.get(self, "node_status_update_frequency")

    @property
    @pulumi.getter(name="nonMasqueradeCidr")
    def non_masquerade_cidr(self) -> Optional[str]:
        """
        - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
        """
        return pulumi.get(self, "non_masquerade_cidr")

    @property
    @pulumi.getter(name="nvidiaGpUs")
    def nvidia_gp_us(self) -> Optional[int]:
        return pulumi.get(self, "nvidia_gp_us")

    @property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> Optional[str]:
        """
        - String - PodCIDR is the CIDR from which we allocate IPs for pods.
        """
        return pulumi.get(self, "pod_cidr")

    @property
    @pulumi.getter(name="podInfraContainerImage")
    def pod_infra_container_image(self) -> Optional[str]:
        return pulumi.get(self, "pod_infra_container_image")

    @property
    @pulumi.getter(name="podManifestPath")
    def pod_manifest_path(self) -> Optional[str]:
        return pulumi.get(self, "pod_manifest_path")

    @property
    @pulumi.getter(name="podPidsLimit")
    def pod_pids_limit(self) -> Optional[int]:
        return pulumi.get(self, "pod_pids_limit")

    @property
    @pulumi.getter(name="protectKernelDefaults")
    def protect_kernel_defaults(self) -> Optional[bool]:
        return pulumi.get(self, "protect_kernel_defaults")

    @property
    @pulumi.getter(name="readOnlyPort")
    def read_only_port(self) -> Optional[int]:
        return pulumi.get(self, "read_only_port")

    @property
    @pulumi.getter(name="reconcileCidr")
    def reconcile_cidr(self) -> Optional[bool]:
        return pulumi.get(self, "reconcile_cidr")

    @property
    @pulumi.getter(name="registerNode")
    def register_node(self) -> Optional[bool]:
        return pulumi.get(self, "register_node")

    @property
    @pulumi.getter(name="registerSchedulable")
    def register_schedulable(self) -> Optional[bool]:
        return pulumi.get(self, "register_schedulable")

    @property
    @pulumi.getter(name="registryBurst")
    def registry_burst(self) -> Optional[int]:
        return pulumi.get(self, "registry_burst")

    @property
    @pulumi.getter(name="registryPullQps")
    def registry_pull_qps(self) -> Optional[int]:
        return pulumi.get(self, "registry_pull_qps")

    @property
    @pulumi.getter(name="requireKubeconfig")
    def require_kubeconfig(self) -> Optional[bool]:
        return pulumi.get(self, "require_kubeconfig")

    @property
    @pulumi.getter(name="resolverConfig")
    def resolver_config(self) -> Optional[str]:
        return pulumi.get(self, "resolver_config")

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> Optional[str]:
        return pulumi.get(self, "root_dir")

    @property
    @pulumi.getter(name="rotateCertificates")
    def rotate_certificates(self) -> Optional[bool]:
        return pulumi.get(self, "rotate_certificates")

    @property
    @pulumi.getter(name="runtimeCgroups")
    def runtime_cgroups(self) -> Optional[str]:
        return pulumi.get(self, "runtime_cgroups")

    @property
    @pulumi.getter(name="runtimeRequestTimeout")
    def runtime_request_timeout(self) -> Optional[str]:
        return pulumi.get(self, "runtime_request_timeout")

    @property
    @pulumi.getter(name="seccompProfileRoot")
    def seccomp_profile_root(self) -> Optional[str]:
        return pulumi.get(self, "seccomp_profile_root")

    @property
    @pulumi.getter(name="serializeImagePulls")
    def serialize_image_pulls(self) -> Optional[bool]:
        return pulumi.get(self, "serialize_image_pulls")

    @property
    @pulumi.getter(name="shutdownGracePeriod")
    def shutdown_grace_period(self) -> Optional[str]:
        return pulumi.get(self, "shutdown_grace_period")

    @property
    @pulumi.getter(name="shutdownGracePeriodCriticalPods")
    def shutdown_grace_period_critical_pods(self) -> Optional[str]:
        return pulumi.get(self, "shutdown_grace_period_critical_pods")

    @property
    @pulumi.getter(name="streamingConnectionIdleTimeout")
    def streaming_connection_idle_timeout(self) -> Optional[str]:
        return pulumi.get(self, "streaming_connection_idle_timeout")

    @property
    @pulumi.getter(name="systemCgroups")
    def system_cgroups(self) -> Optional[str]:
        return pulumi.get(self, "system_cgroups")

    @property
    @pulumi.getter(name="systemReserved")
    def system_reserved(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "system_reserved")

    @property
    @pulumi.getter(name="systemReservedCgroup")
    def system_reserved_cgroup(self) -> Optional[str]:
        return pulumi.get(self, "system_reserved_cgroup")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "taints")

    @property
    @pulumi.getter(name="tlsCertFile")
    def tls_cert_file(self) -> Optional[str]:
        return pulumi.get(self, "tls_cert_file")

    @property
    @pulumi.getter(name="tlsCipherSuites")
    def tls_cipher_suites(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tls_cipher_suites")

    @property
    @pulumi.getter(name="tlsMinVersion")
    def tls_min_version(self) -> Optional[str]:
        return pulumi.get(self, "tls_min_version")

    @property
    @pulumi.getter(name="tlsPrivateKeyFile")
    def tls_private_key_file(self) -> Optional[str]:
        return pulumi.get(self, "tls_private_key_file")

    @property
    @pulumi.getter(name="topologyManagerPolicy")
    def topology_manager_policy(self) -> Optional[str]:
        return pulumi.get(self, "topology_manager_policy")

    @property
    @pulumi.getter(name="volumePluginDirectory")
    def volume_plugin_directory(self) -> Optional[str]:
        return pulumi.get(self, "volume_plugin_directory")

    @property
    @pulumi.getter(name="volumeStatsAggPeriod")
    def volume_stats_agg_period(self) -> Optional[str]:
        return pulumi.get(self, "volume_stats_agg_period")


@pulumi.output_type
class ClusterMasterKubeletAnonymousAuth(dict):
    def __init__(__self__, *,
                 value: Optional[bool] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[bool]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterMasterKubeletCpuCfsQuota(dict):
    def __init__(__self__, *,
                 value: Optional[bool] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[bool]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterMetricsServer(dict):
    def __init__(__self__, *,
                 insecure: bool,
                 enabled: Optional[bool] = None,
                 image: Optional[str] = None):
        pulumi.set(__self__, "insecure", insecure)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter
    def insecure(self) -> bool:
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")


@pulumi.output_type
class ClusterNetworking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amazonVpc":
            suggest = "amazon_vpc"
        elif key == "lyftVpc":
            suggest = "lyft_vpc"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNetworking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNetworking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNetworking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amazon_vpc: Optional['outputs.ClusterNetworkingAmazonVpc'] = None,
                 calico: Optional['outputs.ClusterNetworkingCalico'] = None,
                 canal: Optional['outputs.ClusterNetworkingCanal'] = None,
                 cilium: Optional['outputs.ClusterNetworkingCilium'] = None,
                 classic: Optional['outputs.ClusterNetworkingClassic'] = None,
                 cni: Optional['outputs.ClusterNetworkingCni'] = None,
                 external: Optional['outputs.ClusterNetworkingExternal'] = None,
                 flannel: Optional['outputs.ClusterNetworkingFlannel'] = None,
                 gce: Optional['outputs.ClusterNetworkingGce'] = None,
                 kopeio: Optional['outputs.ClusterNetworkingKopeio'] = None,
                 kubenet: Optional['outputs.ClusterNetworkingKubenet'] = None,
                 kuberouter: Optional['outputs.ClusterNetworkingKuberouter'] = None,
                 lyft_vpc: Optional['outputs.ClusterNetworkingLyftVpc'] = None,
                 romana: Optional['outputs.ClusterNetworkingRomana'] = None,
                 weave: Optional['outputs.ClusterNetworkingWeave'] = None):
        if amazon_vpc is not None:
            pulumi.set(__self__, "amazon_vpc", amazon_vpc)
        if calico is not None:
            pulumi.set(__self__, "calico", calico)
        if canal is not None:
            pulumi.set(__self__, "canal", canal)
        if cilium is not None:
            pulumi.set(__self__, "cilium", cilium)
        if classic is not None:
            pulumi.set(__self__, "classic", classic)
        if cni is not None:
            pulumi.set(__self__, "cni", cni)
        if external is not None:
            pulumi.set(__self__, "external", external)
        if flannel is not None:
            pulumi.set(__self__, "flannel", flannel)
        if gce is not None:
            pulumi.set(__self__, "gce", gce)
        if kopeio is not None:
            pulumi.set(__self__, "kopeio", kopeio)
        if kubenet is not None:
            pulumi.set(__self__, "kubenet", kubenet)
        if kuberouter is not None:
            pulumi.set(__self__, "kuberouter", kuberouter)
        if lyft_vpc is not None:
            pulumi.set(__self__, "lyft_vpc", lyft_vpc)
        if romana is not None:
            pulumi.set(__self__, "romana", romana)
        if weave is not None:
            pulumi.set(__self__, "weave", weave)

    @property
    @pulumi.getter(name="amazonVpc")
    def amazon_vpc(self) -> Optional['outputs.ClusterNetworkingAmazonVpc']:
        return pulumi.get(self, "amazon_vpc")

    @property
    @pulumi.getter
    def calico(self) -> Optional['outputs.ClusterNetworkingCalico']:
        return pulumi.get(self, "calico")

    @property
    @pulumi.getter
    def canal(self) -> Optional['outputs.ClusterNetworkingCanal']:
        return pulumi.get(self, "canal")

    @property
    @pulumi.getter
    def cilium(self) -> Optional['outputs.ClusterNetworkingCilium']:
        return pulumi.get(self, "cilium")

    @property
    @pulumi.getter
    def classic(self) -> Optional['outputs.ClusterNetworkingClassic']:
        return pulumi.get(self, "classic")

    @property
    @pulumi.getter
    def cni(self) -> Optional['outputs.ClusterNetworkingCni']:
        return pulumi.get(self, "cni")

    @property
    @pulumi.getter
    def external(self) -> Optional['outputs.ClusterNetworkingExternal']:
        return pulumi.get(self, "external")

    @property
    @pulumi.getter
    def flannel(self) -> Optional['outputs.ClusterNetworkingFlannel']:
        return pulumi.get(self, "flannel")

    @property
    @pulumi.getter
    def gce(self) -> Optional['outputs.ClusterNetworkingGce']:
        return pulumi.get(self, "gce")

    @property
    @pulumi.getter
    def kopeio(self) -> Optional['outputs.ClusterNetworkingKopeio']:
        return pulumi.get(self, "kopeio")

    @property
    @pulumi.getter
    def kubenet(self) -> Optional['outputs.ClusterNetworkingKubenet']:
        return pulumi.get(self, "kubenet")

    @property
    @pulumi.getter
    def kuberouter(self) -> Optional['outputs.ClusterNetworkingKuberouter']:
        return pulumi.get(self, "kuberouter")

    @property
    @pulumi.getter(name="lyftVpc")
    def lyft_vpc(self) -> Optional['outputs.ClusterNetworkingLyftVpc']:
        return pulumi.get(self, "lyft_vpc")

    @property
    @pulumi.getter
    def romana(self) -> Optional['outputs.ClusterNetworkingRomana']:
        return pulumi.get(self, "romana")

    @property
    @pulumi.getter
    def weave(self) -> Optional['outputs.ClusterNetworkingWeave']:
        return pulumi.get(self, "weave")


@pulumi.output_type
class ClusterNetworkingAmazonVpc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initImage":
            suggest = "init_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNetworkingAmazonVpc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNetworkingAmazonVpc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNetworkingAmazonVpc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 envs: Optional[Sequence['outputs.ClusterNetworkingAmazonVpcEnv']] = None,
                 image: Optional[str] = None,
                 init_image: Optional[str] = None):
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if init_image is not None:
            pulumi.set(__self__, "init_image", init_image)

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.ClusterNetworkingAmazonVpcEnv']]:
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="initImage")
    def init_image(self) -> Optional[str]:
        return pulumi.get(self, "init_image")


@pulumi.output_type
class ClusterNetworkingAmazonVpcEnv(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str name: - (Force new) - String - Name defines the cluster name.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - (Force new) - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterNetworkingCalico(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowIpForwarding":
            suggest = "allow_ip_forwarding"
        elif key == "awsSrcDstCheck":
            suggest = "aws_src_dst_check"
        elif key == "bpfEnabled":
            suggest = "bpf_enabled"
        elif key == "bpfExternalServiceMode":
            suggest = "bpf_external_service_mode"
        elif key == "bpfKubeProxyIptablesCleanupEnabled":
            suggest = "bpf_kube_proxy_iptables_cleanup_enabled"
        elif key == "bpfLogLevel":
            suggest = "bpf_log_level"
        elif key == "chainInsertMode":
            suggest = "chain_insert_mode"
        elif key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "crossSubnet":
            suggest = "cross_subnet"
        elif key == "encapsulationMode":
            suggest = "encapsulation_mode"
        elif key == "ipIpMode":
            suggest = "ip_ip_mode"
        elif key == "iptablesBackend":
            suggest = "iptables_backend"
        elif key == "ipv4AutoDetectionMethod":
            suggest = "ipv4_auto_detection_method"
        elif key == "ipv6AutoDetectionMethod":
            suggest = "ipv6_auto_detection_method"
        elif key == "logSeverityScreen":
            suggest = "log_severity_screen"
        elif key == "prometheusGoMetricsEnabled":
            suggest = "prometheus_go_metrics_enabled"
        elif key == "prometheusMetricsEnabled":
            suggest = "prometheus_metrics_enabled"
        elif key == "prometheusMetricsPort":
            suggest = "prometheus_metrics_port"
        elif key == "prometheusProcessMetricsEnabled":
            suggest = "prometheus_process_metrics_enabled"
        elif key == "typhaPrometheusMetricsEnabled":
            suggest = "typha_prometheus_metrics_enabled"
        elif key == "typhaPrometheusMetricsPort":
            suggest = "typha_prometheus_metrics_port"
        elif key == "typhaReplicas":
            suggest = "typha_replicas"
        elif key == "vxlanMode":
            suggest = "vxlan_mode"
        elif key == "wireguardEnabled":
            suggest = "wireguard_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNetworkingCalico. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNetworkingCalico.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNetworkingCalico.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_ip_forwarding: Optional[bool] = None,
                 aws_src_dst_check: Optional[str] = None,
                 bpf_enabled: Optional[bool] = None,
                 bpf_external_service_mode: Optional[str] = None,
                 bpf_kube_proxy_iptables_cleanup_enabled: Optional[bool] = None,
                 bpf_log_level: Optional[str] = None,
                 chain_insert_mode: Optional[str] = None,
                 cpu_request: Optional[str] = None,
                 cross_subnet: Optional[bool] = None,
                 encapsulation_mode: Optional[str] = None,
                 ip_ip_mode: Optional[str] = None,
                 iptables_backend: Optional[str] = None,
                 ipv4_auto_detection_method: Optional[str] = None,
                 ipv6_auto_detection_method: Optional[str] = None,
                 log_severity_screen: Optional[str] = None,
                 mtu: Optional[int] = None,
                 prometheus_go_metrics_enabled: Optional[bool] = None,
                 prometheus_metrics_enabled: Optional[bool] = None,
                 prometheus_metrics_port: Optional[int] = None,
                 prometheus_process_metrics_enabled: Optional[bool] = None,
                 registry: Optional[str] = None,
                 typha_prometheus_metrics_enabled: Optional[bool] = None,
                 typha_prometheus_metrics_port: Optional[int] = None,
                 typha_replicas: Optional[int] = None,
                 version: Optional[str] = None,
                 vxlan_mode: Optional[str] = None,
                 wireguard_enabled: Optional[bool] = None):
        if allow_ip_forwarding is not None:
            pulumi.set(__self__, "allow_ip_forwarding", allow_ip_forwarding)
        if aws_src_dst_check is not None:
            pulumi.set(__self__, "aws_src_dst_check", aws_src_dst_check)
        if bpf_enabled is not None:
            pulumi.set(__self__, "bpf_enabled", bpf_enabled)
        if bpf_external_service_mode is not None:
            pulumi.set(__self__, "bpf_external_service_mode", bpf_external_service_mode)
        if bpf_kube_proxy_iptables_cleanup_enabled is not None:
            pulumi.set(__self__, "bpf_kube_proxy_iptables_cleanup_enabled", bpf_kube_proxy_iptables_cleanup_enabled)
        if bpf_log_level is not None:
            pulumi.set(__self__, "bpf_log_level", bpf_log_level)
        if chain_insert_mode is not None:
            pulumi.set(__self__, "chain_insert_mode", chain_insert_mode)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if cross_subnet is not None:
            pulumi.set(__self__, "cross_subnet", cross_subnet)
        if encapsulation_mode is not None:
            pulumi.set(__self__, "encapsulation_mode", encapsulation_mode)
        if ip_ip_mode is not None:
            pulumi.set(__self__, "ip_ip_mode", ip_ip_mode)
        if iptables_backend is not None:
            pulumi.set(__self__, "iptables_backend", iptables_backend)
        if ipv4_auto_detection_method is not None:
            pulumi.set(__self__, "ipv4_auto_detection_method", ipv4_auto_detection_method)
        if ipv6_auto_detection_method is not None:
            pulumi.set(__self__, "ipv6_auto_detection_method", ipv6_auto_detection_method)
        if log_severity_screen is not None:
            pulumi.set(__self__, "log_severity_screen", log_severity_screen)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if prometheus_go_metrics_enabled is not None:
            pulumi.set(__self__, "prometheus_go_metrics_enabled", prometheus_go_metrics_enabled)
        if prometheus_metrics_enabled is not None:
            pulumi.set(__self__, "prometheus_metrics_enabled", prometheus_metrics_enabled)
        if prometheus_metrics_port is not None:
            pulumi.set(__self__, "prometheus_metrics_port", prometheus_metrics_port)
        if prometheus_process_metrics_enabled is not None:
            pulumi.set(__self__, "prometheus_process_metrics_enabled", prometheus_process_metrics_enabled)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if typha_prometheus_metrics_enabled is not None:
            pulumi.set(__self__, "typha_prometheus_metrics_enabled", typha_prometheus_metrics_enabled)
        if typha_prometheus_metrics_port is not None:
            pulumi.set(__self__, "typha_prometheus_metrics_port", typha_prometheus_metrics_port)
        if typha_replicas is not None:
            pulumi.set(__self__, "typha_replicas", typha_replicas)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if vxlan_mode is not None:
            pulumi.set(__self__, "vxlan_mode", vxlan_mode)
        if wireguard_enabled is not None:
            pulumi.set(__self__, "wireguard_enabled", wireguard_enabled)

    @property
    @pulumi.getter(name="allowIpForwarding")
    def allow_ip_forwarding(self) -> Optional[bool]:
        return pulumi.get(self, "allow_ip_forwarding")

    @property
    @pulumi.getter(name="awsSrcDstCheck")
    def aws_src_dst_check(self) -> Optional[str]:
        return pulumi.get(self, "aws_src_dst_check")

    @property
    @pulumi.getter(name="bpfEnabled")
    def bpf_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "bpf_enabled")

    @property
    @pulumi.getter(name="bpfExternalServiceMode")
    def bpf_external_service_mode(self) -> Optional[str]:
        return pulumi.get(self, "bpf_external_service_mode")

    @property
    @pulumi.getter(name="bpfKubeProxyIptablesCleanupEnabled")
    def bpf_kube_proxy_iptables_cleanup_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "bpf_kube_proxy_iptables_cleanup_enabled")

    @property
    @pulumi.getter(name="bpfLogLevel")
    def bpf_log_level(self) -> Optional[str]:
        return pulumi.get(self, "bpf_log_level")

    @property
    @pulumi.getter(name="chainInsertMode")
    def chain_insert_mode(self) -> Optional[str]:
        return pulumi.get(self, "chain_insert_mode")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[str]:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter(name="crossSubnet")
    def cross_subnet(self) -> Optional[bool]:
        return pulumi.get(self, "cross_subnet")

    @property
    @pulumi.getter(name="encapsulationMode")
    def encapsulation_mode(self) -> Optional[str]:
        return pulumi.get(self, "encapsulation_mode")

    @property
    @pulumi.getter(name="ipIpMode")
    def ip_ip_mode(self) -> Optional[str]:
        return pulumi.get(self, "ip_ip_mode")

    @property
    @pulumi.getter(name="iptablesBackend")
    def iptables_backend(self) -> Optional[str]:
        return pulumi.get(self, "iptables_backend")

    @property
    @pulumi.getter(name="ipv4AutoDetectionMethod")
    def ipv4_auto_detection_method(self) -> Optional[str]:
        return pulumi.get(self, "ipv4_auto_detection_method")

    @property
    @pulumi.getter(name="ipv6AutoDetectionMethod")
    def ipv6_auto_detection_method(self) -> Optional[str]:
        return pulumi.get(self, "ipv6_auto_detection_method")

    @property
    @pulumi.getter(name="logSeverityScreen")
    def log_severity_screen(self) -> Optional[str]:
        return pulumi.get(self, "log_severity_screen")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter(name="prometheusGoMetricsEnabled")
    def prometheus_go_metrics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "prometheus_go_metrics_enabled")

    @property
    @pulumi.getter(name="prometheusMetricsEnabled")
    def prometheus_metrics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "prometheus_metrics_enabled")

    @property
    @pulumi.getter(name="prometheusMetricsPort")
    def prometheus_metrics_port(self) -> Optional[int]:
        return pulumi.get(self, "prometheus_metrics_port")

    @property
    @pulumi.getter(name="prometheusProcessMetricsEnabled")
    def prometheus_process_metrics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "prometheus_process_metrics_enabled")

    @property
    @pulumi.getter
    def registry(self) -> Optional[str]:
        return pulumi.get(self, "registry")

    @property
    @pulumi.getter(name="typhaPrometheusMetricsEnabled")
    def typha_prometheus_metrics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "typha_prometheus_metrics_enabled")

    @property
    @pulumi.getter(name="typhaPrometheusMetricsPort")
    def typha_prometheus_metrics_port(self) -> Optional[int]:
        return pulumi.get(self, "typha_prometheus_metrics_port")

    @property
    @pulumi.getter(name="typhaReplicas")
    def typha_replicas(self) -> Optional[int]:
        return pulumi.get(self, "typha_replicas")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="vxlanMode")
    def vxlan_mode(self) -> Optional[str]:
        return pulumi.get(self, "vxlan_mode")

    @property
    @pulumi.getter(name="wireguardEnabled")
    def wireguard_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "wireguard_enabled")


@pulumi.output_type
class ClusterNetworkingCanal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chainInsertMode":
            suggest = "chain_insert_mode"
        elif key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "defaultEndpointToHostAction":
            suggest = "default_endpoint_to_host_action"
        elif key == "flanneldIptablesForwardRules":
            suggest = "flanneld_iptables_forward_rules"
        elif key == "iptablesBackend":
            suggest = "iptables_backend"
        elif key == "logSeveritySys":
            suggest = "log_severity_sys"
        elif key == "prometheusGoMetricsEnabled":
            suggest = "prometheus_go_metrics_enabled"
        elif key == "prometheusMetricsEnabled":
            suggest = "prometheus_metrics_enabled"
        elif key == "prometheusMetricsPort":
            suggest = "prometheus_metrics_port"
        elif key == "prometheusProcessMetricsEnabled":
            suggest = "prometheus_process_metrics_enabled"
        elif key == "typhaPrometheusMetricsEnabled":
            suggest = "typha_prometheus_metrics_enabled"
        elif key == "typhaPrometheusMetricsPort":
            suggest = "typha_prometheus_metrics_port"
        elif key == "typhaReplicas":
            suggest = "typha_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNetworkingCanal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNetworkingCanal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNetworkingCanal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chain_insert_mode: Optional[str] = None,
                 cpu_request: Optional[str] = None,
                 default_endpoint_to_host_action: Optional[str] = None,
                 flanneld_iptables_forward_rules: Optional[bool] = None,
                 iptables_backend: Optional[str] = None,
                 log_severity_sys: Optional[str] = None,
                 mtu: Optional[int] = None,
                 prometheus_go_metrics_enabled: Optional[bool] = None,
                 prometheus_metrics_enabled: Optional[bool] = None,
                 prometheus_metrics_port: Optional[int] = None,
                 prometheus_process_metrics_enabled: Optional[bool] = None,
                 typha_prometheus_metrics_enabled: Optional[bool] = None,
                 typha_prometheus_metrics_port: Optional[int] = None,
                 typha_replicas: Optional[int] = None):
        if chain_insert_mode is not None:
            pulumi.set(__self__, "chain_insert_mode", chain_insert_mode)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if default_endpoint_to_host_action is not None:
            pulumi.set(__self__, "default_endpoint_to_host_action", default_endpoint_to_host_action)
        if flanneld_iptables_forward_rules is not None:
            pulumi.set(__self__, "flanneld_iptables_forward_rules", flanneld_iptables_forward_rules)
        if iptables_backend is not None:
            pulumi.set(__self__, "iptables_backend", iptables_backend)
        if log_severity_sys is not None:
            pulumi.set(__self__, "log_severity_sys", log_severity_sys)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if prometheus_go_metrics_enabled is not None:
            pulumi.set(__self__, "prometheus_go_metrics_enabled", prometheus_go_metrics_enabled)
        if prometheus_metrics_enabled is not None:
            pulumi.set(__self__, "prometheus_metrics_enabled", prometheus_metrics_enabled)
        if prometheus_metrics_port is not None:
            pulumi.set(__self__, "prometheus_metrics_port", prometheus_metrics_port)
        if prometheus_process_metrics_enabled is not None:
            pulumi.set(__self__, "prometheus_process_metrics_enabled", prometheus_process_metrics_enabled)
        if typha_prometheus_metrics_enabled is not None:
            pulumi.set(__self__, "typha_prometheus_metrics_enabled", typha_prometheus_metrics_enabled)
        if typha_prometheus_metrics_port is not None:
            pulumi.set(__self__, "typha_prometheus_metrics_port", typha_prometheus_metrics_port)
        if typha_replicas is not None:
            pulumi.set(__self__, "typha_replicas", typha_replicas)

    @property
    @pulumi.getter(name="chainInsertMode")
    def chain_insert_mode(self) -> Optional[str]:
        return pulumi.get(self, "chain_insert_mode")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[str]:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter(name="defaultEndpointToHostAction")
    def default_endpoint_to_host_action(self) -> Optional[str]:
        return pulumi.get(self, "default_endpoint_to_host_action")

    @property
    @pulumi.getter(name="flanneldIptablesForwardRules")
    def flanneld_iptables_forward_rules(self) -> Optional[bool]:
        return pulumi.get(self, "flanneld_iptables_forward_rules")

    @property
    @pulumi.getter(name="iptablesBackend")
    def iptables_backend(self) -> Optional[str]:
        return pulumi.get(self, "iptables_backend")

    @property
    @pulumi.getter(name="logSeveritySys")
    def log_severity_sys(self) -> Optional[str]:
        return pulumi.get(self, "log_severity_sys")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter(name="prometheusGoMetricsEnabled")
    def prometheus_go_metrics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "prometheus_go_metrics_enabled")

    @property
    @pulumi.getter(name="prometheusMetricsEnabled")
    def prometheus_metrics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "prometheus_metrics_enabled")

    @property
    @pulumi.getter(name="prometheusMetricsPort")
    def prometheus_metrics_port(self) -> Optional[int]:
        return pulumi.get(self, "prometheus_metrics_port")

    @property
    @pulumi.getter(name="prometheusProcessMetricsEnabled")
    def prometheus_process_metrics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "prometheus_process_metrics_enabled")

    @property
    @pulumi.getter(name="typhaPrometheusMetricsEnabled")
    def typha_prometheus_metrics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "typha_prometheus_metrics_enabled")

    @property
    @pulumi.getter(name="typhaPrometheusMetricsPort")
    def typha_prometheus_metrics_port(self) -> Optional[int]:
        return pulumi.get(self, "typha_prometheus_metrics_port")

    @property
    @pulumi.getter(name="typhaReplicas")
    def typha_replicas(self) -> Optional[int]:
        return pulumi.get(self, "typha_replicas")


@pulumi.output_type
class ClusterNetworkingCilium(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableRemoteNodeIdentity":
            suggest = "enable_remote_node_identity"
        elif key == "preallocateBpfMaps":
            suggest = "preallocate_bpf_maps"
        elif key == "agentPodAnnotations":
            suggest = "agent_pod_annotations"
        elif key == "agentPrometheusPort":
            suggest = "agent_prometheus_port"
        elif key == "autoDirectNodeRoutes":
            suggest = "auto_direct_node_routes"
        elif key == "bpfNeighGlobalMax":
            suggest = "bpf_neigh_global_max"
        elif key == "bpfPolicyMapMax":
            suggest = "bpf_policy_map_max"
        elif key == "bpfctGlobalAnyMax":
            suggest = "bpfct_global_any_max"
        elif key == "bpfctGlobalTcpMax":
            suggest = "bpfct_global_tcp_max"
        elif key == "bpflbAlgorithm":
            suggest = "bpflb_algorithm"
        elif key == "bpflbMaglevTableSize":
            suggest = "bpflb_maglev_table_size"
        elif key == "bpflbMapMax":
            suggest = "bpflb_map_max"
        elif key == "bpflbSockHostNsOnly":
            suggest = "bpflb_sock_host_ns_only"
        elif key == "bpfnatGlobalMax":
            suggest = "bpfnat_global_max"
        elif key == "chainingMode":
            suggest = "chaining_mode"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "disableCnpStatusUpdates":
            suggest = "disable_cnp_status_updates"
        elif key == "disableEndpointCrd":
            suggest = "disable_endpoint_crd"
        elif key == "enableBpfMasquerade":
            suggest = "enable_bpf_masquerade"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "enableEndpointHealthChecking":
            suggest = "enable_endpoint_health_checking"
        elif key == "enableHostReachableServices":
            suggest = "enable_host_reachable_services"
        elif key == "enableL7Proxy":
            suggest = "enable_l7_proxy"
        elif key == "enableNodePort":
            suggest = "enable_node_port"
        elif key == "enablePolicy":
            suggest = "enable_policy"
        elif key == "enablePrometheusMetrics":
            suggest = "enable_prometheus_metrics"
        elif key == "enableServiceTopology":
            suggest = "enable_service_topology"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "etcdManaged":
            suggest = "etcd_managed"
        elif key == "identityAllocationMode":
            suggest = "identity_allocation_mode"
        elif key == "identityChangeGracePeriod":
            suggest = "identity_change_grace_period"
        elif key == "installIptablesRules":
            suggest = "install_iptables_rules"
        elif key == "memoryRequest":
            suggest = "memory_request"
        elif key == "monitorAggregation":
            suggest = "monitor_aggregation"
        elif key == "sidecarIstioProxyImage":
            suggest = "sidecar_istio_proxy_image"
        elif key == "toFqdnsDnsRejectResponseCode":
            suggest = "to_fqdns_dns_reject_response_code"
        elif key == "toFqdnsEnablePoller":
            suggest = "to_fqdns_enable_poller"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNetworkingCilium. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNetworkingCilium.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNetworkingCilium.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_remote_node_identity: bool,
                 preallocate_bpf_maps: bool,
                 agent_pod_annotations: Optional[Mapping[str, str]] = None,
                 agent_prometheus_port: Optional[int] = None,
                 auto_direct_node_routes: Optional[bool] = None,
                 bpf_neigh_global_max: Optional[int] = None,
                 bpf_policy_map_max: Optional[int] = None,
                 bpfct_global_any_max: Optional[int] = None,
                 bpfct_global_tcp_max: Optional[int] = None,
                 bpflb_algorithm: Optional[str] = None,
                 bpflb_maglev_table_size: Optional[str] = None,
                 bpflb_map_max: Optional[int] = None,
                 bpflb_sock_host_ns_only: Optional[bool] = None,
                 bpfnat_global_max: Optional[int] = None,
                 chaining_mode: Optional[str] = None,
                 cluster_name: Optional[str] = None,
                 cpu_request: Optional[str] = None,
                 debug: Optional[bool] = None,
                 disable_cnp_status_updates: Optional[bool] = None,
                 disable_endpoint_crd: Optional[bool] = None,
                 enable_bpf_masquerade: Optional[bool] = None,
                 enable_encryption: Optional[bool] = None,
                 enable_endpoint_health_checking: Optional[bool] = None,
                 enable_host_reachable_services: Optional[bool] = None,
                 enable_l7_proxy: Optional[bool] = None,
                 enable_node_port: Optional[bool] = None,
                 enable_policy: Optional[str] = None,
                 enable_prometheus_metrics: Optional[bool] = None,
                 enable_service_topology: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 etcd_managed: Optional[bool] = None,
                 hubble: Optional['outputs.ClusterNetworkingCiliumHubble'] = None,
                 identity_allocation_mode: Optional[str] = None,
                 identity_change_grace_period: Optional[str] = None,
                 install_iptables_rules: Optional[bool] = None,
                 ipam: Optional[str] = None,
                 masquerade: Optional[bool] = None,
                 memory_request: Optional[str] = None,
                 metrics: Optional[Sequence[str]] = None,
                 monitor_aggregation: Optional[str] = None,
                 sidecar_istio_proxy_image: Optional[str] = None,
                 to_fqdns_dns_reject_response_code: Optional[str] = None,
                 to_fqdns_enable_poller: Optional[bool] = None,
                 tunnel: Optional[str] = None,
                 version: Optional[str] = None):
        pulumi.set(__self__, "enable_remote_node_identity", enable_remote_node_identity)
        pulumi.set(__self__, "preallocate_bpf_maps", preallocate_bpf_maps)
        if agent_pod_annotations is not None:
            pulumi.set(__self__, "agent_pod_annotations", agent_pod_annotations)
        if agent_prometheus_port is not None:
            pulumi.set(__self__, "agent_prometheus_port", agent_prometheus_port)
        if auto_direct_node_routes is not None:
            pulumi.set(__self__, "auto_direct_node_routes", auto_direct_node_routes)
        if bpf_neigh_global_max is not None:
            pulumi.set(__self__, "bpf_neigh_global_max", bpf_neigh_global_max)
        if bpf_policy_map_max is not None:
            pulumi.set(__self__, "bpf_policy_map_max", bpf_policy_map_max)
        if bpfct_global_any_max is not None:
            pulumi.set(__self__, "bpfct_global_any_max", bpfct_global_any_max)
        if bpfct_global_tcp_max is not None:
            pulumi.set(__self__, "bpfct_global_tcp_max", bpfct_global_tcp_max)
        if bpflb_algorithm is not None:
            pulumi.set(__self__, "bpflb_algorithm", bpflb_algorithm)
        if bpflb_maglev_table_size is not None:
            pulumi.set(__self__, "bpflb_maglev_table_size", bpflb_maglev_table_size)
        if bpflb_map_max is not None:
            pulumi.set(__self__, "bpflb_map_max", bpflb_map_max)
        if bpflb_sock_host_ns_only is not None:
            pulumi.set(__self__, "bpflb_sock_host_ns_only", bpflb_sock_host_ns_only)
        if bpfnat_global_max is not None:
            pulumi.set(__self__, "bpfnat_global_max", bpfnat_global_max)
        if chaining_mode is not None:
            pulumi.set(__self__, "chaining_mode", chaining_mode)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if disable_cnp_status_updates is not None:
            pulumi.set(__self__, "disable_cnp_status_updates", disable_cnp_status_updates)
        if disable_endpoint_crd is not None:
            pulumi.set(__self__, "disable_endpoint_crd", disable_endpoint_crd)
        if enable_bpf_masquerade is not None:
            pulumi.set(__self__, "enable_bpf_masquerade", enable_bpf_masquerade)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if enable_endpoint_health_checking is not None:
            pulumi.set(__self__, "enable_endpoint_health_checking", enable_endpoint_health_checking)
        if enable_host_reachable_services is not None:
            pulumi.set(__self__, "enable_host_reachable_services", enable_host_reachable_services)
        if enable_l7_proxy is not None:
            pulumi.set(__self__, "enable_l7_proxy", enable_l7_proxy)
        if enable_node_port is not None:
            pulumi.set(__self__, "enable_node_port", enable_node_port)
        if enable_policy is not None:
            pulumi.set(__self__, "enable_policy", enable_policy)
        if enable_prometheus_metrics is not None:
            pulumi.set(__self__, "enable_prometheus_metrics", enable_prometheus_metrics)
        if enable_service_topology is not None:
            pulumi.set(__self__, "enable_service_topology", enable_service_topology)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if etcd_managed is not None:
            pulumi.set(__self__, "etcd_managed", etcd_managed)
        if hubble is not None:
            pulumi.set(__self__, "hubble", hubble)
        if identity_allocation_mode is not None:
            pulumi.set(__self__, "identity_allocation_mode", identity_allocation_mode)
        if identity_change_grace_period is not None:
            pulumi.set(__self__, "identity_change_grace_period", identity_change_grace_period)
        if install_iptables_rules is not None:
            pulumi.set(__self__, "install_iptables_rules", install_iptables_rules)
        if ipam is not None:
            pulumi.set(__self__, "ipam", ipam)
        if masquerade is not None:
            pulumi.set(__self__, "masquerade", masquerade)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if monitor_aggregation is not None:
            pulumi.set(__self__, "monitor_aggregation", monitor_aggregation)
        if sidecar_istio_proxy_image is not None:
            pulumi.set(__self__, "sidecar_istio_proxy_image", sidecar_istio_proxy_image)
        if to_fqdns_dns_reject_response_code is not None:
            pulumi.set(__self__, "to_fqdns_dns_reject_response_code", to_fqdns_dns_reject_response_code)
        if to_fqdns_enable_poller is not None:
            pulumi.set(__self__, "to_fqdns_enable_poller", to_fqdns_enable_poller)
        if tunnel is not None:
            pulumi.set(__self__, "tunnel", tunnel)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="enableRemoteNodeIdentity")
    def enable_remote_node_identity(self) -> bool:
        return pulumi.get(self, "enable_remote_node_identity")

    @property
    @pulumi.getter(name="preallocateBpfMaps")
    def preallocate_bpf_maps(self) -> bool:
        return pulumi.get(self, "preallocate_bpf_maps")

    @property
    @pulumi.getter(name="agentPodAnnotations")
    def agent_pod_annotations(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "agent_pod_annotations")

    @property
    @pulumi.getter(name="agentPrometheusPort")
    def agent_prometheus_port(self) -> Optional[int]:
        return pulumi.get(self, "agent_prometheus_port")

    @property
    @pulumi.getter(name="autoDirectNodeRoutes")
    def auto_direct_node_routes(self) -> Optional[bool]:
        return pulumi.get(self, "auto_direct_node_routes")

    @property
    @pulumi.getter(name="bpfNeighGlobalMax")
    def bpf_neigh_global_max(self) -> Optional[int]:
        return pulumi.get(self, "bpf_neigh_global_max")

    @property
    @pulumi.getter(name="bpfPolicyMapMax")
    def bpf_policy_map_max(self) -> Optional[int]:
        return pulumi.get(self, "bpf_policy_map_max")

    @property
    @pulumi.getter(name="bpfctGlobalAnyMax")
    def bpfct_global_any_max(self) -> Optional[int]:
        return pulumi.get(self, "bpfct_global_any_max")

    @property
    @pulumi.getter(name="bpfctGlobalTcpMax")
    def bpfct_global_tcp_max(self) -> Optional[int]:
        return pulumi.get(self, "bpfct_global_tcp_max")

    @property
    @pulumi.getter(name="bpflbAlgorithm")
    def bpflb_algorithm(self) -> Optional[str]:
        return pulumi.get(self, "bpflb_algorithm")

    @property
    @pulumi.getter(name="bpflbMaglevTableSize")
    def bpflb_maglev_table_size(self) -> Optional[str]:
        return pulumi.get(self, "bpflb_maglev_table_size")

    @property
    @pulumi.getter(name="bpflbMapMax")
    def bpflb_map_max(self) -> Optional[int]:
        return pulumi.get(self, "bpflb_map_max")

    @property
    @pulumi.getter(name="bpflbSockHostNsOnly")
    def bpflb_sock_host_ns_only(self) -> Optional[bool]:
        return pulumi.get(self, "bpflb_sock_host_ns_only")

    @property
    @pulumi.getter(name="bpfnatGlobalMax")
    def bpfnat_global_max(self) -> Optional[int]:
        return pulumi.get(self, "bpfnat_global_max")

    @property
    @pulumi.getter(name="chainingMode")
    def chaining_mode(self) -> Optional[str]:
        return pulumi.get(self, "chaining_mode")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[str]:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter
    def debug(self) -> Optional[bool]:
        return pulumi.get(self, "debug")

    @property
    @pulumi.getter(name="disableCnpStatusUpdates")
    def disable_cnp_status_updates(self) -> Optional[bool]:
        return pulumi.get(self, "disable_cnp_status_updates")

    @property
    @pulumi.getter(name="disableEndpointCrd")
    def disable_endpoint_crd(self) -> Optional[bool]:
        return pulumi.get(self, "disable_endpoint_crd")

    @property
    @pulumi.getter(name="enableBpfMasquerade")
    def enable_bpf_masquerade(self) -> Optional[bool]:
        return pulumi.get(self, "enable_bpf_masquerade")

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @property
    @pulumi.getter(name="enableEndpointHealthChecking")
    def enable_endpoint_health_checking(self) -> Optional[bool]:
        return pulumi.get(self, "enable_endpoint_health_checking")

    @property
    @pulumi.getter(name="enableHostReachableServices")
    def enable_host_reachable_services(self) -> Optional[bool]:
        return pulumi.get(self, "enable_host_reachable_services")

    @property
    @pulumi.getter(name="enableL7Proxy")
    def enable_l7_proxy(self) -> Optional[bool]:
        return pulumi.get(self, "enable_l7_proxy")

    @property
    @pulumi.getter(name="enableNodePort")
    def enable_node_port(self) -> Optional[bool]:
        return pulumi.get(self, "enable_node_port")

    @property
    @pulumi.getter(name="enablePolicy")
    def enable_policy(self) -> Optional[str]:
        return pulumi.get(self, "enable_policy")

    @property
    @pulumi.getter(name="enablePrometheusMetrics")
    def enable_prometheus_metrics(self) -> Optional[bool]:
        return pulumi.get(self, "enable_prometheus_metrics")

    @property
    @pulumi.getter(name="enableServiceTopology")
    def enable_service_topology(self) -> Optional[bool]:
        return pulumi.get(self, "enable_service_topology")

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter(name="etcdManaged")
    def etcd_managed(self) -> Optional[bool]:
        return pulumi.get(self, "etcd_managed")

    @property
    @pulumi.getter
    def hubble(self) -> Optional['outputs.ClusterNetworkingCiliumHubble']:
        return pulumi.get(self, "hubble")

    @property
    @pulumi.getter(name="identityAllocationMode")
    def identity_allocation_mode(self) -> Optional[str]:
        return pulumi.get(self, "identity_allocation_mode")

    @property
    @pulumi.getter(name="identityChangeGracePeriod")
    def identity_change_grace_period(self) -> Optional[str]:
        return pulumi.get(self, "identity_change_grace_period")

    @property
    @pulumi.getter(name="installIptablesRules")
    def install_iptables_rules(self) -> Optional[bool]:
        return pulumi.get(self, "install_iptables_rules")

    @property
    @pulumi.getter
    def ipam(self) -> Optional[str]:
        return pulumi.get(self, "ipam")

    @property
    @pulumi.getter
    def masquerade(self) -> Optional[bool]:
        return pulumi.get(self, "masquerade")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[str]:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter(name="monitorAggregation")
    def monitor_aggregation(self) -> Optional[str]:
        return pulumi.get(self, "monitor_aggregation")

    @property
    @pulumi.getter(name="sidecarIstioProxyImage")
    def sidecar_istio_proxy_image(self) -> Optional[str]:
        return pulumi.get(self, "sidecar_istio_proxy_image")

    @property
    @pulumi.getter(name="toFqdnsDnsRejectResponseCode")
    def to_fqdns_dns_reject_response_code(self) -> Optional[str]:
        return pulumi.get(self, "to_fqdns_dns_reject_response_code")

    @property
    @pulumi.getter(name="toFqdnsEnablePoller")
    def to_fqdns_enable_poller(self) -> Optional[bool]:
        return pulumi.get(self, "to_fqdns_enable_poller")

    @property
    @pulumi.getter
    def tunnel(self) -> Optional[str]:
        return pulumi.get(self, "tunnel")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterNetworkingCiliumHubble(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 metrics: Optional[Sequence[str]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "metrics")


@pulumi.output_type
class ClusterNetworkingClassic(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClusterNetworkingCni(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usesSecondaryIp":
            suggest = "uses_secondary_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNetworkingCni. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNetworkingCni.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNetworkingCni.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uses_secondary_ip: Optional[bool] = None):
        if uses_secondary_ip is not None:
            pulumi.set(__self__, "uses_secondary_ip", uses_secondary_ip)

    @property
    @pulumi.getter(name="usesSecondaryIp")
    def uses_secondary_ip(self) -> Optional[bool]:
        return pulumi.get(self, "uses_secondary_ip")


@pulumi.output_type
class ClusterNetworkingExternal(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClusterNetworkingFlannel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iptablesResyncSeconds":
            suggest = "iptables_resync_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNetworkingFlannel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNetworkingFlannel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNetworkingFlannel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend: Optional[str] = None,
                 iptables_resync_seconds: Optional[int] = None):
        if backend is not None:
            pulumi.set(__self__, "backend", backend)
        if iptables_resync_seconds is not None:
            pulumi.set(__self__, "iptables_resync_seconds", iptables_resync_seconds)

    @property
    @pulumi.getter
    def backend(self) -> Optional[str]:
        return pulumi.get(self, "backend")

    @property
    @pulumi.getter(name="iptablesResyncSeconds")
    def iptables_resync_seconds(self) -> Optional[int]:
        return pulumi.get(self, "iptables_resync_seconds")


@pulumi.output_type
class ClusterNetworkingGce(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClusterNetworkingKopeio(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClusterNetworkingKubenet(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClusterNetworkingKuberouter(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ClusterNetworkingLyftVpc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetTags":
            suggest = "subnet_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNetworkingLyftVpc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNetworkingLyftVpc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNetworkingLyftVpc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_tags: Optional[Mapping[str, str]] = None):
        if subnet_tags is not None:
            pulumi.set(__self__, "subnet_tags", subnet_tags)

    @property
    @pulumi.getter(name="subnetTags")
    def subnet_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "subnet_tags")


@pulumi.output_type
class ClusterNetworkingRomana(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daemonServiceIp":
            suggest = "daemon_service_ip"
        elif key == "etcdServiceIp":
            suggest = "etcd_service_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNetworkingRomana. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNetworkingRomana.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNetworkingRomana.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 daemon_service_ip: Optional[str] = None,
                 etcd_service_ip: Optional[str] = None):
        if daemon_service_ip is not None:
            pulumi.set(__self__, "daemon_service_ip", daemon_service_ip)
        if etcd_service_ip is not None:
            pulumi.set(__self__, "etcd_service_ip", etcd_service_ip)

    @property
    @pulumi.getter(name="daemonServiceIp")
    def daemon_service_ip(self) -> Optional[str]:
        return pulumi.get(self, "daemon_service_ip")

    @property
    @pulumi.getter(name="etcdServiceIp")
    def etcd_service_ip(self) -> Optional[str]:
        return pulumi.get(self, "etcd_service_ip")


@pulumi.output_type
class ClusterNetworkingWeave(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connLimit":
            suggest = "conn_limit"
        elif key == "cpuLimit":
            suggest = "cpu_limit"
        elif key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "memoryLimit":
            suggest = "memory_limit"
        elif key == "memoryRequest":
            suggest = "memory_request"
        elif key == "netExtraArgs":
            suggest = "net_extra_args"
        elif key == "noMasqLocal":
            suggest = "no_masq_local"
        elif key == "npcCpuLimit":
            suggest = "npc_cpu_limit"
        elif key == "npcCpuRequest":
            suggest = "npc_cpu_request"
        elif key == "npcExtraArgs":
            suggest = "npc_extra_args"
        elif key == "npcMemoryLimit":
            suggest = "npc_memory_limit"
        elif key == "npcMemoryRequest":
            suggest = "npc_memory_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNetworkingWeave. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNetworkingWeave.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNetworkingWeave.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conn_limit: Optional[int] = None,
                 cpu_limit: Optional[str] = None,
                 cpu_request: Optional[str] = None,
                 memory_limit: Optional[str] = None,
                 memory_request: Optional[str] = None,
                 mtu: Optional[int] = None,
                 net_extra_args: Optional[str] = None,
                 no_masq_local: Optional[int] = None,
                 npc_cpu_limit: Optional[str] = None,
                 npc_cpu_request: Optional[str] = None,
                 npc_extra_args: Optional[str] = None,
                 npc_memory_limit: Optional[str] = None,
                 npc_memory_request: Optional[str] = None,
                 version: Optional[str] = None):
        if conn_limit is not None:
            pulumi.set(__self__, "conn_limit", conn_limit)
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if net_extra_args is not None:
            pulumi.set(__self__, "net_extra_args", net_extra_args)
        if no_masq_local is not None:
            pulumi.set(__self__, "no_masq_local", no_masq_local)
        if npc_cpu_limit is not None:
            pulumi.set(__self__, "npc_cpu_limit", npc_cpu_limit)
        if npc_cpu_request is not None:
            pulumi.set(__self__, "npc_cpu_request", npc_cpu_request)
        if npc_extra_args is not None:
            pulumi.set(__self__, "npc_extra_args", npc_extra_args)
        if npc_memory_limit is not None:
            pulumi.set(__self__, "npc_memory_limit", npc_memory_limit)
        if npc_memory_request is not None:
            pulumi.set(__self__, "npc_memory_request", npc_memory_request)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="connLimit")
    def conn_limit(self) -> Optional[int]:
        return pulumi.get(self, "conn_limit")

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[str]:
        return pulumi.get(self, "cpu_limit")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[str]:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[str]:
        return pulumi.get(self, "memory_limit")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[str]:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter(name="netExtraArgs")
    def net_extra_args(self) -> Optional[str]:
        return pulumi.get(self, "net_extra_args")

    @property
    @pulumi.getter(name="noMasqLocal")
    def no_masq_local(self) -> Optional[int]:
        return pulumi.get(self, "no_masq_local")

    @property
    @pulumi.getter(name="npcCpuLimit")
    def npc_cpu_limit(self) -> Optional[str]:
        return pulumi.get(self, "npc_cpu_limit")

    @property
    @pulumi.getter(name="npcCpuRequest")
    def npc_cpu_request(self) -> Optional[str]:
        return pulumi.get(self, "npc_cpu_request")

    @property
    @pulumi.getter(name="npcExtraArgs")
    def npc_extra_args(self) -> Optional[str]:
        return pulumi.get(self, "npc_extra_args")

    @property
    @pulumi.getter(name="npcMemoryLimit")
    def npc_memory_limit(self) -> Optional[str]:
        return pulumi.get(self, "npc_memory_limit")

    @property
    @pulumi.getter(name="npcMemoryRequest")
    def npc_memory_request(self) -> Optional[str]:
        return pulumi.get(self, "npc_memory_request")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterNodeAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeAuthorizer":
            suggest = "node_authorizer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_authorizer: Optional['outputs.ClusterNodeAuthorizationNodeAuthorizer'] = None):
        if node_authorizer is not None:
            pulumi.set(__self__, "node_authorizer", node_authorizer)

    @property
    @pulumi.getter(name="nodeAuthorizer")
    def node_authorizer(self) -> Optional['outputs.ClusterNodeAuthorizationNodeAuthorizer']:
        return pulumi.get(self, "node_authorizer")


@pulumi.output_type
class ClusterNodeAuthorizationNodeAuthorizer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeUrl":
            suggest = "node_url"
        elif key == "tokenTtl":
            suggest = "token_ttl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeAuthorizationNodeAuthorizer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeAuthorizationNodeAuthorizer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeAuthorizationNodeAuthorizer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorizer: Optional[str] = None,
                 features: Optional[Sequence[str]] = None,
                 image: Optional[str] = None,
                 interval: Optional[str] = None,
                 node_url: Optional[str] = None,
                 port: Optional[int] = None,
                 timeout: Optional[str] = None,
                 token_ttl: Optional[str] = None):
        if authorizer is not None:
            pulumi.set(__self__, "authorizer", authorizer)
        if features is not None:
            pulumi.set(__self__, "features", features)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if node_url is not None:
            pulumi.set(__self__, "node_url", node_url)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if token_ttl is not None:
            pulumi.set(__self__, "token_ttl", token_ttl)

    @property
    @pulumi.getter
    def authorizer(self) -> Optional[str]:
        return pulumi.get(self, "authorizer")

    @property
    @pulumi.getter
    def features(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "features")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="nodeUrl")
    def node_url(self) -> Optional[str]:
        return pulumi.get(self, "node_url")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tokenTtl")
    def token_ttl(self) -> Optional[str]:
        return pulumi.get(self, "token_ttl")


@pulumi.output_type
class ClusterNodeProblemDetector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuLimit":
            suggest = "cpu_limit"
        elif key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "memoryLimit":
            suggest = "memory_limit"
        elif key == "memoryRequest":
            suggest = "memory_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeProblemDetector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeProblemDetector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeProblemDetector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_limit: Optional[str] = None,
                 cpu_request: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 image: Optional[str] = None,
                 memory_limit: Optional[str] = None,
                 memory_request: Optional[str] = None):
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[str]:
        return pulumi.get(self, "cpu_limit")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[str]:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[str]:
        return pulumi.get(self, "memory_limit")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[str]:
        return pulumi.get(self, "memory_request")


@pulumi.output_type
class ClusterNodeTerminationHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableSpotInterruptionDraining":
            suggest = "enable_spot_interruption_draining"
        elif key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "enablePrometheusMetrics":
            suggest = "enable_prometheus_metrics"
        elif key == "enableRebalanceDraining":
            suggest = "enable_rebalance_draining"
        elif key == "enableRebalanceMonitoring":
            suggest = "enable_rebalance_monitoring"
        elif key == "enableScheduledEventDraining":
            suggest = "enable_scheduled_event_draining"
        elif key == "enableSqsTerminationDraining":
            suggest = "enable_sqs_termination_draining"
        elif key == "excludeFromLoadBalancers":
            suggest = "exclude_from_load_balancers"
        elif key == "managedAsgTag":
            suggest = "managed_asg_tag"
        elif key == "memoryRequest":
            suggest = "memory_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeTerminationHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeTerminationHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeTerminationHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_spot_interruption_draining: bool,
                 enabled: bool,
                 cpu_request: Optional[str] = None,
                 enable_prometheus_metrics: Optional[bool] = None,
                 enable_rebalance_draining: Optional[bool] = None,
                 enable_rebalance_monitoring: Optional[bool] = None,
                 enable_scheduled_event_draining: Optional[bool] = None,
                 enable_sqs_termination_draining: Optional[bool] = None,
                 exclude_from_load_balancers: Optional[bool] = None,
                 managed_asg_tag: Optional[str] = None,
                 memory_request: Optional[str] = None,
                 version: Optional[str] = None):
        pulumi.set(__self__, "enable_spot_interruption_draining", enable_spot_interruption_draining)
        pulumi.set(__self__, "enabled", enabled)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if enable_prometheus_metrics is not None:
            pulumi.set(__self__, "enable_prometheus_metrics", enable_prometheus_metrics)
        if enable_rebalance_draining is not None:
            pulumi.set(__self__, "enable_rebalance_draining", enable_rebalance_draining)
        if enable_rebalance_monitoring is not None:
            pulumi.set(__self__, "enable_rebalance_monitoring", enable_rebalance_monitoring)
        if enable_scheduled_event_draining is not None:
            pulumi.set(__self__, "enable_scheduled_event_draining", enable_scheduled_event_draining)
        if enable_sqs_termination_draining is not None:
            pulumi.set(__self__, "enable_sqs_termination_draining", enable_sqs_termination_draining)
        if exclude_from_load_balancers is not None:
            pulumi.set(__self__, "exclude_from_load_balancers", exclude_from_load_balancers)
        if managed_asg_tag is not None:
            pulumi.set(__self__, "managed_asg_tag", managed_asg_tag)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="enableSpotInterruptionDraining")
    def enable_spot_interruption_draining(self) -> bool:
        return pulumi.get(self, "enable_spot_interruption_draining")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[str]:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter(name="enablePrometheusMetrics")
    def enable_prometheus_metrics(self) -> Optional[bool]:
        return pulumi.get(self, "enable_prometheus_metrics")

    @property
    @pulumi.getter(name="enableRebalanceDraining")
    def enable_rebalance_draining(self) -> Optional[bool]:
        return pulumi.get(self, "enable_rebalance_draining")

    @property
    @pulumi.getter(name="enableRebalanceMonitoring")
    def enable_rebalance_monitoring(self) -> Optional[bool]:
        return pulumi.get(self, "enable_rebalance_monitoring")

    @property
    @pulumi.getter(name="enableScheduledEventDraining")
    def enable_scheduled_event_draining(self) -> Optional[bool]:
        return pulumi.get(self, "enable_scheduled_event_draining")

    @property
    @pulumi.getter(name="enableSqsTerminationDraining")
    def enable_sqs_termination_draining(self) -> Optional[bool]:
        return pulumi.get(self, "enable_sqs_termination_draining")

    @property
    @pulumi.getter(name="excludeFromLoadBalancers")
    def exclude_from_load_balancers(self) -> Optional[bool]:
        return pulumi.get(self, "exclude_from_load_balancers")

    @property
    @pulumi.getter(name="managedAsgTag")
    def managed_asg_tag(self) -> Optional[str]:
        return pulumi.get(self, "managed_asg_tag")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[str]:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterNtp(dict):
    def __init__(__self__, *,
                 managed: Optional[bool] = None):
        if managed is not None:
            pulumi.set(__self__, "managed", managed)

    @property
    @pulumi.getter
    def managed(self) -> Optional[bool]:
        return pulumi.get(self, "managed")


@pulumi.output_type
class ClusterPodIdentityWebhook(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 replicas: Optional[int] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        return pulumi.get(self, "replicas")


@pulumi.output_type
class ClusterRollingUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainAndTerminate":
            suggest = "drain_and_terminate"
        elif key == "maxSurge":
            suggest = "max_surge"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRollingUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRollingUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRollingUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain_and_terminate: Optional[bool] = None,
                 max_surge: Optional[str] = None,
                 max_unavailable: Optional[str] = None):
        if drain_and_terminate is not None:
            pulumi.set(__self__, "drain_and_terminate", drain_and_terminate)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="drainAndTerminate")
    def drain_and_terminate(self) -> Optional[bool]:
        return pulumi.get(self, "drain_and_terminate")

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[str]:
        return pulumi.get(self, "max_surge")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[str]:
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class ClusterSecrets(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterCaCert":
            suggest = "cluster_ca_cert"
        elif key == "clusterCaKey":
            suggest = "cluster_ca_key"
        elif key == "dockerConfig":
            suggest = "docker_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSecrets. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSecrets.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSecrets.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_ca_cert: Optional[str] = None,
                 cluster_ca_key: Optional[str] = None,
                 docker_config: Optional[str] = None):
        if cluster_ca_cert is not None:
            pulumi.set(__self__, "cluster_ca_cert", cluster_ca_cert)
        if cluster_ca_key is not None:
            pulumi.set(__self__, "cluster_ca_key", cluster_ca_key)
        if docker_config is not None:
            pulumi.set(__self__, "docker_config", docker_config)

    @property
    @pulumi.getter(name="clusterCaCert")
    def cluster_ca_cert(self) -> Optional[str]:
        return pulumi.get(self, "cluster_ca_cert")

    @property
    @pulumi.getter(name="clusterCaKey")
    def cluster_ca_key(self) -> Optional[str]:
        return pulumi.get(self, "cluster_ca_key")

    @property
    @pulumi.getter(name="dockerConfig")
    def docker_config(self) -> Optional[str]:
        return pulumi.get(self, "docker_config")


@pulumi.output_type
class ClusterServiceAccountIssuerDiscovery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalAudiences":
            suggest = "additional_audiences"
        elif key == "discoveryStore":
            suggest = "discovery_store"
        elif key == "enableAwsOidcProvider":
            suggest = "enable_aws_oidc_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServiceAccountIssuerDiscovery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServiceAccountIssuerDiscovery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServiceAccountIssuerDiscovery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_audiences: Optional[Sequence[str]] = None,
                 discovery_store: Optional[str] = None,
                 enable_aws_oidc_provider: Optional[bool] = None):
        if additional_audiences is not None:
            pulumi.set(__self__, "additional_audiences", additional_audiences)
        if discovery_store is not None:
            pulumi.set(__self__, "discovery_store", discovery_store)
        if enable_aws_oidc_provider is not None:
            pulumi.set(__self__, "enable_aws_oidc_provider", enable_aws_oidc_provider)

    @property
    @pulumi.getter(name="additionalAudiences")
    def additional_audiences(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "additional_audiences")

    @property
    @pulumi.getter(name="discoveryStore")
    def discovery_store(self) -> Optional[str]:
        return pulumi.get(self, "discovery_store")

    @property
    @pulumi.getter(name="enableAwsOidcProvider")
    def enable_aws_oidc_provider(self) -> Optional[bool]:
        return pulumi.get(self, "enable_aws_oidc_provider")


@pulumi.output_type
class ClusterSnapshotController(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "installDefaultClass":
            suggest = "install_default_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSnapshotController. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSnapshotController.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSnapshotController.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 install_default_class: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if install_default_class is not None:
            pulumi.set(__self__, "install_default_class", install_default_class)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="installDefaultClass")
    def install_default_class(self) -> Optional[bool]:
        return pulumi.get(self, "install_default_class")


@pulumi.output_type
class ClusterSubnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerId":
            suggest = "provider_id"
        elif key == "additionalRoutes":
            suggest = "additional_routes"
        elif key == "ipv6Cidr":
            suggest = "ipv6_cidr"
        elif key == "publicIp":
            suggest = "public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSubnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSubnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSubnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 provider_id: str,
                 type: str,
                 zone: str,
                 additional_routes: Optional[Sequence['outputs.ClusterSubnetAdditionalRoute']] = None,
                 cidr: Optional[str] = None,
                 egress: Optional[str] = None,
                 ipv6_cidr: Optional[str] = None,
                 public_ip: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str name: - (Force new) - String - Name defines the cluster name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider_id", provider_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)
        if additional_routes is not None:
            pulumi.set(__self__, "additional_routes", additional_routes)
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if ipv6_cidr is not None:
            pulumi.set(__self__, "ipv6_cidr", ipv6_cidr)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - (Force new) - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> str:
        return pulumi.get(self, "provider_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> str:
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter(name="additionalRoutes")
    def additional_routes(self) -> Optional[Sequence['outputs.ClusterSubnetAdditionalRoute']]:
        return pulumi.get(self, "additional_routes")

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def egress(self) -> Optional[str]:
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter(name="ipv6Cidr")
    def ipv6_cidr(self) -> Optional[str]:
        return pulumi.get(self, "ipv6_cidr")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[str]:
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class ClusterSubnetAdditionalRoute(dict):
    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 target: Optional[str] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")


@pulumi.output_type
class ClusterTagSubnets(dict):
    def __init__(__self__, *,
                 value: Optional[bool] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[bool]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterTopology(dict):
    def __init__(__self__, *,
                 dns: 'outputs.ClusterTopologyDns',
                 masters: str,
                 nodes: str,
                 bastion: Optional['outputs.ClusterTopologyBastion'] = None):
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "masters", masters)
        pulumi.set(__self__, "nodes", nodes)
        if bastion is not None:
            pulumi.set(__self__, "bastion", bastion)

    @property
    @pulumi.getter
    def dns(self) -> 'outputs.ClusterTopologyDns':
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def masters(self) -> str:
        return pulumi.get(self, "masters")

    @property
    @pulumi.getter
    def nodes(self) -> str:
        return pulumi.get(self, "nodes")

    @property
    @pulumi.getter
    def bastion(self) -> Optional['outputs.ClusterTopologyBastion']:
        return pulumi.get(self, "bastion")


@pulumi.output_type
class ClusterTopologyBastion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bastionPublicName":
            suggest = "bastion_public_name"
        elif key == "idleTimeoutSeconds":
            suggest = "idle_timeout_seconds"
        elif key == "loadBalancer":
            suggest = "load_balancer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTopologyBastion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTopologyBastion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTopologyBastion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bastion_public_name: str,
                 idle_timeout_seconds: Optional[int] = None,
                 load_balancer: Optional['outputs.ClusterTopologyBastionLoadBalancer'] = None):
        pulumi.set(__self__, "bastion_public_name", bastion_public_name)
        if idle_timeout_seconds is not None:
            pulumi.set(__self__, "idle_timeout_seconds", idle_timeout_seconds)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)

    @property
    @pulumi.getter(name="bastionPublicName")
    def bastion_public_name(self) -> str:
        return pulumi.get(self, "bastion_public_name")

    @property
    @pulumi.getter(name="idleTimeoutSeconds")
    def idle_timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "idle_timeout_seconds")

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional['outputs.ClusterTopologyBastionLoadBalancer']:
        return pulumi.get(self, "load_balancer")


@pulumi.output_type
class ClusterTopologyBastionLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalSecurityGroups":
            suggest = "additional_security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTopologyBastionLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTopologyBastionLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTopologyBastionLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_security_groups: Sequence[str],
                 type: Optional[str] = None):
        pulumi.set(__self__, "additional_security_groups", additional_security_groups)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="additionalSecurityGroups")
    def additional_security_groups(self) -> Sequence[str]:
        return pulumi.get(self, "additional_security_groups")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ClusterTopologyDns(dict):
    def __init__(__self__, *,
                 type: str):
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class ClusterUpdaterApply(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowKopsDowngrade":
            suggest = "allow_kops_downgrade"
        elif key == "lifecycleOverrides":
            suggest = "lifecycle_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterUpdaterApply. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterUpdaterApply.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterUpdaterApply.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_kops_downgrade: Optional[bool] = None,
                 lifecycle_overrides: Optional[Mapping[str, str]] = None,
                 skip: Optional[bool] = None):
        if allow_kops_downgrade is not None:
            pulumi.set(__self__, "allow_kops_downgrade", allow_kops_downgrade)
        if lifecycle_overrides is not None:
            pulumi.set(__self__, "lifecycle_overrides", lifecycle_overrides)
        if skip is not None:
            pulumi.set(__self__, "skip", skip)

    @property
    @pulumi.getter(name="allowKopsDowngrade")
    def allow_kops_downgrade(self) -> Optional[bool]:
        return pulumi.get(self, "allow_kops_downgrade")

    @property
    @pulumi.getter(name="lifecycleOverrides")
    def lifecycle_overrides(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "lifecycle_overrides")

    @property
    @pulumi.getter
    def skip(self) -> Optional[bool]:
        return pulumi.get(self, "skip")


@pulumi.output_type
class ClusterUpdaterRollingUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bastionInterval":
            suggest = "bastion_interval"
        elif key == "cloudOnly":
            suggest = "cloud_only"
        elif key == "failOnDrainError":
            suggest = "fail_on_drain_error"
        elif key == "failOnValidate":
            suggest = "fail_on_validate"
        elif key == "masterInterval":
            suggest = "master_interval"
        elif key == "nodeInterval":
            suggest = "node_interval"
        elif key == "postDrainDelay":
            suggest = "post_drain_delay"
        elif key == "validateCount":
            suggest = "validate_count"
        elif key == "validationTimeout":
            suggest = "validation_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterUpdaterRollingUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterUpdaterRollingUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterUpdaterRollingUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bastion_interval: Optional[str] = None,
                 cloud_only: Optional[bool] = None,
                 fail_on_drain_error: Optional[bool] = None,
                 fail_on_validate: Optional[bool] = None,
                 force: Optional[bool] = None,
                 master_interval: Optional[str] = None,
                 node_interval: Optional[str] = None,
                 post_drain_delay: Optional[str] = None,
                 skip: Optional[bool] = None,
                 validate_count: Optional[int] = None,
                 validation_timeout: Optional[str] = None):
        if bastion_interval is not None:
            pulumi.set(__self__, "bastion_interval", bastion_interval)
        if cloud_only is not None:
            pulumi.set(__self__, "cloud_only", cloud_only)
        if fail_on_drain_error is not None:
            pulumi.set(__self__, "fail_on_drain_error", fail_on_drain_error)
        if fail_on_validate is not None:
            pulumi.set(__self__, "fail_on_validate", fail_on_validate)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if master_interval is not None:
            pulumi.set(__self__, "master_interval", master_interval)
        if node_interval is not None:
            pulumi.set(__self__, "node_interval", node_interval)
        if post_drain_delay is not None:
            pulumi.set(__self__, "post_drain_delay", post_drain_delay)
        if skip is not None:
            pulumi.set(__self__, "skip", skip)
        if validate_count is not None:
            pulumi.set(__self__, "validate_count", validate_count)
        if validation_timeout is not None:
            pulumi.set(__self__, "validation_timeout", validation_timeout)

    @property
    @pulumi.getter(name="bastionInterval")
    def bastion_interval(self) -> Optional[str]:
        return pulumi.get(self, "bastion_interval")

    @property
    @pulumi.getter(name="cloudOnly")
    def cloud_only(self) -> Optional[bool]:
        return pulumi.get(self, "cloud_only")

    @property
    @pulumi.getter(name="failOnDrainError")
    def fail_on_drain_error(self) -> Optional[bool]:
        return pulumi.get(self, "fail_on_drain_error")

    @property
    @pulumi.getter(name="failOnValidate")
    def fail_on_validate(self) -> Optional[bool]:
        return pulumi.get(self, "fail_on_validate")

    @property
    @pulumi.getter
    def force(self) -> Optional[bool]:
        return pulumi.get(self, "force")

    @property
    @pulumi.getter(name="masterInterval")
    def master_interval(self) -> Optional[str]:
        return pulumi.get(self, "master_interval")

    @property
    @pulumi.getter(name="nodeInterval")
    def node_interval(self) -> Optional[str]:
        return pulumi.get(self, "node_interval")

    @property
    @pulumi.getter(name="postDrainDelay")
    def post_drain_delay(self) -> Optional[str]:
        return pulumi.get(self, "post_drain_delay")

    @property
    @pulumi.getter
    def skip(self) -> Optional[bool]:
        return pulumi.get(self, "skip")

    @property
    @pulumi.getter(name="validateCount")
    def validate_count(self) -> Optional[int]:
        return pulumi.get(self, "validate_count")

    @property
    @pulumi.getter(name="validationTimeout")
    def validation_timeout(self) -> Optional[str]:
        return pulumi.get(self, "validation_timeout")


@pulumi.output_type
class ClusterUpdaterValidate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pollInterval":
            suggest = "poll_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterUpdaterValidate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterUpdaterValidate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterUpdaterValidate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 poll_interval: Optional[str] = None,
                 skip: Optional[bool] = None,
                 timeout: Optional[str] = None):
        if poll_interval is not None:
            pulumi.set(__self__, "poll_interval", poll_interval)
        if skip is not None:
            pulumi.set(__self__, "skip", skip)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="pollInterval")
    def poll_interval(self) -> Optional[str]:
        return pulumi.get(self, "poll_interval")

    @property
    @pulumi.getter
    def skip(self) -> Optional[bool]:
        return pulumi.get(self, "skip")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ClusterWarmPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableLifecycleHook":
            suggest = "enable_lifecycle_hook"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterWarmPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterWarmPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterWarmPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_lifecycle_hook: Optional[bool] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None):
        if enable_lifecycle_hook is not None:
            pulumi.set(__self__, "enable_lifecycle_hook", enable_lifecycle_hook)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)

    @property
    @pulumi.getter(name="enableLifecycleHook")
    def enable_lifecycle_hook(self) -> Optional[bool]:
        return pulumi.get(self, "enable_lifecycle_hook")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        return pulumi.get(self, "min_size")


@pulumi.output_type
class InstanceGroupAdditionalUserData(dict):
    def __init__(__self__, *,
                 content: str,
                 name: str,
                 type: str):
        """
        :param str name: - (Force new) - String - Name defines the instance group name.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - (Force new) - String - Name defines the instance group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class InstanceGroupContainerd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configOverride":
            suggest = "config_override"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "nvidiaGpu":
            suggest = "nvidia_gpu"
        elif key == "registryMirrors":
            suggest = "registry_mirrors"
        elif key == "skipInstall":
            suggest = "skip_install"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupContainerd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupContainerd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupContainerd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 config_override: Optional[str] = None,
                 log_level: Optional[str] = None,
                 nvidia_gpu: Optional['outputs.InstanceGroupContainerdNvidiaGpu'] = None,
                 packages: Optional['outputs.InstanceGroupContainerdPackages'] = None,
                 registry_mirrors: Optional[Sequence['outputs.InstanceGroupContainerdRegistryMirror']] = None,
                 root: Optional[str] = None,
                 runc: Optional['outputs.InstanceGroupContainerdRunc'] = None,
                 skip_install: Optional[bool] = None,
                 state: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param 'InstanceGroupContainerdPackagesArgs' packages: - List(String) - Packages specifies additional packages to be installed.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if config_override is not None:
            pulumi.set(__self__, "config_override", config_override)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if nvidia_gpu is not None:
            pulumi.set(__self__, "nvidia_gpu", nvidia_gpu)
        if packages is not None:
            pulumi.set(__self__, "packages", packages)
        if registry_mirrors is not None:
            pulumi.set(__self__, "registry_mirrors", registry_mirrors)
        if root is not None:
            pulumi.set(__self__, "root", root)
        if runc is not None:
            pulumi.set(__self__, "runc", runc)
        if skip_install is not None:
            pulumi.set(__self__, "skip_install", skip_install)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="configOverride")
    def config_override(self) -> Optional[str]:
        return pulumi.get(self, "config_override")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="nvidiaGpu")
    def nvidia_gpu(self) -> Optional['outputs.InstanceGroupContainerdNvidiaGpu']:
        return pulumi.get(self, "nvidia_gpu")

    @property
    @pulumi.getter
    def packages(self) -> Optional['outputs.InstanceGroupContainerdPackages']:
        """
        - List(String) - Packages specifies additional packages to be installed.
        """
        return pulumi.get(self, "packages")

    @property
    @pulumi.getter(name="registryMirrors")
    def registry_mirrors(self) -> Optional[Sequence['outputs.InstanceGroupContainerdRegistryMirror']]:
        return pulumi.get(self, "registry_mirrors")

    @property
    @pulumi.getter
    def root(self) -> Optional[str]:
        return pulumi.get(self, "root")

    @property
    @pulumi.getter
    def runc(self) -> Optional['outputs.InstanceGroupContainerdRunc']:
        return pulumi.get(self, "runc")

    @property
    @pulumi.getter(name="skipInstall")
    def skip_install(self) -> Optional[bool]:
        return pulumi.get(self, "skip_install")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class InstanceGroupContainerdNvidiaGpu(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "driverPackage":
            suggest = "driver_package"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupContainerdNvidiaGpu. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupContainerdNvidiaGpu.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupContainerdNvidiaGpu.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 driver_package: Optional[str] = None,
                 enabled: Optional[bool] = None):
        if driver_package is not None:
            pulumi.set(__self__, "driver_package", driver_package)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="driverPackage")
    def driver_package(self) -> Optional[str]:
        return pulumi.get(self, "driver_package")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class InstanceGroupContainerdPackages(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hashAmd64":
            suggest = "hash_amd64"
        elif key == "hashArm64":
            suggest = "hash_arm64"
        elif key == "urlAmd64":
            suggest = "url_amd64"
        elif key == "urlArm64":
            suggest = "url_arm64"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupContainerdPackages. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupContainerdPackages.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupContainerdPackages.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hash_amd64: Optional[str] = None,
                 hash_arm64: Optional[str] = None,
                 url_amd64: Optional[str] = None,
                 url_arm64: Optional[str] = None):
        if hash_amd64 is not None:
            pulumi.set(__self__, "hash_amd64", hash_amd64)
        if hash_arm64 is not None:
            pulumi.set(__self__, "hash_arm64", hash_arm64)
        if url_amd64 is not None:
            pulumi.set(__self__, "url_amd64", url_amd64)
        if url_arm64 is not None:
            pulumi.set(__self__, "url_arm64", url_arm64)

    @property
    @pulumi.getter(name="hashAmd64")
    def hash_amd64(self) -> Optional[str]:
        return pulumi.get(self, "hash_amd64")

    @property
    @pulumi.getter(name="hashArm64")
    def hash_arm64(self) -> Optional[str]:
        return pulumi.get(self, "hash_arm64")

    @property
    @pulumi.getter(name="urlAmd64")
    def url_amd64(self) -> Optional[str]:
        return pulumi.get(self, "url_amd64")

    @property
    @pulumi.getter(name="urlArm64")
    def url_arm64(self) -> Optional[str]:
        return pulumi.get(self, "url_arm64")


@pulumi.output_type
class InstanceGroupContainerdRegistryMirror(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class InstanceGroupContainerdRunc(dict):
    def __init__(__self__, *,
                 packages: Optional['outputs.InstanceGroupContainerdRuncPackages'] = None,
                 version: Optional[str] = None):
        """
        :param 'InstanceGroupContainerdRuncPackagesArgs' packages: - List(String) - Packages specifies additional packages to be installed.
        """
        if packages is not None:
            pulumi.set(__self__, "packages", packages)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def packages(self) -> Optional['outputs.InstanceGroupContainerdRuncPackages']:
        """
        - List(String) - Packages specifies additional packages to be installed.
        """
        return pulumi.get(self, "packages")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class InstanceGroupContainerdRuncPackages(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hashAmd64":
            suggest = "hash_amd64"
        elif key == "hashArm64":
            suggest = "hash_arm64"
        elif key == "urlAmd64":
            suggest = "url_amd64"
        elif key == "urlArm64":
            suggest = "url_arm64"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupContainerdRuncPackages. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupContainerdRuncPackages.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupContainerdRuncPackages.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hash_amd64: Optional[str] = None,
                 hash_arm64: Optional[str] = None,
                 url_amd64: Optional[str] = None,
                 url_arm64: Optional[str] = None):
        if hash_amd64 is not None:
            pulumi.set(__self__, "hash_amd64", hash_amd64)
        if hash_arm64 is not None:
            pulumi.set(__self__, "hash_arm64", hash_arm64)
        if url_amd64 is not None:
            pulumi.set(__self__, "url_amd64", url_amd64)
        if url_arm64 is not None:
            pulumi.set(__self__, "url_arm64", url_arm64)

    @property
    @pulumi.getter(name="hashAmd64")
    def hash_amd64(self) -> Optional[str]:
        return pulumi.get(self, "hash_amd64")

    @property
    @pulumi.getter(name="hashArm64")
    def hash_arm64(self) -> Optional[str]:
        return pulumi.get(self, "hash_arm64")

    @property
    @pulumi.getter(name="urlAmd64")
    def url_amd64(self) -> Optional[str]:
        return pulumi.get(self, "url_amd64")

    @property
    @pulumi.getter(name="urlArm64")
    def url_arm64(self) -> Optional[str]:
        return pulumi.get(self, "url_arm64")


@pulumi.output_type
class InstanceGroupExternalLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadBalancerName":
            suggest = "load_balancer_name"
        elif key == "targetGroupArn":
            suggest = "target_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupExternalLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupExternalLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupExternalLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load_balancer_name: Optional[str] = None,
                 target_group_arn: Optional[str] = None):
        if load_balancer_name is not None:
            pulumi.set(__self__, "load_balancer_name", load_balancer_name)
        if target_group_arn is not None:
            pulumi.set(__self__, "target_group_arn", target_group_arn)

    @property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> Optional[str]:
        return pulumi.get(self, "load_balancer_name")

    @property
    @pulumi.getter(name="targetGroupArn")
    def target_group_arn(self) -> Optional[str]:
        return pulumi.get(self, "target_group_arn")


@pulumi.output_type
class InstanceGroupFileAsset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isBase64":
            suggest = "is_base64"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupFileAsset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupFileAsset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupFileAsset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: str,
                 name: str,
                 path: str,
                 is_base64: Optional[bool] = None,
                 mode: Optional[str] = None,
                 roles: Optional[Sequence[str]] = None):
        """
        :param str name: - (Force new) - String - Name defines the instance group name.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        if is_base64 is not None:
            pulumi.set(__self__, "is_base64", is_base64)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - (Force new) - String - Name defines the instance group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="isBase64")
    def is_base64(self) -> Optional[bool]:
        return pulumi.get(self, "is_base64")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "roles")


@pulumi.output_type
class InstanceGroupGuestAccelerator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorType":
            suggest = "accelerator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupGuestAccelerator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupGuestAccelerator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupGuestAccelerator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional[int] = None,
                 accelerator_type: Optional[str] = None):
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_type is not None:
            pulumi.set(__self__, "accelerator_type", accelerator_type)

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional[int]:
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorType")
    def accelerator_type(self) -> Optional[str]:
        return pulumi.get(self, "accelerator_type")


@pulumi.output_type
class InstanceGroupHook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "execContainer":
            suggest = "exec_container"
        elif key == "useRawManifest":
            suggest = "use_raw_manifest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupHook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupHook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupHook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 befores: Optional[Sequence[str]] = None,
                 enabled: Optional[bool] = None,
                 exec_container: Optional['outputs.InstanceGroupHookExecContainer'] = None,
                 manifest: Optional[str] = None,
                 requires: Optional[Sequence[str]] = None,
                 roles: Optional[Sequence[str]] = None,
                 use_raw_manifest: Optional[bool] = None):
        """
        :param str name: - (Force new) - String - Name defines the instance group name.
        """
        pulumi.set(__self__, "name", name)
        if befores is not None:
            pulumi.set(__self__, "befores", befores)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exec_container is not None:
            pulumi.set(__self__, "exec_container", exec_container)
        if manifest is not None:
            pulumi.set(__self__, "manifest", manifest)
        if requires is not None:
            pulumi.set(__self__, "requires", requires)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if use_raw_manifest is not None:
            pulumi.set(__self__, "use_raw_manifest", use_raw_manifest)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - (Force new) - String - Name defines the instance group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def befores(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "befores")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="execContainer")
    def exec_container(self) -> Optional['outputs.InstanceGroupHookExecContainer']:
        return pulumi.get(self, "exec_container")

    @property
    @pulumi.getter
    def manifest(self) -> Optional[str]:
        return pulumi.get(self, "manifest")

    @property
    @pulumi.getter
    def requires(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "requires")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter(name="useRawManifest")
    def use_raw_manifest(self) -> Optional[bool]:
        return pulumi.get(self, "use_raw_manifest")


@pulumi.output_type
class InstanceGroupHookExecContainer(dict):
    def __init__(__self__, *,
                 image: str,
                 commands: Optional[Sequence[str]] = None,
                 environment: Optional[Mapping[str, str]] = None):
        """
        :param str image: - (Computed) - String - Image is the instance (ami etc) we should use.
        """
        pulumi.set(__self__, "image", image)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @property
    @pulumi.getter
    def image(self) -> str:
        """
        - (Computed) - String - Image is the instance (ami etc) we should use.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def environment(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "environment")


@pulumi.output_type
class InstanceGroupIam(dict):
    def __init__(__self__, *,
                 profile: str):
        pulumi.set(__self__, "profile", profile)

    @property
    @pulumi.getter
    def profile(self) -> str:
        return pulumi.get(self, "profile")


@pulumi.output_type
class InstanceGroupInstanceMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupInstanceMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupInstanceMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupInstanceMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_put_response_hop_limit: Optional[int] = None,
                 http_tokens: Optional[str] = None):
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[int]:
        return pulumi.get(self, "http_put_response_hop_limit")

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[str]:
        return pulumi.get(self, "http_tokens")


@pulumi.output_type
class InstanceGroupKubelet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPrivileged":
            suggest = "allow_privileged"
        elif key == "allowedUnsafeSysctls":
            suggest = "allowed_unsafe_sysctls"
        elif key == "anonymousAuth":
            suggest = "anonymous_auth"
        elif key == "apiServers":
            suggest = "api_servers"
        elif key == "authenticationTokenWebhook":
            suggest = "authentication_token_webhook"
        elif key == "authenticationTokenWebhookCacheTtl":
            suggest = "authentication_token_webhook_cache_ttl"
        elif key == "authorizationMode":
            suggest = "authorization_mode"
        elif key == "babysitDaemons":
            suggest = "babysit_daemons"
        elif key == "bootstrapKubeconfig":
            suggest = "bootstrap_kubeconfig"
        elif key == "cgroupDriver":
            suggest = "cgroup_driver"
        elif key == "cgroupRoot":
            suggest = "cgroup_root"
        elif key == "clientCaFile":
            suggest = "client_ca_file"
        elif key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "clusterDns":
            suggest = "cluster_dns"
        elif key == "clusterDomain":
            suggest = "cluster_domain"
        elif key == "configureCbr0":
            suggest = "configure_cbr0"
        elif key == "containerLogMaxFiles":
            suggest = "container_log_max_files"
        elif key == "containerLogMaxSize":
            suggest = "container_log_max_size"
        elif key == "cpuCfsQuota":
            suggest = "cpu_cfs_quota"
        elif key == "cpuCfsQuotaPeriod":
            suggest = "cpu_cfs_quota_period"
        elif key == "cpuManagerPolicy":
            suggest = "cpu_manager_policy"
        elif key == "dockerDisableSharedPid":
            suggest = "docker_disable_shared_pid"
        elif key == "enableCadvisorJsonEndpoints":
            suggest = "enable_cadvisor_json_endpoints"
        elif key == "enableCustomMetrics":
            suggest = "enable_custom_metrics"
        elif key == "enableDebuggingHandlers":
            suggest = "enable_debugging_handlers"
        elif key == "enforceNodeAllocatable":
            suggest = "enforce_node_allocatable"
        elif key == "eventBurst":
            suggest = "event_burst"
        elif key == "eventQps":
            suggest = "event_qps"
        elif key == "evictionHard":
            suggest = "eviction_hard"
        elif key == "evictionMaxPodGracePeriod":
            suggest = "eviction_max_pod_grace_period"
        elif key == "evictionMinimumReclaim":
            suggest = "eviction_minimum_reclaim"
        elif key == "evictionPressureTransitionPeriod":
            suggest = "eviction_pressure_transition_period"
        elif key == "evictionSoft":
            suggest = "eviction_soft"
        elif key == "evictionSoftGracePeriod":
            suggest = "eviction_soft_grace_period"
        elif key == "experimentalAllowedUnsafeSysctls":
            suggest = "experimental_allowed_unsafe_sysctls"
        elif key == "failSwapOn":
            suggest = "fail_swap_on"
        elif key == "featureGates":
            suggest = "feature_gates"
        elif key == "hairpinMode":
            suggest = "hairpin_mode"
        elif key == "hostnameOverride":
            suggest = "hostname_override"
        elif key == "housekeepingInterval":
            suggest = "housekeeping_interval"
        elif key == "imageGcHighThresholdPercent":
            suggest = "image_gc_high_threshold_percent"
        elif key == "imageGcLowThresholdPercent":
            suggest = "image_gc_low_threshold_percent"
        elif key == "imagePullProgressDeadline":
            suggest = "image_pull_progress_deadline"
        elif key == "kernelMemcgNotification":
            suggest = "kernel_memcg_notification"
        elif key == "kubeReserved":
            suggest = "kube_reserved"
        elif key == "kubeReservedCgroup":
            suggest = "kube_reserved_cgroup"
        elif key == "kubeconfigPath":
            suggest = "kubeconfig_path"
        elif key == "kubeletCgroups":
            suggest = "kubelet_cgroups"
        elif key == "logFormat":
            suggest = "log_format"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "maxPods":
            suggest = "max_pods"
        elif key == "networkPluginMtu":
            suggest = "network_plugin_mtu"
        elif key == "networkPluginName":
            suggest = "network_plugin_name"
        elif key == "nodeLabels":
            suggest = "node_labels"
        elif key == "nodeStatusUpdateFrequency":
            suggest = "node_status_update_frequency"
        elif key == "nonMasqueradeCidr":
            suggest = "non_masquerade_cidr"
        elif key == "nvidiaGpUs":
            suggest = "nvidia_gp_us"
        elif key == "podCidr":
            suggest = "pod_cidr"
        elif key == "podInfraContainerImage":
            suggest = "pod_infra_container_image"
        elif key == "podManifestPath":
            suggest = "pod_manifest_path"
        elif key == "podPidsLimit":
            suggest = "pod_pids_limit"
        elif key == "protectKernelDefaults":
            suggest = "protect_kernel_defaults"
        elif key == "readOnlyPort":
            suggest = "read_only_port"
        elif key == "reconcileCidr":
            suggest = "reconcile_cidr"
        elif key == "registerNode":
            suggest = "register_node"
        elif key == "registerSchedulable":
            suggest = "register_schedulable"
        elif key == "registryBurst":
            suggest = "registry_burst"
        elif key == "registryPullQps":
            suggest = "registry_pull_qps"
        elif key == "requireKubeconfig":
            suggest = "require_kubeconfig"
        elif key == "resolverConfig":
            suggest = "resolver_config"
        elif key == "rootDir":
            suggest = "root_dir"
        elif key == "rotateCertificates":
            suggest = "rotate_certificates"
        elif key == "runtimeCgroups":
            suggest = "runtime_cgroups"
        elif key == "runtimeRequestTimeout":
            suggest = "runtime_request_timeout"
        elif key == "seccompProfileRoot":
            suggest = "seccomp_profile_root"
        elif key == "serializeImagePulls":
            suggest = "serialize_image_pulls"
        elif key == "shutdownGracePeriod":
            suggest = "shutdown_grace_period"
        elif key == "shutdownGracePeriodCriticalPods":
            suggest = "shutdown_grace_period_critical_pods"
        elif key == "streamingConnectionIdleTimeout":
            suggest = "streaming_connection_idle_timeout"
        elif key == "systemCgroups":
            suggest = "system_cgroups"
        elif key == "systemReserved":
            suggest = "system_reserved"
        elif key == "systemReservedCgroup":
            suggest = "system_reserved_cgroup"
        elif key == "tlsCertFile":
            suggest = "tls_cert_file"
        elif key == "tlsCipherSuites":
            suggest = "tls_cipher_suites"
        elif key == "tlsMinVersion":
            suggest = "tls_min_version"
        elif key == "tlsPrivateKeyFile":
            suggest = "tls_private_key_file"
        elif key == "topologyManagerPolicy":
            suggest = "topology_manager_policy"
        elif key == "volumePluginDirectory":
            suggest = "volume_plugin_directory"
        elif key == "volumeStatsAggPeriod":
            suggest = "volume_stats_agg_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupKubelet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupKubelet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupKubelet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_privileged: Optional[bool] = None,
                 allowed_unsafe_sysctls: Optional[Sequence[str]] = None,
                 anonymous_auth: Optional['outputs.InstanceGroupKubeletAnonymousAuth'] = None,
                 api_servers: Optional[str] = None,
                 authentication_token_webhook: Optional[bool] = None,
                 authentication_token_webhook_cache_ttl: Optional[str] = None,
                 authorization_mode: Optional[str] = None,
                 babysit_daemons: Optional[bool] = None,
                 bootstrap_kubeconfig: Optional[str] = None,
                 cgroup_driver: Optional[str] = None,
                 cgroup_root: Optional[str] = None,
                 client_ca_file: Optional[str] = None,
                 cloud_provider: Optional[str] = None,
                 cluster_dns: Optional[str] = None,
                 cluster_domain: Optional[str] = None,
                 configure_cbr0: Optional[bool] = None,
                 container_log_max_files: Optional[int] = None,
                 container_log_max_size: Optional[str] = None,
                 cpu_cfs_quota: Optional['outputs.InstanceGroupKubeletCpuCfsQuota'] = None,
                 cpu_cfs_quota_period: Optional[str] = None,
                 cpu_manager_policy: Optional[str] = None,
                 docker_disable_shared_pid: Optional[bool] = None,
                 enable_cadvisor_json_endpoints: Optional[bool] = None,
                 enable_custom_metrics: Optional[bool] = None,
                 enable_debugging_handlers: Optional[bool] = None,
                 enforce_node_allocatable: Optional[str] = None,
                 event_burst: Optional[int] = None,
                 event_qps: Optional[int] = None,
                 eviction_hard: Optional[str] = None,
                 eviction_max_pod_grace_period: Optional[int] = None,
                 eviction_minimum_reclaim: Optional[str] = None,
                 eviction_pressure_transition_period: Optional[str] = None,
                 eviction_soft: Optional[str] = None,
                 eviction_soft_grace_period: Optional[str] = None,
                 experimental_allowed_unsafe_sysctls: Optional[Sequence[str]] = None,
                 fail_swap_on: Optional[bool] = None,
                 feature_gates: Optional[Mapping[str, str]] = None,
                 hairpin_mode: Optional[str] = None,
                 hostname_override: Optional[str] = None,
                 housekeeping_interval: Optional[str] = None,
                 image_gc_high_threshold_percent: Optional[int] = None,
                 image_gc_low_threshold_percent: Optional[int] = None,
                 image_pull_progress_deadline: Optional[str] = None,
                 kernel_memcg_notification: Optional[bool] = None,
                 kube_reserved: Optional[Mapping[str, str]] = None,
                 kube_reserved_cgroup: Optional[str] = None,
                 kubeconfig_path: Optional[str] = None,
                 kubelet_cgroups: Optional[str] = None,
                 log_format: Optional[str] = None,
                 log_level: Optional[int] = None,
                 max_pods: Optional[int] = None,
                 network_plugin_mtu: Optional[int] = None,
                 network_plugin_name: Optional[str] = None,
                 node_labels: Optional[Mapping[str, str]] = None,
                 node_status_update_frequency: Optional[str] = None,
                 non_masquerade_cidr: Optional[str] = None,
                 nvidia_gp_us: Optional[int] = None,
                 pod_cidr: Optional[str] = None,
                 pod_infra_container_image: Optional[str] = None,
                 pod_manifest_path: Optional[str] = None,
                 pod_pids_limit: Optional[int] = None,
                 protect_kernel_defaults: Optional[bool] = None,
                 read_only_port: Optional[int] = None,
                 reconcile_cidr: Optional[bool] = None,
                 register_node: Optional[bool] = None,
                 register_schedulable: Optional[bool] = None,
                 registry_burst: Optional[int] = None,
                 registry_pull_qps: Optional[int] = None,
                 require_kubeconfig: Optional[bool] = None,
                 resolver_config: Optional[str] = None,
                 root_dir: Optional[str] = None,
                 rotate_certificates: Optional[bool] = None,
                 runtime_cgroups: Optional[str] = None,
                 runtime_request_timeout: Optional[str] = None,
                 seccomp_profile_root: Optional[str] = None,
                 serialize_image_pulls: Optional[bool] = None,
                 shutdown_grace_period: Optional[str] = None,
                 shutdown_grace_period_critical_pods: Optional[str] = None,
                 streaming_connection_idle_timeout: Optional[str] = None,
                 system_cgroups: Optional[str] = None,
                 system_reserved: Optional[Mapping[str, str]] = None,
                 system_reserved_cgroup: Optional[str] = None,
                 taints: Optional[Sequence[str]] = None,
                 tls_cert_file: Optional[str] = None,
                 tls_cipher_suites: Optional[Sequence[str]] = None,
                 tls_min_version: Optional[str] = None,
                 tls_private_key_file: Optional[str] = None,
                 topology_manager_policy: Optional[str] = None,
                 volume_plugin_directory: Optional[str] = None,
                 volume_stats_agg_period: Optional[str] = None):
        """
        :param Mapping[str, str] node_labels: - Map(String) - NodeLabels indicates the kubernetes labels for nodes in this instance group.
        :param Sequence[str] taints: - List(String) - Taints indicates the kubernetes taints for nodes in this instance group.
        """
        if allow_privileged is not None:
            pulumi.set(__self__, "allow_privileged", allow_privileged)
        if allowed_unsafe_sysctls is not None:
            pulumi.set(__self__, "allowed_unsafe_sysctls", allowed_unsafe_sysctls)
        if anonymous_auth is not None:
            pulumi.set(__self__, "anonymous_auth", anonymous_auth)
        if api_servers is not None:
            pulumi.set(__self__, "api_servers", api_servers)
        if authentication_token_webhook is not None:
            pulumi.set(__self__, "authentication_token_webhook", authentication_token_webhook)
        if authentication_token_webhook_cache_ttl is not None:
            pulumi.set(__self__, "authentication_token_webhook_cache_ttl", authentication_token_webhook_cache_ttl)
        if authorization_mode is not None:
            pulumi.set(__self__, "authorization_mode", authorization_mode)
        if babysit_daemons is not None:
            pulumi.set(__self__, "babysit_daemons", babysit_daemons)
        if bootstrap_kubeconfig is not None:
            pulumi.set(__self__, "bootstrap_kubeconfig", bootstrap_kubeconfig)
        if cgroup_driver is not None:
            pulumi.set(__self__, "cgroup_driver", cgroup_driver)
        if cgroup_root is not None:
            pulumi.set(__self__, "cgroup_root", cgroup_root)
        if client_ca_file is not None:
            pulumi.set(__self__, "client_ca_file", client_ca_file)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if cluster_dns is not None:
            pulumi.set(__self__, "cluster_dns", cluster_dns)
        if cluster_domain is not None:
            pulumi.set(__self__, "cluster_domain", cluster_domain)
        if configure_cbr0 is not None:
            pulumi.set(__self__, "configure_cbr0", configure_cbr0)
        if container_log_max_files is not None:
            pulumi.set(__self__, "container_log_max_files", container_log_max_files)
        if container_log_max_size is not None:
            pulumi.set(__self__, "container_log_max_size", container_log_max_size)
        if cpu_cfs_quota is not None:
            pulumi.set(__self__, "cpu_cfs_quota", cpu_cfs_quota)
        if cpu_cfs_quota_period is not None:
            pulumi.set(__self__, "cpu_cfs_quota_period", cpu_cfs_quota_period)
        if cpu_manager_policy is not None:
            pulumi.set(__self__, "cpu_manager_policy", cpu_manager_policy)
        if docker_disable_shared_pid is not None:
            pulumi.set(__self__, "docker_disable_shared_pid", docker_disable_shared_pid)
        if enable_cadvisor_json_endpoints is not None:
            pulumi.set(__self__, "enable_cadvisor_json_endpoints", enable_cadvisor_json_endpoints)
        if enable_custom_metrics is not None:
            pulumi.set(__self__, "enable_custom_metrics", enable_custom_metrics)
        if enable_debugging_handlers is not None:
            pulumi.set(__self__, "enable_debugging_handlers", enable_debugging_handlers)
        if enforce_node_allocatable is not None:
            pulumi.set(__self__, "enforce_node_allocatable", enforce_node_allocatable)
        if event_burst is not None:
            pulumi.set(__self__, "event_burst", event_burst)
        if event_qps is not None:
            pulumi.set(__self__, "event_qps", event_qps)
        if eviction_hard is not None:
            pulumi.set(__self__, "eviction_hard", eviction_hard)
        if eviction_max_pod_grace_period is not None:
            pulumi.set(__self__, "eviction_max_pod_grace_period", eviction_max_pod_grace_period)
        if eviction_minimum_reclaim is not None:
            pulumi.set(__self__, "eviction_minimum_reclaim", eviction_minimum_reclaim)
        if eviction_pressure_transition_period is not None:
            pulumi.set(__self__, "eviction_pressure_transition_period", eviction_pressure_transition_period)
        if eviction_soft is not None:
            pulumi.set(__self__, "eviction_soft", eviction_soft)
        if eviction_soft_grace_period is not None:
            pulumi.set(__self__, "eviction_soft_grace_period", eviction_soft_grace_period)
        if experimental_allowed_unsafe_sysctls is not None:
            pulumi.set(__self__, "experimental_allowed_unsafe_sysctls", experimental_allowed_unsafe_sysctls)
        if fail_swap_on is not None:
            pulumi.set(__self__, "fail_swap_on", fail_swap_on)
        if feature_gates is not None:
            pulumi.set(__self__, "feature_gates", feature_gates)
        if hairpin_mode is not None:
            pulumi.set(__self__, "hairpin_mode", hairpin_mode)
        if hostname_override is not None:
            pulumi.set(__self__, "hostname_override", hostname_override)
        if housekeeping_interval is not None:
            pulumi.set(__self__, "housekeeping_interval", housekeeping_interval)
        if image_gc_high_threshold_percent is not None:
            pulumi.set(__self__, "image_gc_high_threshold_percent", image_gc_high_threshold_percent)
        if image_gc_low_threshold_percent is not None:
            pulumi.set(__self__, "image_gc_low_threshold_percent", image_gc_low_threshold_percent)
        if image_pull_progress_deadline is not None:
            pulumi.set(__self__, "image_pull_progress_deadline", image_pull_progress_deadline)
        if kernel_memcg_notification is not None:
            pulumi.set(__self__, "kernel_memcg_notification", kernel_memcg_notification)
        if kube_reserved is not None:
            pulumi.set(__self__, "kube_reserved", kube_reserved)
        if kube_reserved_cgroup is not None:
            pulumi.set(__self__, "kube_reserved_cgroup", kube_reserved_cgroup)
        if kubeconfig_path is not None:
            pulumi.set(__self__, "kubeconfig_path", kubeconfig_path)
        if kubelet_cgroups is not None:
            pulumi.set(__self__, "kubelet_cgroups", kubelet_cgroups)
        if log_format is not None:
            pulumi.set(__self__, "log_format", log_format)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if network_plugin_mtu is not None:
            pulumi.set(__self__, "network_plugin_mtu", network_plugin_mtu)
        if network_plugin_name is not None:
            pulumi.set(__self__, "network_plugin_name", network_plugin_name)
        if node_labels is not None:
            pulumi.set(__self__, "node_labels", node_labels)
        if node_status_update_frequency is not None:
            pulumi.set(__self__, "node_status_update_frequency", node_status_update_frequency)
        if non_masquerade_cidr is not None:
            pulumi.set(__self__, "non_masquerade_cidr", non_masquerade_cidr)
        if nvidia_gp_us is not None:
            pulumi.set(__self__, "nvidia_gp_us", nvidia_gp_us)
        if pod_cidr is not None:
            pulumi.set(__self__, "pod_cidr", pod_cidr)
        if pod_infra_container_image is not None:
            pulumi.set(__self__, "pod_infra_container_image", pod_infra_container_image)
        if pod_manifest_path is not None:
            pulumi.set(__self__, "pod_manifest_path", pod_manifest_path)
        if pod_pids_limit is not None:
            pulumi.set(__self__, "pod_pids_limit", pod_pids_limit)
        if protect_kernel_defaults is not None:
            pulumi.set(__self__, "protect_kernel_defaults", protect_kernel_defaults)
        if read_only_port is not None:
            pulumi.set(__self__, "read_only_port", read_only_port)
        if reconcile_cidr is not None:
            pulumi.set(__self__, "reconcile_cidr", reconcile_cidr)
        if register_node is not None:
            pulumi.set(__self__, "register_node", register_node)
        if register_schedulable is not None:
            pulumi.set(__self__, "register_schedulable", register_schedulable)
        if registry_burst is not None:
            pulumi.set(__self__, "registry_burst", registry_burst)
        if registry_pull_qps is not None:
            pulumi.set(__self__, "registry_pull_qps", registry_pull_qps)
        if require_kubeconfig is not None:
            pulumi.set(__self__, "require_kubeconfig", require_kubeconfig)
        if resolver_config is not None:
            pulumi.set(__self__, "resolver_config", resolver_config)
        if root_dir is not None:
            pulumi.set(__self__, "root_dir", root_dir)
        if rotate_certificates is not None:
            pulumi.set(__self__, "rotate_certificates", rotate_certificates)
        if runtime_cgroups is not None:
            pulumi.set(__self__, "runtime_cgroups", runtime_cgroups)
        if runtime_request_timeout is not None:
            pulumi.set(__self__, "runtime_request_timeout", runtime_request_timeout)
        if seccomp_profile_root is not None:
            pulumi.set(__self__, "seccomp_profile_root", seccomp_profile_root)
        if serialize_image_pulls is not None:
            pulumi.set(__self__, "serialize_image_pulls", serialize_image_pulls)
        if shutdown_grace_period is not None:
            pulumi.set(__self__, "shutdown_grace_period", shutdown_grace_period)
        if shutdown_grace_period_critical_pods is not None:
            pulumi.set(__self__, "shutdown_grace_period_critical_pods", shutdown_grace_period_critical_pods)
        if streaming_connection_idle_timeout is not None:
            pulumi.set(__self__, "streaming_connection_idle_timeout", streaming_connection_idle_timeout)
        if system_cgroups is not None:
            pulumi.set(__self__, "system_cgroups", system_cgroups)
        if system_reserved is not None:
            pulumi.set(__self__, "system_reserved", system_reserved)
        if system_reserved_cgroup is not None:
            pulumi.set(__self__, "system_reserved_cgroup", system_reserved_cgroup)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if tls_cert_file is not None:
            pulumi.set(__self__, "tls_cert_file", tls_cert_file)
        if tls_cipher_suites is not None:
            pulumi.set(__self__, "tls_cipher_suites", tls_cipher_suites)
        if tls_min_version is not None:
            pulumi.set(__self__, "tls_min_version", tls_min_version)
        if tls_private_key_file is not None:
            pulumi.set(__self__, "tls_private_key_file", tls_private_key_file)
        if topology_manager_policy is not None:
            pulumi.set(__self__, "topology_manager_policy", topology_manager_policy)
        if volume_plugin_directory is not None:
            pulumi.set(__self__, "volume_plugin_directory", volume_plugin_directory)
        if volume_stats_agg_period is not None:
            pulumi.set(__self__, "volume_stats_agg_period", volume_stats_agg_period)

    @property
    @pulumi.getter(name="allowPrivileged")
    def allow_privileged(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privileged")

    @property
    @pulumi.getter(name="allowedUnsafeSysctls")
    def allowed_unsafe_sysctls(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_unsafe_sysctls")

    @property
    @pulumi.getter(name="anonymousAuth")
    def anonymous_auth(self) -> Optional['outputs.InstanceGroupKubeletAnonymousAuth']:
        return pulumi.get(self, "anonymous_auth")

    @property
    @pulumi.getter(name="apiServers")
    def api_servers(self) -> Optional[str]:
        return pulumi.get(self, "api_servers")

    @property
    @pulumi.getter(name="authenticationTokenWebhook")
    def authentication_token_webhook(self) -> Optional[bool]:
        return pulumi.get(self, "authentication_token_webhook")

    @property
    @pulumi.getter(name="authenticationTokenWebhookCacheTtl")
    def authentication_token_webhook_cache_ttl(self) -> Optional[str]:
        return pulumi.get(self, "authentication_token_webhook_cache_ttl")

    @property
    @pulumi.getter(name="authorizationMode")
    def authorization_mode(self) -> Optional[str]:
        return pulumi.get(self, "authorization_mode")

    @property
    @pulumi.getter(name="babysitDaemons")
    def babysit_daemons(self) -> Optional[bool]:
        return pulumi.get(self, "babysit_daemons")

    @property
    @pulumi.getter(name="bootstrapKubeconfig")
    def bootstrap_kubeconfig(self) -> Optional[str]:
        return pulumi.get(self, "bootstrap_kubeconfig")

    @property
    @pulumi.getter(name="cgroupDriver")
    def cgroup_driver(self) -> Optional[str]:
        return pulumi.get(self, "cgroup_driver")

    @property
    @pulumi.getter(name="cgroupRoot")
    def cgroup_root(self) -> Optional[str]:
        return pulumi.get(self, "cgroup_root")

    @property
    @pulumi.getter(name="clientCaFile")
    def client_ca_file(self) -> Optional[str]:
        return pulumi.get(self, "client_ca_file")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[str]:
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="clusterDns")
    def cluster_dns(self) -> Optional[str]:
        return pulumi.get(self, "cluster_dns")

    @property
    @pulumi.getter(name="clusterDomain")
    def cluster_domain(self) -> Optional[str]:
        return pulumi.get(self, "cluster_domain")

    @property
    @pulumi.getter(name="configureCbr0")
    def configure_cbr0(self) -> Optional[bool]:
        return pulumi.get(self, "configure_cbr0")

    @property
    @pulumi.getter(name="containerLogMaxFiles")
    def container_log_max_files(self) -> Optional[int]:
        return pulumi.get(self, "container_log_max_files")

    @property
    @pulumi.getter(name="containerLogMaxSize")
    def container_log_max_size(self) -> Optional[str]:
        return pulumi.get(self, "container_log_max_size")

    @property
    @pulumi.getter(name="cpuCfsQuota")
    def cpu_cfs_quota(self) -> Optional['outputs.InstanceGroupKubeletCpuCfsQuota']:
        return pulumi.get(self, "cpu_cfs_quota")

    @property
    @pulumi.getter(name="cpuCfsQuotaPeriod")
    def cpu_cfs_quota_period(self) -> Optional[str]:
        return pulumi.get(self, "cpu_cfs_quota_period")

    @property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> Optional[str]:
        return pulumi.get(self, "cpu_manager_policy")

    @property
    @pulumi.getter(name="dockerDisableSharedPid")
    def docker_disable_shared_pid(self) -> Optional[bool]:
        return pulumi.get(self, "docker_disable_shared_pid")

    @property
    @pulumi.getter(name="enableCadvisorJsonEndpoints")
    def enable_cadvisor_json_endpoints(self) -> Optional[bool]:
        return pulumi.get(self, "enable_cadvisor_json_endpoints")

    @property
    @pulumi.getter(name="enableCustomMetrics")
    def enable_custom_metrics(self) -> Optional[bool]:
        return pulumi.get(self, "enable_custom_metrics")

    @property
    @pulumi.getter(name="enableDebuggingHandlers")
    def enable_debugging_handlers(self) -> Optional[bool]:
        return pulumi.get(self, "enable_debugging_handlers")

    @property
    @pulumi.getter(name="enforceNodeAllocatable")
    def enforce_node_allocatable(self) -> Optional[str]:
        return pulumi.get(self, "enforce_node_allocatable")

    @property
    @pulumi.getter(name="eventBurst")
    def event_burst(self) -> Optional[int]:
        return pulumi.get(self, "event_burst")

    @property
    @pulumi.getter(name="eventQps")
    def event_qps(self) -> Optional[int]:
        return pulumi.get(self, "event_qps")

    @property
    @pulumi.getter(name="evictionHard")
    def eviction_hard(self) -> Optional[str]:
        return pulumi.get(self, "eviction_hard")

    @property
    @pulumi.getter(name="evictionMaxPodGracePeriod")
    def eviction_max_pod_grace_period(self) -> Optional[int]:
        return pulumi.get(self, "eviction_max_pod_grace_period")

    @property
    @pulumi.getter(name="evictionMinimumReclaim")
    def eviction_minimum_reclaim(self) -> Optional[str]:
        return pulumi.get(self, "eviction_minimum_reclaim")

    @property
    @pulumi.getter(name="evictionPressureTransitionPeriod")
    def eviction_pressure_transition_period(self) -> Optional[str]:
        return pulumi.get(self, "eviction_pressure_transition_period")

    @property
    @pulumi.getter(name="evictionSoft")
    def eviction_soft(self) -> Optional[str]:
        return pulumi.get(self, "eviction_soft")

    @property
    @pulumi.getter(name="evictionSoftGracePeriod")
    def eviction_soft_grace_period(self) -> Optional[str]:
        return pulumi.get(self, "eviction_soft_grace_period")

    @property
    @pulumi.getter(name="experimentalAllowedUnsafeSysctls")
    def experimental_allowed_unsafe_sysctls(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "experimental_allowed_unsafe_sysctls")

    @property
    @pulumi.getter(name="failSwapOn")
    def fail_swap_on(self) -> Optional[bool]:
        return pulumi.get(self, "fail_swap_on")

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "feature_gates")

    @property
    @pulumi.getter(name="hairpinMode")
    def hairpin_mode(self) -> Optional[str]:
        return pulumi.get(self, "hairpin_mode")

    @property
    @pulumi.getter(name="hostnameOverride")
    def hostname_override(self) -> Optional[str]:
        return pulumi.get(self, "hostname_override")

    @property
    @pulumi.getter(name="housekeepingInterval")
    def housekeeping_interval(self) -> Optional[str]:
        return pulumi.get(self, "housekeeping_interval")

    @property
    @pulumi.getter(name="imageGcHighThresholdPercent")
    def image_gc_high_threshold_percent(self) -> Optional[int]:
        return pulumi.get(self, "image_gc_high_threshold_percent")

    @property
    @pulumi.getter(name="imageGcLowThresholdPercent")
    def image_gc_low_threshold_percent(self) -> Optional[int]:
        return pulumi.get(self, "image_gc_low_threshold_percent")

    @property
    @pulumi.getter(name="imagePullProgressDeadline")
    def image_pull_progress_deadline(self) -> Optional[str]:
        return pulumi.get(self, "image_pull_progress_deadline")

    @property
    @pulumi.getter(name="kernelMemcgNotification")
    def kernel_memcg_notification(self) -> Optional[bool]:
        return pulumi.get(self, "kernel_memcg_notification")

    @property
    @pulumi.getter(name="kubeReserved")
    def kube_reserved(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "kube_reserved")

    @property
    @pulumi.getter(name="kubeReservedCgroup")
    def kube_reserved_cgroup(self) -> Optional[str]:
        return pulumi.get(self, "kube_reserved_cgroup")

    @property
    @pulumi.getter(name="kubeconfigPath")
    def kubeconfig_path(self) -> Optional[str]:
        return pulumi.get(self, "kubeconfig_path")

    @property
    @pulumi.getter(name="kubeletCgroups")
    def kubelet_cgroups(self) -> Optional[str]:
        return pulumi.get(self, "kubelet_cgroups")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> Optional[str]:
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[int]:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[int]:
        return pulumi.get(self, "max_pods")

    @property
    @pulumi.getter(name="networkPluginMtu")
    def network_plugin_mtu(self) -> Optional[int]:
        return pulumi.get(self, "network_plugin_mtu")

    @property
    @pulumi.getter(name="networkPluginName")
    def network_plugin_name(self) -> Optional[str]:
        return pulumi.get(self, "network_plugin_name")

    @property
    @pulumi.getter(name="nodeLabels")
    def node_labels(self) -> Optional[Mapping[str, str]]:
        """
        - Map(String) - NodeLabels indicates the kubernetes labels for nodes in this instance group.
        """
        return pulumi.get(self, "node_labels")

    @property
    @pulumi.getter(name="nodeStatusUpdateFrequency")
    def node_status_update_frequency(self) -> Optional[str]:
        return pulumi.get(self, "node_status_update_frequency")

    @property
    @pulumi.getter(name="nonMasqueradeCidr")
    def non_masquerade_cidr(self) -> Optional[str]:
        return pulumi.get(self, "non_masquerade_cidr")

    @property
    @pulumi.getter(name="nvidiaGpUs")
    def nvidia_gp_us(self) -> Optional[int]:
        return pulumi.get(self, "nvidia_gp_us")

    @property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> Optional[str]:
        return pulumi.get(self, "pod_cidr")

    @property
    @pulumi.getter(name="podInfraContainerImage")
    def pod_infra_container_image(self) -> Optional[str]:
        return pulumi.get(self, "pod_infra_container_image")

    @property
    @pulumi.getter(name="podManifestPath")
    def pod_manifest_path(self) -> Optional[str]:
        return pulumi.get(self, "pod_manifest_path")

    @property
    @pulumi.getter(name="podPidsLimit")
    def pod_pids_limit(self) -> Optional[int]:
        return pulumi.get(self, "pod_pids_limit")

    @property
    @pulumi.getter(name="protectKernelDefaults")
    def protect_kernel_defaults(self) -> Optional[bool]:
        return pulumi.get(self, "protect_kernel_defaults")

    @property
    @pulumi.getter(name="readOnlyPort")
    def read_only_port(self) -> Optional[int]:
        return pulumi.get(self, "read_only_port")

    @property
    @pulumi.getter(name="reconcileCidr")
    def reconcile_cidr(self) -> Optional[bool]:
        return pulumi.get(self, "reconcile_cidr")

    @property
    @pulumi.getter(name="registerNode")
    def register_node(self) -> Optional[bool]:
        return pulumi.get(self, "register_node")

    @property
    @pulumi.getter(name="registerSchedulable")
    def register_schedulable(self) -> Optional[bool]:
        return pulumi.get(self, "register_schedulable")

    @property
    @pulumi.getter(name="registryBurst")
    def registry_burst(self) -> Optional[int]:
        return pulumi.get(self, "registry_burst")

    @property
    @pulumi.getter(name="registryPullQps")
    def registry_pull_qps(self) -> Optional[int]:
        return pulumi.get(self, "registry_pull_qps")

    @property
    @pulumi.getter(name="requireKubeconfig")
    def require_kubeconfig(self) -> Optional[bool]:
        return pulumi.get(self, "require_kubeconfig")

    @property
    @pulumi.getter(name="resolverConfig")
    def resolver_config(self) -> Optional[str]:
        return pulumi.get(self, "resolver_config")

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> Optional[str]:
        return pulumi.get(self, "root_dir")

    @property
    @pulumi.getter(name="rotateCertificates")
    def rotate_certificates(self) -> Optional[bool]:
        return pulumi.get(self, "rotate_certificates")

    @property
    @pulumi.getter(name="runtimeCgroups")
    def runtime_cgroups(self) -> Optional[str]:
        return pulumi.get(self, "runtime_cgroups")

    @property
    @pulumi.getter(name="runtimeRequestTimeout")
    def runtime_request_timeout(self) -> Optional[str]:
        return pulumi.get(self, "runtime_request_timeout")

    @property
    @pulumi.getter(name="seccompProfileRoot")
    def seccomp_profile_root(self) -> Optional[str]:
        return pulumi.get(self, "seccomp_profile_root")

    @property
    @pulumi.getter(name="serializeImagePulls")
    def serialize_image_pulls(self) -> Optional[bool]:
        return pulumi.get(self, "serialize_image_pulls")

    @property
    @pulumi.getter(name="shutdownGracePeriod")
    def shutdown_grace_period(self) -> Optional[str]:
        return pulumi.get(self, "shutdown_grace_period")

    @property
    @pulumi.getter(name="shutdownGracePeriodCriticalPods")
    def shutdown_grace_period_critical_pods(self) -> Optional[str]:
        return pulumi.get(self, "shutdown_grace_period_critical_pods")

    @property
    @pulumi.getter(name="streamingConnectionIdleTimeout")
    def streaming_connection_idle_timeout(self) -> Optional[str]:
        return pulumi.get(self, "streaming_connection_idle_timeout")

    @property
    @pulumi.getter(name="systemCgroups")
    def system_cgroups(self) -> Optional[str]:
        return pulumi.get(self, "system_cgroups")

    @property
    @pulumi.getter(name="systemReserved")
    def system_reserved(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "system_reserved")

    @property
    @pulumi.getter(name="systemReservedCgroup")
    def system_reserved_cgroup(self) -> Optional[str]:
        return pulumi.get(self, "system_reserved_cgroup")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence[str]]:
        """
        - List(String) - Taints indicates the kubernetes taints for nodes in this instance group.
        """
        return pulumi.get(self, "taints")

    @property
    @pulumi.getter(name="tlsCertFile")
    def tls_cert_file(self) -> Optional[str]:
        return pulumi.get(self, "tls_cert_file")

    @property
    @pulumi.getter(name="tlsCipherSuites")
    def tls_cipher_suites(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tls_cipher_suites")

    @property
    @pulumi.getter(name="tlsMinVersion")
    def tls_min_version(self) -> Optional[str]:
        return pulumi.get(self, "tls_min_version")

    @property
    @pulumi.getter(name="tlsPrivateKeyFile")
    def tls_private_key_file(self) -> Optional[str]:
        return pulumi.get(self, "tls_private_key_file")

    @property
    @pulumi.getter(name="topologyManagerPolicy")
    def topology_manager_policy(self) -> Optional[str]:
        return pulumi.get(self, "topology_manager_policy")

    @property
    @pulumi.getter(name="volumePluginDirectory")
    def volume_plugin_directory(self) -> Optional[str]:
        return pulumi.get(self, "volume_plugin_directory")

    @property
    @pulumi.getter(name="volumeStatsAggPeriod")
    def volume_stats_agg_period(self) -> Optional[str]:
        return pulumi.get(self, "volume_stats_agg_period")


@pulumi.output_type
class InstanceGroupKubeletAnonymousAuth(dict):
    def __init__(__self__, *,
                 value: Optional[bool] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[bool]:
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceGroupKubeletCpuCfsQuota(dict):
    def __init__(__self__, *,
                 value: Optional[bool] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[bool]:
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceGroupMixedInstancesPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "onDemandAboveBase":
            suggest = "on_demand_above_base"
        elif key == "onDemandAllocationStrategy":
            suggest = "on_demand_allocation_strategy"
        elif key == "onDemandBase":
            suggest = "on_demand_base"
        elif key == "spotAllocationStrategy":
            suggest = "spot_allocation_strategy"
        elif key == "spotInstancePools":
            suggest = "spot_instance_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupMixedInstancesPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupMixedInstancesPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupMixedInstancesPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_requirements: Optional['outputs.InstanceGroupMixedInstancesPolicyInstanceRequirements'] = None,
                 instances: Optional[Sequence[str]] = None,
                 on_demand_above_base: Optional['outputs.InstanceGroupMixedInstancesPolicyOnDemandAboveBase'] = None,
                 on_demand_allocation_strategy: Optional[str] = None,
                 on_demand_base: Optional['outputs.InstanceGroupMixedInstancesPolicyOnDemandBase'] = None,
                 spot_allocation_strategy: Optional[str] = None,
                 spot_instance_pools: Optional[int] = None):
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instances is not None:
            pulumi.set(__self__, "instances", instances)
        if on_demand_above_base is not None:
            pulumi.set(__self__, "on_demand_above_base", on_demand_above_base)
        if on_demand_allocation_strategy is not None:
            pulumi.set(__self__, "on_demand_allocation_strategy", on_demand_allocation_strategy)
        if on_demand_base is not None:
            pulumi.set(__self__, "on_demand_base", on_demand_base)
        if spot_allocation_strategy is not None:
            pulumi.set(__self__, "spot_allocation_strategy", spot_allocation_strategy)
        if spot_instance_pools is not None:
            pulumi.set(__self__, "spot_instance_pools", spot_instance_pools)

    @property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.InstanceGroupMixedInstancesPolicyInstanceRequirements']:
        return pulumi.get(self, "instance_requirements")

    @property
    @pulumi.getter
    def instances(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter(name="onDemandAboveBase")
    def on_demand_above_base(self) -> Optional['outputs.InstanceGroupMixedInstancesPolicyOnDemandAboveBase']:
        return pulumi.get(self, "on_demand_above_base")

    @property
    @pulumi.getter(name="onDemandAllocationStrategy")
    def on_demand_allocation_strategy(self) -> Optional[str]:
        return pulumi.get(self, "on_demand_allocation_strategy")

    @property
    @pulumi.getter(name="onDemandBase")
    def on_demand_base(self) -> Optional['outputs.InstanceGroupMixedInstancesPolicyOnDemandBase']:
        return pulumi.get(self, "on_demand_base")

    @property
    @pulumi.getter(name="spotAllocationStrategy")
    def spot_allocation_strategy(self) -> Optional[str]:
        return pulumi.get(self, "spot_allocation_strategy")

    @property
    @pulumi.getter(name="spotInstancePools")
    def spot_instance_pools(self) -> Optional[int]:
        return pulumi.get(self, "spot_instance_pools")


@pulumi.output_type
class InstanceGroupMixedInstancesPolicyInstanceRequirements(dict):
    def __init__(__self__, *,
                 cpu: Optional['outputs.InstanceGroupMixedInstancesPolicyInstanceRequirementsCpu'] = None,
                 memory: Optional['outputs.InstanceGroupMixedInstancesPolicyInstanceRequirementsMemory'] = None):
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional['outputs.InstanceGroupMixedInstancesPolicyInstanceRequirementsCpu']:
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def memory(self) -> Optional['outputs.InstanceGroupMixedInstancesPolicyInstanceRequirementsMemory']:
        return pulumi.get(self, "memory")


@pulumi.output_type
class InstanceGroupMixedInstancesPolicyInstanceRequirementsCpu(dict):
    def __init__(__self__, *,
                 max: Optional[str] = None,
                 min: Optional[str] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        return pulumi.get(self, "min")


@pulumi.output_type
class InstanceGroupMixedInstancesPolicyInstanceRequirementsMemory(dict):
    def __init__(__self__, *,
                 max: Optional[str] = None,
                 min: Optional[str] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        return pulumi.get(self, "min")


@pulumi.output_type
class InstanceGroupMixedInstancesPolicyOnDemandAboveBase(dict):
    def __init__(__self__, *,
                 value: Optional[int] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceGroupMixedInstancesPolicyOnDemandBase(dict):
    def __init__(__self__, *,
                 value: Optional[int] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceGroupRollingUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainAndTerminate":
            suggest = "drain_and_terminate"
        elif key == "maxSurge":
            suggest = "max_surge"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupRollingUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupRollingUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupRollingUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain_and_terminate: Optional[bool] = None,
                 max_surge: Optional[str] = None,
                 max_unavailable: Optional[str] = None):
        if drain_and_terminate is not None:
            pulumi.set(__self__, "drain_and_terminate", drain_and_terminate)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="drainAndTerminate")
    def drain_and_terminate(self) -> Optional[bool]:
        return pulumi.get(self, "drain_and_terminate")

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[str]:
        return pulumi.get(self, "max_surge")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[str]:
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class InstanceGroupVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device: str,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 key: Optional[str] = None,
                 size: Optional[int] = None,
                 throughput: Optional[int] = None,
                 type: Optional[str] = None):
        pulumi.set(__self__, "device", device)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def device(self) -> str:
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class InstanceGroupVolumeMount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatOptions":
            suggest = "format_options"
        elif key == "mountOptions":
            suggest = "mount_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupVolumeMount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupVolumeMount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupVolumeMount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device: str,
                 filesystem: str,
                 path: str,
                 format_options: Optional[Sequence[str]] = None,
                 mount_options: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "filesystem", filesystem)
        pulumi.set(__self__, "path", path)
        if format_options is not None:
            pulumi.set(__self__, "format_options", format_options)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @property
    @pulumi.getter
    def device(self) -> str:
        return pulumi.get(self, "device")

    @property
    @pulumi.getter
    def filesystem(self) -> str:
        return pulumi.get(self, "filesystem")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="formatOptions")
    def format_options(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "format_options")

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "mount_options")


@pulumi.output_type
class InstanceGroupWarmPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableLifecycleHook":
            suggest = "enable_lifecycle_hook"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupWarmPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupWarmPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupWarmPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_lifecycle_hook: Optional[bool] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None):
        """
        :param int max_size: - Int - MaxSize is the maximum size of the pool.
        :param int min_size: - Int - MinSize is the minimum size of the pool.
        """
        if enable_lifecycle_hook is not None:
            pulumi.set(__self__, "enable_lifecycle_hook", enable_lifecycle_hook)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)

    @property
    @pulumi.getter(name="enableLifecycleHook")
    def enable_lifecycle_hook(self) -> Optional[bool]:
        return pulumi.get(self, "enable_lifecycle_hook")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        """
        - Int - MaxSize is the maximum size of the pool.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        """
        - Int - MinSize is the minimum size of the pool.
        """
        return pulumi.get(self, "min_size")


@pulumi.output_type
class GetClusterAddonResult(dict):
    def __init__(__self__, *,
                 manifest: str):
        pulumi.set(__self__, "manifest", manifest)

    @property
    @pulumi.getter
    def manifest(self) -> str:
        return pulumi.get(self, "manifest")


@pulumi.output_type
class GetClusterApiResult(dict):
    def __init__(__self__, *,
                 dns: Sequence['outputs.GetClusterApiDnResult'],
                 load_balancers: Sequence['outputs.GetClusterApiLoadBalancerResult']):
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "load_balancers", load_balancers)

    @property
    @pulumi.getter
    def dns(self) -> Sequence['outputs.GetClusterApiDnResult']:
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> Sequence['outputs.GetClusterApiLoadBalancerResult']:
        return pulumi.get(self, "load_balancers")


@pulumi.output_type
class GetClusterApiDnResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClusterApiLoadBalancerResult(dict):
    def __init__(__self__, *,
                 access_logs: Sequence['outputs.GetClusterApiLoadBalancerAccessLogResult'],
                 additional_security_groups: Sequence[str],
                 class_: str,
                 cross_zone_load_balancing: bool,
                 idle_timeout_seconds: int,
                 security_group_override: str,
                 ssl_certificate: str,
                 ssl_policy: str,
                 subnets: Sequence['outputs.GetClusterApiLoadBalancerSubnetResult'],
                 type: str,
                 use_for_internal_api: bool):
        pulumi.set(__self__, "access_logs", access_logs)
        pulumi.set(__self__, "additional_security_groups", additional_security_groups)
        pulumi.set(__self__, "class_", class_)
        pulumi.set(__self__, "cross_zone_load_balancing", cross_zone_load_balancing)
        pulumi.set(__self__, "idle_timeout_seconds", idle_timeout_seconds)
        pulumi.set(__self__, "security_group_override", security_group_override)
        pulumi.set(__self__, "ssl_certificate", ssl_certificate)
        pulumi.set(__self__, "ssl_policy", ssl_policy)
        pulumi.set(__self__, "subnets", subnets)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "use_for_internal_api", use_for_internal_api)

    @property
    @pulumi.getter(name="accessLogs")
    def access_logs(self) -> Sequence['outputs.GetClusterApiLoadBalancerAccessLogResult']:
        return pulumi.get(self, "access_logs")

    @property
    @pulumi.getter(name="additionalSecurityGroups")
    def additional_security_groups(self) -> Sequence[str]:
        return pulumi.get(self, "additional_security_groups")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> str:
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter(name="crossZoneLoadBalancing")
    def cross_zone_load_balancing(self) -> bool:
        return pulumi.get(self, "cross_zone_load_balancing")

    @property
    @pulumi.getter(name="idleTimeoutSeconds")
    def idle_timeout_seconds(self) -> int:
        return pulumi.get(self, "idle_timeout_seconds")

    @property
    @pulumi.getter(name="securityGroupOverride")
    def security_group_override(self) -> str:
        return pulumi.get(self, "security_group_override")

    @property
    @pulumi.getter(name="sslCertificate")
    def ssl_certificate(self) -> str:
        return pulumi.get(self, "ssl_certificate")

    @property
    @pulumi.getter(name="sslPolicy")
    def ssl_policy(self) -> str:
        return pulumi.get(self, "ssl_policy")

    @property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.GetClusterApiLoadBalancerSubnetResult']:
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="useForInternalApi")
    def use_for_internal_api(self) -> bool:
        return pulumi.get(self, "use_for_internal_api")


@pulumi.output_type
class GetClusterApiLoadBalancerAccessLogResult(dict):
    def __init__(__self__, *,
                 bucket: str,
                 bucket_prefix: str,
                 interval: int):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> str:
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter
    def interval(self) -> int:
        return pulumi.get(self, "interval")


@pulumi.output_type
class GetClusterApiLoadBalancerSubnetResult(dict):
    def __init__(__self__, *,
                 allocation_id: str,
                 name: str,
                 private_ipv4_address: str):
        """
        :param str name: - String - Name defines the cluster name.
        """
        pulumi.set(__self__, "allocation_id", allocation_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_ipv4_address", private_ipv4_address)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> str:
        return pulumi.get(self, "allocation_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpv4Address")
    def private_ipv4_address(self) -> str:
        return pulumi.get(self, "private_ipv4_address")


@pulumi.output_type
class GetClusterAssetResult(dict):
    def __init__(__self__, *,
                 container_proxy: str,
                 container_registry: str,
                 file_repository: str):
        pulumi.set(__self__, "container_proxy", container_proxy)
        pulumi.set(__self__, "container_registry", container_registry)
        pulumi.set(__self__, "file_repository", file_repository)

    @property
    @pulumi.getter(name="containerProxy")
    def container_proxy(self) -> str:
        return pulumi.get(self, "container_proxy")

    @property
    @pulumi.getter(name="containerRegistry")
    def container_registry(self) -> str:
        return pulumi.get(self, "container_registry")

    @property
    @pulumi.getter(name="fileRepository")
    def file_repository(self) -> str:
        return pulumi.get(self, "file_repository")


@pulumi.output_type
class GetClusterAuthenticationResult(dict):
    def __init__(__self__, *,
                 aws: Sequence['outputs.GetClusterAuthenticationAwResult'],
                 kopeios: Sequence['outputs.GetClusterAuthenticationKopeioResult']):
        pulumi.set(__self__, "aws", aws)
        pulumi.set(__self__, "kopeios", kopeios)

    @property
    @pulumi.getter
    def aws(self) -> Sequence['outputs.GetClusterAuthenticationAwResult']:
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter
    def kopeios(self) -> Sequence['outputs.GetClusterAuthenticationKopeioResult']:
        return pulumi.get(self, "kopeios")


@pulumi.output_type
class GetClusterAuthenticationAwResult(dict):
    def __init__(__self__, *,
                 backend_mode: str,
                 cluster_id: str,
                 cpu_limit: str,
                 cpu_request: str,
                 identity_mappings: Sequence['outputs.GetClusterAuthenticationAwIdentityMappingResult'],
                 image: str,
                 memory_limit: str,
                 memory_request: str):
        pulumi.set(__self__, "backend_mode", backend_mode)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cpu_limit", cpu_limit)
        pulumi.set(__self__, "cpu_request", cpu_request)
        pulumi.set(__self__, "identity_mappings", identity_mappings)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "memory_limit", memory_limit)
        pulumi.set(__self__, "memory_request", memory_request)

    @property
    @pulumi.getter(name="backendMode")
    def backend_mode(self) -> str:
        return pulumi.get(self, "backend_mode")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> str:
        return pulumi.get(self, "cpu_limit")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> str:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter(name="identityMappings")
    def identity_mappings(self) -> Sequence['outputs.GetClusterAuthenticationAwIdentityMappingResult']:
        return pulumi.get(self, "identity_mappings")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> str:
        return pulumi.get(self, "memory_limit")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> str:
        return pulumi.get(self, "memory_request")


@pulumi.output_type
class GetClusterAuthenticationAwIdentityMappingResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 groups: Sequence[str],
                 username: str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def groups(self) -> Sequence[str]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetClusterAuthenticationKopeioResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClusterAuthorizationResult(dict):
    def __init__(__self__, *,
                 always_allows: Sequence['outputs.GetClusterAuthorizationAlwaysAllowResult'],
                 rbacs: Sequence['outputs.GetClusterAuthorizationRbacResult']):
        pulumi.set(__self__, "always_allows", always_allows)
        pulumi.set(__self__, "rbacs", rbacs)

    @property
    @pulumi.getter(name="alwaysAllows")
    def always_allows(self) -> Sequence['outputs.GetClusterAuthorizationAlwaysAllowResult']:
        return pulumi.get(self, "always_allows")

    @property
    @pulumi.getter
    def rbacs(self) -> Sequence['outputs.GetClusterAuthorizationRbacResult']:
        return pulumi.get(self, "rbacs")


@pulumi.output_type
class GetClusterAuthorizationAlwaysAllowResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClusterAuthorizationRbacResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClusterAwsLoadBalancerControllerResult(dict):
    def __init__(__self__, *,
                 enable_shield: bool,
                 enable_wa_fv2: bool,
                 enable_waf: bool,
                 enabled: bool,
                 version: str):
        pulumi.set(__self__, "enable_shield", enable_shield)
        pulumi.set(__self__, "enable_wa_fv2", enable_wa_fv2)
        pulumi.set(__self__, "enable_waf", enable_waf)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="enableShield")
    def enable_shield(self) -> bool:
        return pulumi.get(self, "enable_shield")

    @property
    @pulumi.getter(name="enableWaFv2")
    def enable_wa_fv2(self) -> bool:
        return pulumi.get(self, "enable_wa_fv2")

    @property
    @pulumi.getter(name="enableWaf")
    def enable_waf(self) -> bool:
        return pulumi.get(self, "enable_waf")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterCertManagerResult(dict):
    def __init__(__self__, *,
                 default_issuer: str,
                 enabled: bool,
                 hosted_zone_ids: Sequence[str],
                 image: str,
                 managed: bool,
                 nameservers: Sequence[str]):
        pulumi.set(__self__, "default_issuer", default_issuer)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "hosted_zone_ids", hosted_zone_ids)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "managed", managed)
        pulumi.set(__self__, "nameservers", nameservers)

    @property
    @pulumi.getter(name="defaultIssuer")
    def default_issuer(self) -> str:
        return pulumi.get(self, "default_issuer")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="hostedZoneIds")
    def hosted_zone_ids(self) -> Sequence[str]:
        return pulumi.get(self, "hosted_zone_ids")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def managed(self) -> bool:
        return pulumi.get(self, "managed")

    @property
    @pulumi.getter
    def nameservers(self) -> Sequence[str]:
        return pulumi.get(self, "nameservers")


@pulumi.output_type
class GetClusterCloudConfigResult(dict):
    def __init__(__self__, *,
                 aws_ebs_csi_drivers: Sequence['outputs.GetClusterCloudConfigAwsEbsCsiDriverResult'],
                 disable_security_group_ingress: bool,
                 elb_security_group: str,
                 gce_service_account: str,
                 gcp_pd_csi_drivers: Sequence['outputs.GetClusterCloudConfigGcpPdCsiDriverResult'],
                 manage_storage_classes: bool,
                 multizone: bool,
                 node_instance_prefix: str,
                 node_ip_families: Sequence[str],
                 node_tags: str,
                 spotinst_orientation: str,
                 spotinst_product: str):
        pulumi.set(__self__, "aws_ebs_csi_drivers", aws_ebs_csi_drivers)
        pulumi.set(__self__, "disable_security_group_ingress", disable_security_group_ingress)
        pulumi.set(__self__, "elb_security_group", elb_security_group)
        pulumi.set(__self__, "gce_service_account", gce_service_account)
        pulumi.set(__self__, "gcp_pd_csi_drivers", gcp_pd_csi_drivers)
        pulumi.set(__self__, "manage_storage_classes", manage_storage_classes)
        pulumi.set(__self__, "multizone", multizone)
        pulumi.set(__self__, "node_instance_prefix", node_instance_prefix)
        pulumi.set(__self__, "node_ip_families", node_ip_families)
        pulumi.set(__self__, "node_tags", node_tags)
        pulumi.set(__self__, "spotinst_orientation", spotinst_orientation)
        pulumi.set(__self__, "spotinst_product", spotinst_product)

    @property
    @pulumi.getter(name="awsEbsCsiDrivers")
    def aws_ebs_csi_drivers(self) -> Sequence['outputs.GetClusterCloudConfigAwsEbsCsiDriverResult']:
        return pulumi.get(self, "aws_ebs_csi_drivers")

    @property
    @pulumi.getter(name="disableSecurityGroupIngress")
    def disable_security_group_ingress(self) -> bool:
        return pulumi.get(self, "disable_security_group_ingress")

    @property
    @pulumi.getter(name="elbSecurityGroup")
    def elb_security_group(self) -> str:
        return pulumi.get(self, "elb_security_group")

    @property
    @pulumi.getter(name="gceServiceAccount")
    def gce_service_account(self) -> str:
        return pulumi.get(self, "gce_service_account")

    @property
    @pulumi.getter(name="gcpPdCsiDrivers")
    def gcp_pd_csi_drivers(self) -> Sequence['outputs.GetClusterCloudConfigGcpPdCsiDriverResult']:
        return pulumi.get(self, "gcp_pd_csi_drivers")

    @property
    @pulumi.getter(name="manageStorageClasses")
    def manage_storage_classes(self) -> bool:
        return pulumi.get(self, "manage_storage_classes")

    @property
    @pulumi.getter
    def multizone(self) -> bool:
        return pulumi.get(self, "multizone")

    @property
    @pulumi.getter(name="nodeInstancePrefix")
    def node_instance_prefix(self) -> str:
        return pulumi.get(self, "node_instance_prefix")

    @property
    @pulumi.getter(name="nodeIpFamilies")
    def node_ip_families(self) -> Sequence[str]:
        return pulumi.get(self, "node_ip_families")

    @property
    @pulumi.getter(name="nodeTags")
    def node_tags(self) -> str:
        return pulumi.get(self, "node_tags")

    @property
    @pulumi.getter(name="spotinstOrientation")
    def spotinst_orientation(self) -> str:
        return pulumi.get(self, "spotinst_orientation")

    @property
    @pulumi.getter(name="spotinstProduct")
    def spotinst_product(self) -> str:
        return pulumi.get(self, "spotinst_product")


@pulumi.output_type
class GetClusterCloudConfigAwsEbsCsiDriverResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 managed: bool,
                 pod_annotations: Mapping[str, str],
                 version: str,
                 volume_attach_limit: int):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "managed", managed)
        pulumi.set(__self__, "pod_annotations", pod_annotations)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "volume_attach_limit", volume_attach_limit)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def managed(self) -> bool:
        return pulumi.get(self, "managed")

    @property
    @pulumi.getter(name="podAnnotations")
    def pod_annotations(self) -> Mapping[str, str]:
        return pulumi.get(self, "pod_annotations")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="volumeAttachLimit")
    def volume_attach_limit(self) -> int:
        return pulumi.get(self, "volume_attach_limit")


@pulumi.output_type
class GetClusterCloudConfigGcpPdCsiDriverResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetClusterCloudProviderResult(dict):
    def __init__(__self__, *,
                 aws: Sequence['outputs.GetClusterCloudProviderAwResult'],
                 azures: Sequence['outputs.GetClusterCloudProviderAzureResult'],
                 dos: Sequence['outputs.GetClusterCloudProviderDoResult'],
                 gces: Sequence['outputs.GetClusterCloudProviderGceResult'],
                 hetzners: Sequence['outputs.GetClusterCloudProviderHetznerResult'],
                 openstacks: Sequence['outputs.GetClusterCloudProviderOpenstackResult']):
        pulumi.set(__self__, "aws", aws)
        pulumi.set(__self__, "azures", azures)
        pulumi.set(__self__, "dos", dos)
        pulumi.set(__self__, "gces", gces)
        pulumi.set(__self__, "hetzners", hetzners)
        pulumi.set(__self__, "openstacks", openstacks)

    @property
    @pulumi.getter
    def aws(self) -> Sequence['outputs.GetClusterCloudProviderAwResult']:
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter
    def azures(self) -> Sequence['outputs.GetClusterCloudProviderAzureResult']:
        return pulumi.get(self, "azures")

    @property
    @pulumi.getter
    def dos(self) -> Sequence['outputs.GetClusterCloudProviderDoResult']:
        return pulumi.get(self, "dos")

    @property
    @pulumi.getter
    def gces(self) -> Sequence['outputs.GetClusterCloudProviderGceResult']:
        return pulumi.get(self, "gces")

    @property
    @pulumi.getter
    def hetzners(self) -> Sequence['outputs.GetClusterCloudProviderHetznerResult']:
        return pulumi.get(self, "hetzners")

    @property
    @pulumi.getter
    def openstacks(self) -> Sequence['outputs.GetClusterCloudProviderOpenstackResult']:
        return pulumi.get(self, "openstacks")


@pulumi.output_type
class GetClusterCloudProviderAwResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClusterCloudProviderAzureResult(dict):
    def __init__(__self__, *,
                 admin_user: str,
                 resource_group_name: str,
                 route_table_name: str,
                 subscription_id: str,
                 tenant_id: str):
        pulumi.set(__self__, "admin_user", admin_user)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "route_table_name", route_table_name)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="adminUser")
    def admin_user(self) -> str:
        return pulumi.get(self, "admin_user")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="routeTableName")
    def route_table_name(self) -> str:
        return pulumi.get(self, "route_table_name")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetClusterCloudProviderDoResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClusterCloudProviderGceResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClusterCloudProviderHetznerResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClusterCloudProviderOpenstackResult(dict):
    def __init__(__self__, *,
                 block_storages: Sequence['outputs.GetClusterCloudProviderOpenstackBlockStorageResult'],
                 insecure_skip_verify: bool,
                 loadbalancers: Sequence['outputs.GetClusterCloudProviderOpenstackLoadbalancerResult'],
                 metadatas: Sequence['outputs.GetClusterCloudProviderOpenstackMetadataResult'],
                 monitors: Sequence['outputs.GetClusterCloudProviderOpenstackMonitorResult'],
                 networks: Sequence['outputs.GetClusterCloudProviderOpenstackNetworkResult'],
                 routers: Sequence['outputs.GetClusterCloudProviderOpenstackRouterResult']):
        pulumi.set(__self__, "block_storages", block_storages)
        pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        pulumi.set(__self__, "loadbalancers", loadbalancers)
        pulumi.set(__self__, "metadatas", metadatas)
        pulumi.set(__self__, "monitors", monitors)
        pulumi.set(__self__, "networks", networks)
        pulumi.set(__self__, "routers", routers)

    @property
    @pulumi.getter(name="blockStorages")
    def block_storages(self) -> Sequence['outputs.GetClusterCloudProviderOpenstackBlockStorageResult']:
        return pulumi.get(self, "block_storages")

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> bool:
        return pulumi.get(self, "insecure_skip_verify")

    @property
    @pulumi.getter
    def loadbalancers(self) -> Sequence['outputs.GetClusterCloudProviderOpenstackLoadbalancerResult']:
        return pulumi.get(self, "loadbalancers")

    @property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GetClusterCloudProviderOpenstackMetadataResult']:
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter
    def monitors(self) -> Sequence['outputs.GetClusterCloudProviderOpenstackMonitorResult']:
        return pulumi.get(self, "monitors")

    @property
    @pulumi.getter
    def networks(self) -> Sequence['outputs.GetClusterCloudProviderOpenstackNetworkResult']:
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter
    def routers(self) -> Sequence['outputs.GetClusterCloudProviderOpenstackRouterResult']:
        return pulumi.get(self, "routers")


@pulumi.output_type
class GetClusterCloudProviderOpenstackBlockStorageResult(dict):
    def __init__(__self__, *,
                 create_storage_class: bool,
                 csi_plugin_image: str,
                 csi_topology_support: bool,
                 ignore_az: bool,
                 override_az: str,
                 version: str):
        pulumi.set(__self__, "create_storage_class", create_storage_class)
        pulumi.set(__self__, "csi_plugin_image", csi_plugin_image)
        pulumi.set(__self__, "csi_topology_support", csi_topology_support)
        pulumi.set(__self__, "ignore_az", ignore_az)
        pulumi.set(__self__, "override_az", override_az)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="createStorageClass")
    def create_storage_class(self) -> bool:
        return pulumi.get(self, "create_storage_class")

    @property
    @pulumi.getter(name="csiPluginImage")
    def csi_plugin_image(self) -> str:
        return pulumi.get(self, "csi_plugin_image")

    @property
    @pulumi.getter(name="csiTopologySupport")
    def csi_topology_support(self) -> bool:
        return pulumi.get(self, "csi_topology_support")

    @property
    @pulumi.getter(name="ignoreAz")
    def ignore_az(self) -> bool:
        return pulumi.get(self, "ignore_az")

    @property
    @pulumi.getter(name="overrideAz")
    def override_az(self) -> str:
        return pulumi.get(self, "override_az")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterCloudProviderOpenstackLoadbalancerResult(dict):
    def __init__(__self__, *,
                 enable_ingress_hostname: bool,
                 floating_network: str,
                 floating_network_id: str,
                 floating_subnet: str,
                 ingress_hostname_suffix: str,
                 manage_sec_groups: bool,
                 method: str,
                 provider: str,
                 subnet_id: str,
                 use_octavia: bool):
        pulumi.set(__self__, "enable_ingress_hostname", enable_ingress_hostname)
        pulumi.set(__self__, "floating_network", floating_network)
        pulumi.set(__self__, "floating_network_id", floating_network_id)
        pulumi.set(__self__, "floating_subnet", floating_subnet)
        pulumi.set(__self__, "ingress_hostname_suffix", ingress_hostname_suffix)
        pulumi.set(__self__, "manage_sec_groups", manage_sec_groups)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "use_octavia", use_octavia)

    @property
    @pulumi.getter(name="enableIngressHostname")
    def enable_ingress_hostname(self) -> bool:
        return pulumi.get(self, "enable_ingress_hostname")

    @property
    @pulumi.getter(name="floatingNetwork")
    def floating_network(self) -> str:
        return pulumi.get(self, "floating_network")

    @property
    @pulumi.getter(name="floatingNetworkId")
    def floating_network_id(self) -> str:
        return pulumi.get(self, "floating_network_id")

    @property
    @pulumi.getter(name="floatingSubnet")
    def floating_subnet(self) -> str:
        return pulumi.get(self, "floating_subnet")

    @property
    @pulumi.getter(name="ingressHostnameSuffix")
    def ingress_hostname_suffix(self) -> str:
        return pulumi.get(self, "ingress_hostname_suffix")

    @property
    @pulumi.getter(name="manageSecGroups")
    def manage_sec_groups(self) -> bool:
        return pulumi.get(self, "manage_sec_groups")

    @property
    @pulumi.getter
    def method(self) -> str:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def provider(self) -> str:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="useOctavia")
    def use_octavia(self) -> bool:
        return pulumi.get(self, "use_octavia")


@pulumi.output_type
class GetClusterCloudProviderOpenstackMetadataResult(dict):
    def __init__(__self__, *,
                 config_drive: bool):
        pulumi.set(__self__, "config_drive", config_drive)

    @property
    @pulumi.getter(name="configDrive")
    def config_drive(self) -> bool:
        return pulumi.get(self, "config_drive")


@pulumi.output_type
class GetClusterCloudProviderOpenstackMonitorResult(dict):
    def __init__(__self__, *,
                 delay: str,
                 max_retries: int,
                 timeout: str):
        pulumi.set(__self__, "delay", delay)
        pulumi.set(__self__, "max_retries", max_retries)
        pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def delay(self) -> str:
        return pulumi.get(self, "delay")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> int:
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter
    def timeout(self) -> str:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class GetClusterCloudProviderOpenstackNetworkResult(dict):
    def __init__(__self__, *,
                 availability_zone_hints: Sequence[str],
                 internal_network_names: Sequence[str],
                 ipv6_support_disabled: bool,
                 public_network_names: Sequence[str]):
        pulumi.set(__self__, "availability_zone_hints", availability_zone_hints)
        pulumi.set(__self__, "internal_network_names", internal_network_names)
        pulumi.set(__self__, "ipv6_support_disabled", ipv6_support_disabled)
        pulumi.set(__self__, "public_network_names", public_network_names)

    @property
    @pulumi.getter(name="availabilityZoneHints")
    def availability_zone_hints(self) -> Sequence[str]:
        return pulumi.get(self, "availability_zone_hints")

    @property
    @pulumi.getter(name="internalNetworkNames")
    def internal_network_names(self) -> Sequence[str]:
        return pulumi.get(self, "internal_network_names")

    @property
    @pulumi.getter(name="ipv6SupportDisabled")
    def ipv6_support_disabled(self) -> bool:
        return pulumi.get(self, "ipv6_support_disabled")

    @property
    @pulumi.getter(name="publicNetworkNames")
    def public_network_names(self) -> Sequence[str]:
        return pulumi.get(self, "public_network_names")


@pulumi.output_type
class GetClusterCloudProviderOpenstackRouterResult(dict):
    def __init__(__self__, *,
                 availability_zone_hints: Sequence[str],
                 dns_servers: str,
                 external_network: str,
                 external_subnet: str):
        pulumi.set(__self__, "availability_zone_hints", availability_zone_hints)
        pulumi.set(__self__, "dns_servers", dns_servers)
        pulumi.set(__self__, "external_network", external_network)
        pulumi.set(__self__, "external_subnet", external_subnet)

    @property
    @pulumi.getter(name="availabilityZoneHints")
    def availability_zone_hints(self) -> Sequence[str]:
        return pulumi.get(self, "availability_zone_hints")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> str:
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter(name="externalNetwork")
    def external_network(self) -> str:
        return pulumi.get(self, "external_network")

    @property
    @pulumi.getter(name="externalSubnet")
    def external_subnet(self) -> str:
        return pulumi.get(self, "external_subnet")


@pulumi.output_type
class GetClusterClusterAutoscalerResult(dict):
    def __init__(__self__, *,
                 aws_use_static_instance_list: bool,
                 balance_similar_node_groups: bool,
                 cordon_node_before_terminating: bool,
                 cpu_request: str,
                 enabled: bool,
                 expander: str,
                 image: str,
                 max_node_provision_time: str,
                 memory_request: str,
                 new_pod_scale_up_delay: str,
                 pod_annotations: Mapping[str, str],
                 scale_down_delay_after_add: str,
                 scale_down_unneeded_time: str,
                 scale_down_unready_time: str,
                 scale_down_utilization_threshold: str,
                 skip_nodes_with_local_storage: bool,
                 skip_nodes_with_system_pods: bool):
        pulumi.set(__self__, "aws_use_static_instance_list", aws_use_static_instance_list)
        pulumi.set(__self__, "balance_similar_node_groups", balance_similar_node_groups)
        pulumi.set(__self__, "cordon_node_before_terminating", cordon_node_before_terminating)
        pulumi.set(__self__, "cpu_request", cpu_request)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "expander", expander)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "max_node_provision_time", max_node_provision_time)
        pulumi.set(__self__, "memory_request", memory_request)
        pulumi.set(__self__, "new_pod_scale_up_delay", new_pod_scale_up_delay)
        pulumi.set(__self__, "pod_annotations", pod_annotations)
        pulumi.set(__self__, "scale_down_delay_after_add", scale_down_delay_after_add)
        pulumi.set(__self__, "scale_down_unneeded_time", scale_down_unneeded_time)
        pulumi.set(__self__, "scale_down_unready_time", scale_down_unready_time)
        pulumi.set(__self__, "scale_down_utilization_threshold", scale_down_utilization_threshold)
        pulumi.set(__self__, "skip_nodes_with_local_storage", skip_nodes_with_local_storage)
        pulumi.set(__self__, "skip_nodes_with_system_pods", skip_nodes_with_system_pods)

    @property
    @pulumi.getter(name="awsUseStaticInstanceList")
    def aws_use_static_instance_list(self) -> bool:
        return pulumi.get(self, "aws_use_static_instance_list")

    @property
    @pulumi.getter(name="balanceSimilarNodeGroups")
    def balance_similar_node_groups(self) -> bool:
        return pulumi.get(self, "balance_similar_node_groups")

    @property
    @pulumi.getter(name="cordonNodeBeforeTerminating")
    def cordon_node_before_terminating(self) -> bool:
        return pulumi.get(self, "cordon_node_before_terminating")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> str:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def expander(self) -> str:
        return pulumi.get(self, "expander")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="maxNodeProvisionTime")
    def max_node_provision_time(self) -> str:
        return pulumi.get(self, "max_node_provision_time")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> str:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter(name="newPodScaleUpDelay")
    def new_pod_scale_up_delay(self) -> str:
        return pulumi.get(self, "new_pod_scale_up_delay")

    @property
    @pulumi.getter(name="podAnnotations")
    def pod_annotations(self) -> Mapping[str, str]:
        return pulumi.get(self, "pod_annotations")

    @property
    @pulumi.getter(name="scaleDownDelayAfterAdd")
    def scale_down_delay_after_add(self) -> str:
        return pulumi.get(self, "scale_down_delay_after_add")

    @property
    @pulumi.getter(name="scaleDownUnneededTime")
    def scale_down_unneeded_time(self) -> str:
        return pulumi.get(self, "scale_down_unneeded_time")

    @property
    @pulumi.getter(name="scaleDownUnreadyTime")
    def scale_down_unready_time(self) -> str:
        return pulumi.get(self, "scale_down_unready_time")

    @property
    @pulumi.getter(name="scaleDownUtilizationThreshold")
    def scale_down_utilization_threshold(self) -> str:
        return pulumi.get(self, "scale_down_utilization_threshold")

    @property
    @pulumi.getter(name="skipNodesWithLocalStorage")
    def skip_nodes_with_local_storage(self) -> bool:
        return pulumi.get(self, "skip_nodes_with_local_storage")

    @property
    @pulumi.getter(name="skipNodesWithSystemPods")
    def skip_nodes_with_system_pods(self) -> bool:
        return pulumi.get(self, "skip_nodes_with_system_pods")


@pulumi.output_type
class GetClusterContainerdResult(dict):
    def __init__(__self__, *,
                 address: str,
                 config_override: str,
                 log_level: str,
                 nvidia_gpus: Sequence['outputs.GetClusterContainerdNvidiaGpusResult'],
                 packages: Sequence['outputs.GetClusterContainerdPackageResult'],
                 registry_mirrors: Sequence['outputs.GetClusterContainerdRegistryMirrorResult'],
                 root: str,
                 runcs: Sequence['outputs.GetClusterContainerdRuncResult'],
                 skip_install: bool,
                 state: str,
                 version: str):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "config_override", config_override)
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "nvidia_gpus", nvidia_gpus)
        pulumi.set(__self__, "packages", packages)
        pulumi.set(__self__, "registry_mirrors", registry_mirrors)
        pulumi.set(__self__, "root", root)
        pulumi.set(__self__, "runcs", runcs)
        pulumi.set(__self__, "skip_install", skip_install)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="configOverride")
    def config_override(self) -> str:
        return pulumi.get(self, "config_override")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> str:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="nvidiaGpus")
    def nvidia_gpus(self) -> Sequence['outputs.GetClusterContainerdNvidiaGpusResult']:
        return pulumi.get(self, "nvidia_gpus")

    @property
    @pulumi.getter
    def packages(self) -> Sequence['outputs.GetClusterContainerdPackageResult']:
        return pulumi.get(self, "packages")

    @property
    @pulumi.getter(name="registryMirrors")
    def registry_mirrors(self) -> Sequence['outputs.GetClusterContainerdRegistryMirrorResult']:
        return pulumi.get(self, "registry_mirrors")

    @property
    @pulumi.getter
    def root(self) -> str:
        return pulumi.get(self, "root")

    @property
    @pulumi.getter
    def runcs(self) -> Sequence['outputs.GetClusterContainerdRuncResult']:
        return pulumi.get(self, "runcs")

    @property
    @pulumi.getter(name="skipInstall")
    def skip_install(self) -> bool:
        return pulumi.get(self, "skip_install")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterContainerdNvidiaGpusResult(dict):
    def __init__(__self__, *,
                 driver_package: str,
                 enabled: bool):
        pulumi.set(__self__, "driver_package", driver_package)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="driverPackage")
    def driver_package(self) -> str:
        return pulumi.get(self, "driver_package")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetClusterContainerdPackageResult(dict):
    def __init__(__self__, *,
                 hash_amd64: str,
                 hash_arm64: str,
                 url_amd64: str,
                 url_arm64: str):
        pulumi.set(__self__, "hash_amd64", hash_amd64)
        pulumi.set(__self__, "hash_arm64", hash_arm64)
        pulumi.set(__self__, "url_amd64", url_amd64)
        pulumi.set(__self__, "url_arm64", url_arm64)

    @property
    @pulumi.getter(name="hashAmd64")
    def hash_amd64(self) -> str:
        return pulumi.get(self, "hash_amd64")

    @property
    @pulumi.getter(name="hashArm64")
    def hash_arm64(self) -> str:
        return pulumi.get(self, "hash_arm64")

    @property
    @pulumi.getter(name="urlAmd64")
    def url_amd64(self) -> str:
        return pulumi.get(self, "url_amd64")

    @property
    @pulumi.getter(name="urlArm64")
    def url_arm64(self) -> str:
        return pulumi.get(self, "url_arm64")


@pulumi.output_type
class GetClusterContainerdRegistryMirrorResult(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterContainerdRuncResult(dict):
    def __init__(__self__, *,
                 packages: Sequence['outputs.GetClusterContainerdRuncPackageResult'],
                 version: str):
        pulumi.set(__self__, "packages", packages)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def packages(self) -> Sequence['outputs.GetClusterContainerdRuncPackageResult']:
        return pulumi.get(self, "packages")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterContainerdRuncPackageResult(dict):
    def __init__(__self__, *,
                 hash_amd64: str,
                 hash_arm64: str,
                 url_amd64: str,
                 url_arm64: str):
        pulumi.set(__self__, "hash_amd64", hash_amd64)
        pulumi.set(__self__, "hash_arm64", hash_arm64)
        pulumi.set(__self__, "url_amd64", url_amd64)
        pulumi.set(__self__, "url_arm64", url_arm64)

    @property
    @pulumi.getter(name="hashAmd64")
    def hash_amd64(self) -> str:
        return pulumi.get(self, "hash_amd64")

    @property
    @pulumi.getter(name="hashArm64")
    def hash_arm64(self) -> str:
        return pulumi.get(self, "hash_arm64")

    @property
    @pulumi.getter(name="urlAmd64")
    def url_amd64(self) -> str:
        return pulumi.get(self, "url_amd64")

    @property
    @pulumi.getter(name="urlArm64")
    def url_arm64(self) -> str:
        return pulumi.get(self, "url_arm64")


@pulumi.output_type
class GetClusterDockerResult(dict):
    def __init__(__self__, *,
                 authorization_plugins: Sequence[str],
                 bridge: str,
                 bridge_ip: str,
                 data_root: str,
                 default_runtime: str,
                 default_ulimits: Sequence[str],
                 dns: Sequence[str],
                 exec_opts: Sequence[str],
                 exec_root: str,
                 experimental: bool,
                 health_check: bool,
                 hosts: Sequence[str],
                 insecure_registries: Sequence[str],
                 insecure_registry: str,
                 ip_masq: bool,
                 ip_tables: bool,
                 live_restore: bool,
                 log_driver: str,
                 log_level: str,
                 log_opts: Sequence[str],
                 max_concurrent_downloads: int,
                 max_concurrent_uploads: int,
                 max_download_attempts: int,
                 metrics_address: str,
                 mtu: int,
                 packages: Sequence['outputs.GetClusterDockerPackageResult'],
                 registry_mirrors: Sequence[str],
                 runtimes: Sequence[str],
                 selinux_enabled: bool,
                 skip_install: bool,
                 storage: str,
                 storage_opts: Sequence[str],
                 user_namespace_remap: str,
                 version: str):
        pulumi.set(__self__, "authorization_plugins", authorization_plugins)
        pulumi.set(__self__, "bridge", bridge)
        pulumi.set(__self__, "bridge_ip", bridge_ip)
        pulumi.set(__self__, "data_root", data_root)
        pulumi.set(__self__, "default_runtime", default_runtime)
        pulumi.set(__self__, "default_ulimits", default_ulimits)
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "exec_opts", exec_opts)
        pulumi.set(__self__, "exec_root", exec_root)
        pulumi.set(__self__, "experimental", experimental)
        pulumi.set(__self__, "health_check", health_check)
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "insecure_registries", insecure_registries)
        pulumi.set(__self__, "insecure_registry", insecure_registry)
        pulumi.set(__self__, "ip_masq", ip_masq)
        pulumi.set(__self__, "ip_tables", ip_tables)
        pulumi.set(__self__, "live_restore", live_restore)
        pulumi.set(__self__, "log_driver", log_driver)
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "log_opts", log_opts)
        pulumi.set(__self__, "max_concurrent_downloads", max_concurrent_downloads)
        pulumi.set(__self__, "max_concurrent_uploads", max_concurrent_uploads)
        pulumi.set(__self__, "max_download_attempts", max_download_attempts)
        pulumi.set(__self__, "metrics_address", metrics_address)
        pulumi.set(__self__, "mtu", mtu)
        pulumi.set(__self__, "packages", packages)
        pulumi.set(__self__, "registry_mirrors", registry_mirrors)
        pulumi.set(__self__, "runtimes", runtimes)
        pulumi.set(__self__, "selinux_enabled", selinux_enabled)
        pulumi.set(__self__, "skip_install", skip_install)
        pulumi.set(__self__, "storage", storage)
        pulumi.set(__self__, "storage_opts", storage_opts)
        pulumi.set(__self__, "user_namespace_remap", user_namespace_remap)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="authorizationPlugins")
    def authorization_plugins(self) -> Sequence[str]:
        return pulumi.get(self, "authorization_plugins")

    @property
    @pulumi.getter
    def bridge(self) -> str:
        return pulumi.get(self, "bridge")

    @property
    @pulumi.getter(name="bridgeIp")
    def bridge_ip(self) -> str:
        return pulumi.get(self, "bridge_ip")

    @property
    @pulumi.getter(name="dataRoot")
    def data_root(self) -> str:
        return pulumi.get(self, "data_root")

    @property
    @pulumi.getter(name="defaultRuntime")
    def default_runtime(self) -> str:
        return pulumi.get(self, "default_runtime")

    @property
    @pulumi.getter(name="defaultUlimits")
    def default_ulimits(self) -> Sequence[str]:
        return pulumi.get(self, "default_ulimits")

    @property
    @pulumi.getter
    def dns(self) -> Sequence[str]:
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter(name="execOpts")
    def exec_opts(self) -> Sequence[str]:
        return pulumi.get(self, "exec_opts")

    @property
    @pulumi.getter(name="execRoot")
    def exec_root(self) -> str:
        return pulumi.get(self, "exec_root")

    @property
    @pulumi.getter
    def experimental(self) -> bool:
        return pulumi.get(self, "experimental")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> bool:
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter
    def hosts(self) -> Sequence[str]:
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter(name="insecureRegistries")
    def insecure_registries(self) -> Sequence[str]:
        return pulumi.get(self, "insecure_registries")

    @property
    @pulumi.getter(name="insecureRegistry")
    def insecure_registry(self) -> str:
        return pulumi.get(self, "insecure_registry")

    @property
    @pulumi.getter(name="ipMasq")
    def ip_masq(self) -> bool:
        return pulumi.get(self, "ip_masq")

    @property
    @pulumi.getter(name="ipTables")
    def ip_tables(self) -> bool:
        return pulumi.get(self, "ip_tables")

    @property
    @pulumi.getter(name="liveRestore")
    def live_restore(self) -> bool:
        return pulumi.get(self, "live_restore")

    @property
    @pulumi.getter(name="logDriver")
    def log_driver(self) -> str:
        return pulumi.get(self, "log_driver")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> str:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="logOpts")
    def log_opts(self) -> Sequence[str]:
        return pulumi.get(self, "log_opts")

    @property
    @pulumi.getter(name="maxConcurrentDownloads")
    def max_concurrent_downloads(self) -> int:
        return pulumi.get(self, "max_concurrent_downloads")

    @property
    @pulumi.getter(name="maxConcurrentUploads")
    def max_concurrent_uploads(self) -> int:
        return pulumi.get(self, "max_concurrent_uploads")

    @property
    @pulumi.getter(name="maxDownloadAttempts")
    def max_download_attempts(self) -> int:
        return pulumi.get(self, "max_download_attempts")

    @property
    @pulumi.getter(name="metricsAddress")
    def metrics_address(self) -> str:
        return pulumi.get(self, "metrics_address")

    @property
    @pulumi.getter
    def mtu(self) -> int:
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter
    def packages(self) -> Sequence['outputs.GetClusterDockerPackageResult']:
        return pulumi.get(self, "packages")

    @property
    @pulumi.getter(name="registryMirrors")
    def registry_mirrors(self) -> Sequence[str]:
        return pulumi.get(self, "registry_mirrors")

    @property
    @pulumi.getter
    def runtimes(self) -> Sequence[str]:
        return pulumi.get(self, "runtimes")

    @property
    @pulumi.getter(name="selinuxEnabled")
    def selinux_enabled(self) -> bool:
        return pulumi.get(self, "selinux_enabled")

    @property
    @pulumi.getter(name="skipInstall")
    def skip_install(self) -> bool:
        return pulumi.get(self, "skip_install")

    @property
    @pulumi.getter
    def storage(self) -> str:
        return pulumi.get(self, "storage")

    @property
    @pulumi.getter(name="storageOpts")
    def storage_opts(self) -> Sequence[str]:
        return pulumi.get(self, "storage_opts")

    @property
    @pulumi.getter(name="userNamespaceRemap")
    def user_namespace_remap(self) -> str:
        return pulumi.get(self, "user_namespace_remap")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterDockerPackageResult(dict):
    def __init__(__self__, *,
                 hash_amd64: str,
                 hash_arm64: str,
                 url_amd64: str,
                 url_arm64: str):
        pulumi.set(__self__, "hash_amd64", hash_amd64)
        pulumi.set(__self__, "hash_arm64", hash_arm64)
        pulumi.set(__self__, "url_amd64", url_amd64)
        pulumi.set(__self__, "url_arm64", url_arm64)

    @property
    @pulumi.getter(name="hashAmd64")
    def hash_amd64(self) -> str:
        return pulumi.get(self, "hash_amd64")

    @property
    @pulumi.getter(name="hashArm64")
    def hash_arm64(self) -> str:
        return pulumi.get(self, "hash_arm64")

    @property
    @pulumi.getter(name="urlAmd64")
    def url_amd64(self) -> str:
        return pulumi.get(self, "url_amd64")

    @property
    @pulumi.getter(name="urlArm64")
    def url_arm64(self) -> str:
        return pulumi.get(self, "url_arm64")


@pulumi.output_type
class GetClusterEgressProxyResult(dict):
    def __init__(__self__, *,
                 http_proxies: Sequence['outputs.GetClusterEgressProxyHttpProxyResult'],
                 proxy_excludes: str):
        pulumi.set(__self__, "http_proxies", http_proxies)
        pulumi.set(__self__, "proxy_excludes", proxy_excludes)

    @property
    @pulumi.getter(name="httpProxies")
    def http_proxies(self) -> Sequence['outputs.GetClusterEgressProxyHttpProxyResult']:
        return pulumi.get(self, "http_proxies")

    @property
    @pulumi.getter(name="proxyExcludes")
    def proxy_excludes(self) -> str:
        return pulumi.get(self, "proxy_excludes")


@pulumi.output_type
class GetClusterEgressProxyHttpProxyResult(dict):
    def __init__(__self__, *,
                 host: str,
                 port: int):
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")


@pulumi.output_type
class GetClusterEtcdClusterResult(dict):
    def __init__(__self__, *,
                 backups: Sequence['outputs.GetClusterEtcdClusterBackupResult'],
                 cpu_request: str,
                 heartbeat_interval: str,
                 image: str,
                 leader_election_timeout: str,
                 managers: Sequence['outputs.GetClusterEtcdClusterManagerResult'],
                 members: Sequence['outputs.GetClusterEtcdClusterMemberResult'],
                 memory_request: str,
                 name: str,
                 provider: str,
                 version: str):
        """
        :param str name: - String - Name defines the cluster name.
        """
        pulumi.set(__self__, "backups", backups)
        pulumi.set(__self__, "cpu_request", cpu_request)
        pulumi.set(__self__, "heartbeat_interval", heartbeat_interval)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "leader_election_timeout", leader_election_timeout)
        pulumi.set(__self__, "managers", managers)
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "memory_request", memory_request)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def backups(self) -> Sequence['outputs.GetClusterEtcdClusterBackupResult']:
        return pulumi.get(self, "backups")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> str:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter(name="heartbeatInterval")
    def heartbeat_interval(self) -> str:
        return pulumi.get(self, "heartbeat_interval")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="leaderElectionTimeout")
    def leader_election_timeout(self) -> str:
        return pulumi.get(self, "leader_election_timeout")

    @property
    @pulumi.getter
    def managers(self) -> Sequence['outputs.GetClusterEtcdClusterManagerResult']:
        return pulumi.get(self, "managers")

    @property
    @pulumi.getter
    def members(self) -> Sequence['outputs.GetClusterEtcdClusterMemberResult']:
        return pulumi.get(self, "members")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> str:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def provider(self) -> str:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterEtcdClusterBackupResult(dict):
    def __init__(__self__, *,
                 backup_store: str,
                 image: str):
        pulumi.set(__self__, "backup_store", backup_store)
        pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter(name="backupStore")
    def backup_store(self) -> str:
        return pulumi.get(self, "backup_store")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")


@pulumi.output_type
class GetClusterEtcdClusterManagerResult(dict):
    def __init__(__self__, *,
                 backup_interval: str,
                 discovery_poll_interval: str,
                 envs: Sequence['outputs.GetClusterEtcdClusterManagerEnvResult'],
                 image: str,
                 log_level: int):
        pulumi.set(__self__, "backup_interval", backup_interval)
        pulumi.set(__self__, "discovery_poll_interval", discovery_poll_interval)
        pulumi.set(__self__, "envs", envs)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "log_level", log_level)

    @property
    @pulumi.getter(name="backupInterval")
    def backup_interval(self) -> str:
        return pulumi.get(self, "backup_interval")

    @property
    @pulumi.getter(name="discoveryPollInterval")
    def discovery_poll_interval(self) -> str:
        return pulumi.get(self, "discovery_poll_interval")

    @property
    @pulumi.getter
    def envs(self) -> Sequence['outputs.GetClusterEtcdClusterManagerEnvResult']:
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> int:
        return pulumi.get(self, "log_level")


@pulumi.output_type
class GetClusterEtcdClusterManagerEnvResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: - String - Name defines the cluster name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterEtcdClusterMemberResult(dict):
    def __init__(__self__, *,
                 encrypted_volume: bool,
                 instance_group: str,
                 kms_key_id: str,
                 name: str,
                 volume_iops: int,
                 volume_size: int,
                 volume_throughput: int,
                 volume_type: str):
        """
        :param str name: - String - Name defines the cluster name.
        """
        pulumi.set(__self__, "encrypted_volume", encrypted_volume)
        pulumi.set(__self__, "instance_group", instance_group)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "volume_iops", volume_iops)
        pulumi.set(__self__, "volume_size", volume_size)
        pulumi.set(__self__, "volume_throughput", volume_throughput)
        pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="encryptedVolume")
    def encrypted_volume(self) -> bool:
        return pulumi.get(self, "encrypted_volume")

    @property
    @pulumi.getter(name="instanceGroup")
    def instance_group(self) -> str:
        return pulumi.get(self, "instance_group")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="volumeIops")
    def volume_iops(self) -> int:
        return pulumi.get(self, "volume_iops")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> int:
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeThroughput")
    def volume_throughput(self) -> int:
        return pulumi.get(self, "volume_throughput")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetClusterExternalCloudControllerManagerResult(dict):
    def __init__(__self__, *,
                 allocate_node_cidrs: bool,
                 allow_untagged_cloud: bool,
                 cidr_allocator_type: str,
                 cloud_provider: str,
                 cluster_cidr: str,
                 cluster_name: str,
                 configure_cloud_routes: bool,
                 controllers: Sequence[str],
                 cpu_request: str,
                 enable_leader_migration: bool,
                 image: str,
                 leader_elections: Sequence['outputs.GetClusterExternalCloudControllerManagerLeaderElectionResult'],
                 log_level: int,
                 master: str,
                 use_service_account_credentials: bool):
        """
        :param str cloud_provider: - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        """
        pulumi.set(__self__, "allocate_node_cidrs", allocate_node_cidrs)
        pulumi.set(__self__, "allow_untagged_cloud", allow_untagged_cloud)
        pulumi.set(__self__, "cidr_allocator_type", cidr_allocator_type)
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "cluster_cidr", cluster_cidr)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "configure_cloud_routes", configure_cloud_routes)
        pulumi.set(__self__, "controllers", controllers)
        pulumi.set(__self__, "cpu_request", cpu_request)
        pulumi.set(__self__, "enable_leader_migration", enable_leader_migration)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "leader_elections", leader_elections)
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "use_service_account_credentials", use_service_account_credentials)

    @property
    @pulumi.getter(name="allocateNodeCidrs")
    def allocate_node_cidrs(self) -> bool:
        return pulumi.get(self, "allocate_node_cidrs")

    @property
    @pulumi.getter(name="allowUntaggedCloud")
    def allow_untagged_cloud(self) -> bool:
        return pulumi.get(self, "allow_untagged_cloud")

    @property
    @pulumi.getter(name="cidrAllocatorType")
    def cidr_allocator_type(self) -> str:
        return pulumi.get(self, "cidr_allocator_type")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="clusterCidr")
    def cluster_cidr(self) -> str:
        return pulumi.get(self, "cluster_cidr")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="configureCloudRoutes")
    def configure_cloud_routes(self) -> bool:
        return pulumi.get(self, "configure_cloud_routes")

    @property
    @pulumi.getter
    def controllers(self) -> Sequence[str]:
        return pulumi.get(self, "controllers")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> str:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter(name="enableLeaderMigration")
    def enable_leader_migration(self) -> bool:
        return pulumi.get(self, "enable_leader_migration")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="leaderElections")
    def leader_elections(self) -> Sequence['outputs.GetClusterExternalCloudControllerManagerLeaderElectionResult']:
        return pulumi.get(self, "leader_elections")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> int:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter
    def master(self) -> str:
        return pulumi.get(self, "master")

    @property
    @pulumi.getter(name="useServiceAccountCredentials")
    def use_service_account_credentials(self) -> bool:
        return pulumi.get(self, "use_service_account_credentials")


@pulumi.output_type
class GetClusterExternalCloudControllerManagerLeaderElectionResult(dict):
    def __init__(__self__, *,
                 leader_elect: bool,
                 leader_elect_lease_duration: str,
                 leader_elect_renew_deadline_duration: str,
                 leader_elect_resource_lock: str,
                 leader_elect_resource_name: str,
                 leader_elect_resource_namespace: str,
                 leader_elect_retry_period: str):
        pulumi.set(__self__, "leader_elect", leader_elect)
        pulumi.set(__self__, "leader_elect_lease_duration", leader_elect_lease_duration)
        pulumi.set(__self__, "leader_elect_renew_deadline_duration", leader_elect_renew_deadline_duration)
        pulumi.set(__self__, "leader_elect_resource_lock", leader_elect_resource_lock)
        pulumi.set(__self__, "leader_elect_resource_name", leader_elect_resource_name)
        pulumi.set(__self__, "leader_elect_resource_namespace", leader_elect_resource_namespace)
        pulumi.set(__self__, "leader_elect_retry_period", leader_elect_retry_period)

    @property
    @pulumi.getter(name="leaderElect")
    def leader_elect(self) -> bool:
        return pulumi.get(self, "leader_elect")

    @property
    @pulumi.getter(name="leaderElectLeaseDuration")
    def leader_elect_lease_duration(self) -> str:
        return pulumi.get(self, "leader_elect_lease_duration")

    @property
    @pulumi.getter(name="leaderElectRenewDeadlineDuration")
    def leader_elect_renew_deadline_duration(self) -> str:
        return pulumi.get(self, "leader_elect_renew_deadline_duration")

    @property
    @pulumi.getter(name="leaderElectResourceLock")
    def leader_elect_resource_lock(self) -> str:
        return pulumi.get(self, "leader_elect_resource_lock")

    @property
    @pulumi.getter(name="leaderElectResourceName")
    def leader_elect_resource_name(self) -> str:
        return pulumi.get(self, "leader_elect_resource_name")

    @property
    @pulumi.getter(name="leaderElectResourceNamespace")
    def leader_elect_resource_namespace(self) -> str:
        return pulumi.get(self, "leader_elect_resource_namespace")

    @property
    @pulumi.getter(name="leaderElectRetryPeriod")
    def leader_elect_retry_period(self) -> str:
        return pulumi.get(self, "leader_elect_retry_period")


@pulumi.output_type
class GetClusterExternalDnResult(dict):
    def __init__(__self__, *,
                 provider: str,
                 watch_ingress: bool,
                 watch_namespace: str):
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "watch_ingress", watch_ingress)
        pulumi.set(__self__, "watch_namespace", watch_namespace)

    @property
    @pulumi.getter
    def provider(self) -> str:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="watchIngress")
    def watch_ingress(self) -> bool:
        return pulumi.get(self, "watch_ingress")

    @property
    @pulumi.getter(name="watchNamespace")
    def watch_namespace(self) -> str:
        return pulumi.get(self, "watch_namespace")


@pulumi.output_type
class GetClusterExternalPolicyResult(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterFileAssetResult(dict):
    def __init__(__self__, *,
                 content: str,
                 is_base64: bool,
                 mode: str,
                 name: str,
                 path: str,
                 roles: Sequence[str]):
        """
        :param str name: - String - Name defines the cluster name.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "is_base64", is_base64)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="isBase64")
    def is_base64(self) -> bool:
        return pulumi.get(self, "is_base64")

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def roles(self) -> Sequence[str]:
        return pulumi.get(self, "roles")


@pulumi.output_type
class GetClusterHookResult(dict):
    def __init__(__self__, *,
                 befores: Sequence[str],
                 enabled: bool,
                 exec_containers: Sequence['outputs.GetClusterHookExecContainerResult'],
                 manifest: str,
                 name: str,
                 requires: Sequence[str],
                 roles: Sequence[str],
                 use_raw_manifest: bool):
        """
        :param str name: - String - Name defines the cluster name.
        """
        pulumi.set(__self__, "befores", befores)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "exec_containers", exec_containers)
        pulumi.set(__self__, "manifest", manifest)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "requires", requires)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "use_raw_manifest", use_raw_manifest)

    @property
    @pulumi.getter
    def befores(self) -> Sequence[str]:
        return pulumi.get(self, "befores")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="execContainers")
    def exec_containers(self) -> Sequence['outputs.GetClusterHookExecContainerResult']:
        return pulumi.get(self, "exec_containers")

    @property
    @pulumi.getter
    def manifest(self) -> str:
        return pulumi.get(self, "manifest")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def requires(self) -> Sequence[str]:
        return pulumi.get(self, "requires")

    @property
    @pulumi.getter
    def roles(self) -> Sequence[str]:
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter(name="useRawManifest")
    def use_raw_manifest(self) -> bool:
        return pulumi.get(self, "use_raw_manifest")


@pulumi.output_type
class GetClusterHookExecContainerResult(dict):
    def __init__(__self__, *,
                 commands: Sequence[str],
                 environment: Mapping[str, str],
                 image: str):
        pulumi.set(__self__, "commands", commands)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def environment(self) -> Mapping[str, str]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")


@pulumi.output_type
class GetClusterIamResult(dict):
    def __init__(__self__, *,
                 allow_container_registry: bool,
                 legacy: bool,
                 permissions_boundary: str,
                 service_account_external_permissions: Sequence['outputs.GetClusterIamServiceAccountExternalPermissionResult'],
                 use_service_account_external_permissions: bool):
        pulumi.set(__self__, "allow_container_registry", allow_container_registry)
        pulumi.set(__self__, "legacy", legacy)
        pulumi.set(__self__, "permissions_boundary", permissions_boundary)
        pulumi.set(__self__, "service_account_external_permissions", service_account_external_permissions)
        pulumi.set(__self__, "use_service_account_external_permissions", use_service_account_external_permissions)

    @property
    @pulumi.getter(name="allowContainerRegistry")
    def allow_container_registry(self) -> bool:
        return pulumi.get(self, "allow_container_registry")

    @property
    @pulumi.getter
    def legacy(self) -> bool:
        return pulumi.get(self, "legacy")

    @property
    @pulumi.getter(name="permissionsBoundary")
    def permissions_boundary(self) -> str:
        return pulumi.get(self, "permissions_boundary")

    @property
    @pulumi.getter(name="serviceAccountExternalPermissions")
    def service_account_external_permissions(self) -> Sequence['outputs.GetClusterIamServiceAccountExternalPermissionResult']:
        return pulumi.get(self, "service_account_external_permissions")

    @property
    @pulumi.getter(name="useServiceAccountExternalPermissions")
    def use_service_account_external_permissions(self) -> bool:
        return pulumi.get(self, "use_service_account_external_permissions")


@pulumi.output_type
class GetClusterIamServiceAccountExternalPermissionResult(dict):
    def __init__(__self__, *,
                 aws: Sequence['outputs.GetClusterIamServiceAccountExternalPermissionAwResult'],
                 name: str,
                 namespace: str):
        """
        :param str name: - String - Name defines the cluster name.
        """
        pulumi.set(__self__, "aws", aws)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def aws(self) -> Sequence['outputs.GetClusterIamServiceAccountExternalPermissionAwResult']:
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        return pulumi.get(self, "namespace")


@pulumi.output_type
class GetClusterIamServiceAccountExternalPermissionAwResult(dict):
    def __init__(__self__, *,
                 inline_policy: str,
                 policy_ar_ns: Sequence[str]):
        pulumi.set(__self__, "inline_policy", inline_policy)
        pulumi.set(__self__, "policy_ar_ns", policy_ar_ns)

    @property
    @pulumi.getter(name="inlinePolicy")
    def inline_policy(self) -> str:
        return pulumi.get(self, "inline_policy")

    @property
    @pulumi.getter(name="policyArNs")
    def policy_ar_ns(self) -> Sequence[str]:
        return pulumi.get(self, "policy_ar_ns")


@pulumi.output_type
class GetClusterKarpenterResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetClusterKubeApiServerResult(dict):
    def __init__(__self__, *,
                 address: str,
                 admission_control_config_file: str,
                 admission_controls: Sequence[str],
                 advertise_address: str,
                 allow_privileged: bool,
                 api_audiences: Sequence[str],
                 api_server_count: int,
                 append_admission_plugins: Sequence[str],
                 audit_dynamic_configuration: bool,
                 audit_log_format: str,
                 audit_log_max_age: int,
                 audit_log_max_backups: int,
                 audit_log_max_size: int,
                 audit_log_path: str,
                 audit_policy_file: str,
                 audit_webhook_batch_buffer_size: int,
                 audit_webhook_batch_max_size: int,
                 audit_webhook_batch_max_wait: str,
                 audit_webhook_batch_throttle_burst: int,
                 audit_webhook_batch_throttle_enable: bool,
                 audit_webhook_batch_throttle_qps: str,
                 audit_webhook_config_file: str,
                 audit_webhook_initial_backoff: str,
                 audit_webhook_mode: str,
                 authentication_token_webhook_cache_ttl: str,
                 authentication_token_webhook_config_file: str,
                 authorization_mode: str,
                 authorization_rbac_super_user: str,
                 authorization_webhook_cache_authorized_ttl: str,
                 authorization_webhook_cache_unauthorized_ttl: str,
                 authorization_webhook_config_file: str,
                 basic_auth_file: str,
                 bind_address: str,
                 client_ca_file: str,
                 cloud_provider: str,
                 cors_allowed_origins: Sequence[str],
                 cpu_limit: str,
                 cpu_request: str,
                 default_not_ready_toleration_seconds: int,
                 default_unreachable_toleration_seconds: int,
                 disable_admission_plugins: Sequence[str],
                 disable_basic_auth: bool,
                 enable_admission_plugins: Sequence[str],
                 enable_aggregator_routing: bool,
                 enable_bootstrap_auth_token: bool,
                 enable_profiling: bool,
                 encryption_provider_config: str,
                 etcd_ca_file: str,
                 etcd_cert_file: str,
                 etcd_key_file: str,
                 etcd_quorum_read: bool,
                 etcd_servers: Sequence[str],
                 etcd_servers_overrides: Sequence[str],
                 event_ttl: str,
                 experimental_encryption_provider_config: str,
                 feature_gates: Mapping[str, str],
                 http2_max_streams_per_connection: int,
                 image: str,
                 insecure_bind_address: str,
                 insecure_port: int,
                 kubelet_certificate_authority: str,
                 kubelet_client_certificate: str,
                 kubelet_client_key: str,
                 kubelet_preferred_address_types: Sequence[str],
                 log_format: str,
                 log_level: int,
                 max_mutating_requests_inflight: int,
                 max_requests_inflight: int,
                 memory_limit: str,
                 memory_request: str,
                 min_request_timeout: int,
                 oidc_ca_file: str,
                 oidc_client_id: str,
                 oidc_groups_claim: str,
                 oidc_groups_prefix: str,
                 oidc_issuer_url: str,
                 oidc_required_claims: Sequence[str],
                 oidc_username_claim: str,
                 oidc_username_prefix: str,
                 proxy_client_cert_file: str,
                 proxy_client_key_file: str,
                 request_timeout: str,
                 requestheader_allowed_names: Sequence[str],
                 requestheader_client_ca_file: str,
                 requestheader_extra_header_prefixes: Sequence[str],
                 requestheader_group_headers: Sequence[str],
                 requestheader_username_headers: Sequence[str],
                 runtime_config: Mapping[str, str],
                 secure_port: int,
                 service_account_issuer: str,
                 service_account_jwksuri: str,
                 service_account_key_files: Sequence[str],
                 service_account_signing_key_file: str,
                 service_cluster_ip_range: str,
                 service_node_port_range: str,
                 storage_backend: str,
                 target_ram_mb: int,
                 tls_cert_file: str,
                 tls_cipher_suites: Sequence[str],
                 tls_min_version: str,
                 tls_private_key_file: str,
                 token_auth_file: str,
                 anonymous_auth: Optional['outputs.GetClusterKubeApiServerAnonymousAuthResult'] = None):
        """
        :param str cloud_provider: - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        :param str service_cluster_ip_range: - String - ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "admission_control_config_file", admission_control_config_file)
        pulumi.set(__self__, "admission_controls", admission_controls)
        pulumi.set(__self__, "advertise_address", advertise_address)
        pulumi.set(__self__, "allow_privileged", allow_privileged)
        pulumi.set(__self__, "api_audiences", api_audiences)
        pulumi.set(__self__, "api_server_count", api_server_count)
        pulumi.set(__self__, "append_admission_plugins", append_admission_plugins)
        pulumi.set(__self__, "audit_dynamic_configuration", audit_dynamic_configuration)
        pulumi.set(__self__, "audit_log_format", audit_log_format)
        pulumi.set(__self__, "audit_log_max_age", audit_log_max_age)
        pulumi.set(__self__, "audit_log_max_backups", audit_log_max_backups)
        pulumi.set(__self__, "audit_log_max_size", audit_log_max_size)
        pulumi.set(__self__, "audit_log_path", audit_log_path)
        pulumi.set(__self__, "audit_policy_file", audit_policy_file)
        pulumi.set(__self__, "audit_webhook_batch_buffer_size", audit_webhook_batch_buffer_size)
        pulumi.set(__self__, "audit_webhook_batch_max_size", audit_webhook_batch_max_size)
        pulumi.set(__self__, "audit_webhook_batch_max_wait", audit_webhook_batch_max_wait)
        pulumi.set(__self__, "audit_webhook_batch_throttle_burst", audit_webhook_batch_throttle_burst)
        pulumi.set(__self__, "audit_webhook_batch_throttle_enable", audit_webhook_batch_throttle_enable)
        pulumi.set(__self__, "audit_webhook_batch_throttle_qps", audit_webhook_batch_throttle_qps)
        pulumi.set(__self__, "audit_webhook_config_file", audit_webhook_config_file)
        pulumi.set(__self__, "audit_webhook_initial_backoff", audit_webhook_initial_backoff)
        pulumi.set(__self__, "audit_webhook_mode", audit_webhook_mode)
        pulumi.set(__self__, "authentication_token_webhook_cache_ttl", authentication_token_webhook_cache_ttl)
        pulumi.set(__self__, "authentication_token_webhook_config_file", authentication_token_webhook_config_file)
        pulumi.set(__self__, "authorization_mode", authorization_mode)
        pulumi.set(__self__, "authorization_rbac_super_user", authorization_rbac_super_user)
        pulumi.set(__self__, "authorization_webhook_cache_authorized_ttl", authorization_webhook_cache_authorized_ttl)
        pulumi.set(__self__, "authorization_webhook_cache_unauthorized_ttl", authorization_webhook_cache_unauthorized_ttl)
        pulumi.set(__self__, "authorization_webhook_config_file", authorization_webhook_config_file)
        pulumi.set(__self__, "basic_auth_file", basic_auth_file)
        pulumi.set(__self__, "bind_address", bind_address)
        pulumi.set(__self__, "client_ca_file", client_ca_file)
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "cors_allowed_origins", cors_allowed_origins)
        pulumi.set(__self__, "cpu_limit", cpu_limit)
        pulumi.set(__self__, "cpu_request", cpu_request)
        pulumi.set(__self__, "default_not_ready_toleration_seconds", default_not_ready_toleration_seconds)
        pulumi.set(__self__, "default_unreachable_toleration_seconds", default_unreachable_toleration_seconds)
        pulumi.set(__self__, "disable_admission_plugins", disable_admission_plugins)
        pulumi.set(__self__, "disable_basic_auth", disable_basic_auth)
        pulumi.set(__self__, "enable_admission_plugins", enable_admission_plugins)
        pulumi.set(__self__, "enable_aggregator_routing", enable_aggregator_routing)
        pulumi.set(__self__, "enable_bootstrap_auth_token", enable_bootstrap_auth_token)
        pulumi.set(__self__, "enable_profiling", enable_profiling)
        pulumi.set(__self__, "encryption_provider_config", encryption_provider_config)
        pulumi.set(__self__, "etcd_ca_file", etcd_ca_file)
        pulumi.set(__self__, "etcd_cert_file", etcd_cert_file)
        pulumi.set(__self__, "etcd_key_file", etcd_key_file)
        pulumi.set(__self__, "etcd_quorum_read", etcd_quorum_read)
        pulumi.set(__self__, "etcd_servers", etcd_servers)
        pulumi.set(__self__, "etcd_servers_overrides", etcd_servers_overrides)
        pulumi.set(__self__, "event_ttl", event_ttl)
        pulumi.set(__self__, "experimental_encryption_provider_config", experimental_encryption_provider_config)
        pulumi.set(__self__, "feature_gates", feature_gates)
        pulumi.set(__self__, "http2_max_streams_per_connection", http2_max_streams_per_connection)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "insecure_bind_address", insecure_bind_address)
        pulumi.set(__self__, "insecure_port", insecure_port)
        pulumi.set(__self__, "kubelet_certificate_authority", kubelet_certificate_authority)
        pulumi.set(__self__, "kubelet_client_certificate", kubelet_client_certificate)
        pulumi.set(__self__, "kubelet_client_key", kubelet_client_key)
        pulumi.set(__self__, "kubelet_preferred_address_types", kubelet_preferred_address_types)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "max_mutating_requests_inflight", max_mutating_requests_inflight)
        pulumi.set(__self__, "max_requests_inflight", max_requests_inflight)
        pulumi.set(__self__, "memory_limit", memory_limit)
        pulumi.set(__self__, "memory_request", memory_request)
        pulumi.set(__self__, "min_request_timeout", min_request_timeout)
        pulumi.set(__self__, "oidc_ca_file", oidc_ca_file)
        pulumi.set(__self__, "oidc_client_id", oidc_client_id)
        pulumi.set(__self__, "oidc_groups_claim", oidc_groups_claim)
        pulumi.set(__self__, "oidc_groups_prefix", oidc_groups_prefix)
        pulumi.set(__self__, "oidc_issuer_url", oidc_issuer_url)
        pulumi.set(__self__, "oidc_required_claims", oidc_required_claims)
        pulumi.set(__self__, "oidc_username_claim", oidc_username_claim)
        pulumi.set(__self__, "oidc_username_prefix", oidc_username_prefix)
        pulumi.set(__self__, "proxy_client_cert_file", proxy_client_cert_file)
        pulumi.set(__self__, "proxy_client_key_file", proxy_client_key_file)
        pulumi.set(__self__, "request_timeout", request_timeout)
        pulumi.set(__self__, "requestheader_allowed_names", requestheader_allowed_names)
        pulumi.set(__self__, "requestheader_client_ca_file", requestheader_client_ca_file)
        pulumi.set(__self__, "requestheader_extra_header_prefixes", requestheader_extra_header_prefixes)
        pulumi.set(__self__, "requestheader_group_headers", requestheader_group_headers)
        pulumi.set(__self__, "requestheader_username_headers", requestheader_username_headers)
        pulumi.set(__self__, "runtime_config", runtime_config)
        pulumi.set(__self__, "secure_port", secure_port)
        pulumi.set(__self__, "service_account_issuer", service_account_issuer)
        pulumi.set(__self__, "service_account_jwksuri", service_account_jwksuri)
        pulumi.set(__self__, "service_account_key_files", service_account_key_files)
        pulumi.set(__self__, "service_account_signing_key_file", service_account_signing_key_file)
        pulumi.set(__self__, "service_cluster_ip_range", service_cluster_ip_range)
        pulumi.set(__self__, "service_node_port_range", service_node_port_range)
        pulumi.set(__self__, "storage_backend", storage_backend)
        pulumi.set(__self__, "target_ram_mb", target_ram_mb)
        pulumi.set(__self__, "tls_cert_file", tls_cert_file)
        pulumi.set(__self__, "tls_cipher_suites", tls_cipher_suites)
        pulumi.set(__self__, "tls_min_version", tls_min_version)
        pulumi.set(__self__, "tls_private_key_file", tls_private_key_file)
        pulumi.set(__self__, "token_auth_file", token_auth_file)
        if anonymous_auth is not None:
            pulumi.set(__self__, "anonymous_auth", anonymous_auth)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="admissionControlConfigFile")
    def admission_control_config_file(self) -> str:
        return pulumi.get(self, "admission_control_config_file")

    @property
    @pulumi.getter(name="admissionControls")
    def admission_controls(self) -> Sequence[str]:
        return pulumi.get(self, "admission_controls")

    @property
    @pulumi.getter(name="advertiseAddress")
    def advertise_address(self) -> str:
        return pulumi.get(self, "advertise_address")

    @property
    @pulumi.getter(name="allowPrivileged")
    def allow_privileged(self) -> bool:
        return pulumi.get(self, "allow_privileged")

    @property
    @pulumi.getter(name="apiAudiences")
    def api_audiences(self) -> Sequence[str]:
        return pulumi.get(self, "api_audiences")

    @property
    @pulumi.getter(name="apiServerCount")
    def api_server_count(self) -> int:
        return pulumi.get(self, "api_server_count")

    @property
    @pulumi.getter(name="appendAdmissionPlugins")
    def append_admission_plugins(self) -> Sequence[str]:
        return pulumi.get(self, "append_admission_plugins")

    @property
    @pulumi.getter(name="auditDynamicConfiguration")
    def audit_dynamic_configuration(self) -> bool:
        return pulumi.get(self, "audit_dynamic_configuration")

    @property
    @pulumi.getter(name="auditLogFormat")
    def audit_log_format(self) -> str:
        return pulumi.get(self, "audit_log_format")

    @property
    @pulumi.getter(name="auditLogMaxAge")
    def audit_log_max_age(self) -> int:
        return pulumi.get(self, "audit_log_max_age")

    @property
    @pulumi.getter(name="auditLogMaxBackups")
    def audit_log_max_backups(self) -> int:
        return pulumi.get(self, "audit_log_max_backups")

    @property
    @pulumi.getter(name="auditLogMaxSize")
    def audit_log_max_size(self) -> int:
        return pulumi.get(self, "audit_log_max_size")

    @property
    @pulumi.getter(name="auditLogPath")
    def audit_log_path(self) -> str:
        return pulumi.get(self, "audit_log_path")

    @property
    @pulumi.getter(name="auditPolicyFile")
    def audit_policy_file(self) -> str:
        return pulumi.get(self, "audit_policy_file")

    @property
    @pulumi.getter(name="auditWebhookBatchBufferSize")
    def audit_webhook_batch_buffer_size(self) -> int:
        return pulumi.get(self, "audit_webhook_batch_buffer_size")

    @property
    @pulumi.getter(name="auditWebhookBatchMaxSize")
    def audit_webhook_batch_max_size(self) -> int:
        return pulumi.get(self, "audit_webhook_batch_max_size")

    @property
    @pulumi.getter(name="auditWebhookBatchMaxWait")
    def audit_webhook_batch_max_wait(self) -> str:
        return pulumi.get(self, "audit_webhook_batch_max_wait")

    @property
    @pulumi.getter(name="auditWebhookBatchThrottleBurst")
    def audit_webhook_batch_throttle_burst(self) -> int:
        return pulumi.get(self, "audit_webhook_batch_throttle_burst")

    @property
    @pulumi.getter(name="auditWebhookBatchThrottleEnable")
    def audit_webhook_batch_throttle_enable(self) -> bool:
        return pulumi.get(self, "audit_webhook_batch_throttle_enable")

    @property
    @pulumi.getter(name="auditWebhookBatchThrottleQps")
    def audit_webhook_batch_throttle_qps(self) -> str:
        return pulumi.get(self, "audit_webhook_batch_throttle_qps")

    @property
    @pulumi.getter(name="auditWebhookConfigFile")
    def audit_webhook_config_file(self) -> str:
        return pulumi.get(self, "audit_webhook_config_file")

    @property
    @pulumi.getter(name="auditWebhookInitialBackoff")
    def audit_webhook_initial_backoff(self) -> str:
        return pulumi.get(self, "audit_webhook_initial_backoff")

    @property
    @pulumi.getter(name="auditWebhookMode")
    def audit_webhook_mode(self) -> str:
        return pulumi.get(self, "audit_webhook_mode")

    @property
    @pulumi.getter(name="authenticationTokenWebhookCacheTtl")
    def authentication_token_webhook_cache_ttl(self) -> str:
        return pulumi.get(self, "authentication_token_webhook_cache_ttl")

    @property
    @pulumi.getter(name="authenticationTokenWebhookConfigFile")
    def authentication_token_webhook_config_file(self) -> str:
        return pulumi.get(self, "authentication_token_webhook_config_file")

    @property
    @pulumi.getter(name="authorizationMode")
    def authorization_mode(self) -> str:
        return pulumi.get(self, "authorization_mode")

    @property
    @pulumi.getter(name="authorizationRbacSuperUser")
    def authorization_rbac_super_user(self) -> str:
        return pulumi.get(self, "authorization_rbac_super_user")

    @property
    @pulumi.getter(name="authorizationWebhookCacheAuthorizedTtl")
    def authorization_webhook_cache_authorized_ttl(self) -> str:
        return pulumi.get(self, "authorization_webhook_cache_authorized_ttl")

    @property
    @pulumi.getter(name="authorizationWebhookCacheUnauthorizedTtl")
    def authorization_webhook_cache_unauthorized_ttl(self) -> str:
        return pulumi.get(self, "authorization_webhook_cache_unauthorized_ttl")

    @property
    @pulumi.getter(name="authorizationWebhookConfigFile")
    def authorization_webhook_config_file(self) -> str:
        return pulumi.get(self, "authorization_webhook_config_file")

    @property
    @pulumi.getter(name="basicAuthFile")
    def basic_auth_file(self) -> str:
        return pulumi.get(self, "basic_auth_file")

    @property
    @pulumi.getter(name="bindAddress")
    def bind_address(self) -> str:
        return pulumi.get(self, "bind_address")

    @property
    @pulumi.getter(name="clientCaFile")
    def client_ca_file(self) -> str:
        return pulumi.get(self, "client_ca_file")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="corsAllowedOrigins")
    def cors_allowed_origins(self) -> Sequence[str]:
        return pulumi.get(self, "cors_allowed_origins")

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> str:
        return pulumi.get(self, "cpu_limit")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> str:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter(name="defaultNotReadyTolerationSeconds")
    def default_not_ready_toleration_seconds(self) -> int:
        return pulumi.get(self, "default_not_ready_toleration_seconds")

    @property
    @pulumi.getter(name="defaultUnreachableTolerationSeconds")
    def default_unreachable_toleration_seconds(self) -> int:
        return pulumi.get(self, "default_unreachable_toleration_seconds")

    @property
    @pulumi.getter(name="disableAdmissionPlugins")
    def disable_admission_plugins(self) -> Sequence[str]:
        return pulumi.get(self, "disable_admission_plugins")

    @property
    @pulumi.getter(name="disableBasicAuth")
    def disable_basic_auth(self) -> bool:
        return pulumi.get(self, "disable_basic_auth")

    @property
    @pulumi.getter(name="enableAdmissionPlugins")
    def enable_admission_plugins(self) -> Sequence[str]:
        return pulumi.get(self, "enable_admission_plugins")

    @property
    @pulumi.getter(name="enableAggregatorRouting")
    def enable_aggregator_routing(self) -> bool:
        return pulumi.get(self, "enable_aggregator_routing")

    @property
    @pulumi.getter(name="enableBootstrapAuthToken")
    def enable_bootstrap_auth_token(self) -> bool:
        return pulumi.get(self, "enable_bootstrap_auth_token")

    @property
    @pulumi.getter(name="enableProfiling")
    def enable_profiling(self) -> bool:
        return pulumi.get(self, "enable_profiling")

    @property
    @pulumi.getter(name="encryptionProviderConfig")
    def encryption_provider_config(self) -> str:
        return pulumi.get(self, "encryption_provider_config")

    @property
    @pulumi.getter(name="etcdCaFile")
    def etcd_ca_file(self) -> str:
        return pulumi.get(self, "etcd_ca_file")

    @property
    @pulumi.getter(name="etcdCertFile")
    def etcd_cert_file(self) -> str:
        return pulumi.get(self, "etcd_cert_file")

    @property
    @pulumi.getter(name="etcdKeyFile")
    def etcd_key_file(self) -> str:
        return pulumi.get(self, "etcd_key_file")

    @property
    @pulumi.getter(name="etcdQuorumRead")
    def etcd_quorum_read(self) -> bool:
        return pulumi.get(self, "etcd_quorum_read")

    @property
    @pulumi.getter(name="etcdServers")
    def etcd_servers(self) -> Sequence[str]:
        return pulumi.get(self, "etcd_servers")

    @property
    @pulumi.getter(name="etcdServersOverrides")
    def etcd_servers_overrides(self) -> Sequence[str]:
        return pulumi.get(self, "etcd_servers_overrides")

    @property
    @pulumi.getter(name="eventTtl")
    def event_ttl(self) -> str:
        return pulumi.get(self, "event_ttl")

    @property
    @pulumi.getter(name="experimentalEncryptionProviderConfig")
    def experimental_encryption_provider_config(self) -> str:
        return pulumi.get(self, "experimental_encryption_provider_config")

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Mapping[str, str]:
        return pulumi.get(self, "feature_gates")

    @property
    @pulumi.getter(name="http2MaxStreamsPerConnection")
    def http2_max_streams_per_connection(self) -> int:
        return pulumi.get(self, "http2_max_streams_per_connection")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="insecureBindAddress")
    def insecure_bind_address(self) -> str:
        return pulumi.get(self, "insecure_bind_address")

    @property
    @pulumi.getter(name="insecurePort")
    def insecure_port(self) -> int:
        return pulumi.get(self, "insecure_port")

    @property
    @pulumi.getter(name="kubeletCertificateAuthority")
    def kubelet_certificate_authority(self) -> str:
        return pulumi.get(self, "kubelet_certificate_authority")

    @property
    @pulumi.getter(name="kubeletClientCertificate")
    def kubelet_client_certificate(self) -> str:
        return pulumi.get(self, "kubelet_client_certificate")

    @property
    @pulumi.getter(name="kubeletClientKey")
    def kubelet_client_key(self) -> str:
        return pulumi.get(self, "kubelet_client_key")

    @property
    @pulumi.getter(name="kubeletPreferredAddressTypes")
    def kubelet_preferred_address_types(self) -> Sequence[str]:
        return pulumi.get(self, "kubelet_preferred_address_types")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> str:
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> int:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="maxMutatingRequestsInflight")
    def max_mutating_requests_inflight(self) -> int:
        return pulumi.get(self, "max_mutating_requests_inflight")

    @property
    @pulumi.getter(name="maxRequestsInflight")
    def max_requests_inflight(self) -> int:
        return pulumi.get(self, "max_requests_inflight")

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> str:
        return pulumi.get(self, "memory_limit")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> str:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter(name="minRequestTimeout")
    def min_request_timeout(self) -> int:
        return pulumi.get(self, "min_request_timeout")

    @property
    @pulumi.getter(name="oidcCaFile")
    def oidc_ca_file(self) -> str:
        return pulumi.get(self, "oidc_ca_file")

    @property
    @pulumi.getter(name="oidcClientId")
    def oidc_client_id(self) -> str:
        return pulumi.get(self, "oidc_client_id")

    @property
    @pulumi.getter(name="oidcGroupsClaim")
    def oidc_groups_claim(self) -> str:
        return pulumi.get(self, "oidc_groups_claim")

    @property
    @pulumi.getter(name="oidcGroupsPrefix")
    def oidc_groups_prefix(self) -> str:
        return pulumi.get(self, "oidc_groups_prefix")

    @property
    @pulumi.getter(name="oidcIssuerUrl")
    def oidc_issuer_url(self) -> str:
        return pulumi.get(self, "oidc_issuer_url")

    @property
    @pulumi.getter(name="oidcRequiredClaims")
    def oidc_required_claims(self) -> Sequence[str]:
        return pulumi.get(self, "oidc_required_claims")

    @property
    @pulumi.getter(name="oidcUsernameClaim")
    def oidc_username_claim(self) -> str:
        return pulumi.get(self, "oidc_username_claim")

    @property
    @pulumi.getter(name="oidcUsernamePrefix")
    def oidc_username_prefix(self) -> str:
        return pulumi.get(self, "oidc_username_prefix")

    @property
    @pulumi.getter(name="proxyClientCertFile")
    def proxy_client_cert_file(self) -> str:
        return pulumi.get(self, "proxy_client_cert_file")

    @property
    @pulumi.getter(name="proxyClientKeyFile")
    def proxy_client_key_file(self) -> str:
        return pulumi.get(self, "proxy_client_key_file")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> str:
        return pulumi.get(self, "request_timeout")

    @property
    @pulumi.getter(name="requestheaderAllowedNames")
    def requestheader_allowed_names(self) -> Sequence[str]:
        return pulumi.get(self, "requestheader_allowed_names")

    @property
    @pulumi.getter(name="requestheaderClientCaFile")
    def requestheader_client_ca_file(self) -> str:
        return pulumi.get(self, "requestheader_client_ca_file")

    @property
    @pulumi.getter(name="requestheaderExtraHeaderPrefixes")
    def requestheader_extra_header_prefixes(self) -> Sequence[str]:
        return pulumi.get(self, "requestheader_extra_header_prefixes")

    @property
    @pulumi.getter(name="requestheaderGroupHeaders")
    def requestheader_group_headers(self) -> Sequence[str]:
        return pulumi.get(self, "requestheader_group_headers")

    @property
    @pulumi.getter(name="requestheaderUsernameHeaders")
    def requestheader_username_headers(self) -> Sequence[str]:
        return pulumi.get(self, "requestheader_username_headers")

    @property
    @pulumi.getter(name="runtimeConfig")
    def runtime_config(self) -> Mapping[str, str]:
        return pulumi.get(self, "runtime_config")

    @property
    @pulumi.getter(name="securePort")
    def secure_port(self) -> int:
        return pulumi.get(self, "secure_port")

    @property
    @pulumi.getter(name="serviceAccountIssuer")
    def service_account_issuer(self) -> str:
        return pulumi.get(self, "service_account_issuer")

    @property
    @pulumi.getter(name="serviceAccountJwksuri")
    def service_account_jwksuri(self) -> str:
        return pulumi.get(self, "service_account_jwksuri")

    @property
    @pulumi.getter(name="serviceAccountKeyFiles")
    def service_account_key_files(self) -> Sequence[str]:
        return pulumi.get(self, "service_account_key_files")

    @property
    @pulumi.getter(name="serviceAccountSigningKeyFile")
    def service_account_signing_key_file(self) -> str:
        return pulumi.get(self, "service_account_signing_key_file")

    @property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> str:
        """
        - String - ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services.
        """
        return pulumi.get(self, "service_cluster_ip_range")

    @property
    @pulumi.getter(name="serviceNodePortRange")
    def service_node_port_range(self) -> str:
        return pulumi.get(self, "service_node_port_range")

    @property
    @pulumi.getter(name="storageBackend")
    def storage_backend(self) -> str:
        return pulumi.get(self, "storage_backend")

    @property
    @pulumi.getter(name="targetRamMb")
    def target_ram_mb(self) -> int:
        return pulumi.get(self, "target_ram_mb")

    @property
    @pulumi.getter(name="tlsCertFile")
    def tls_cert_file(self) -> str:
        return pulumi.get(self, "tls_cert_file")

    @property
    @pulumi.getter(name="tlsCipherSuites")
    def tls_cipher_suites(self) -> Sequence[str]:
        return pulumi.get(self, "tls_cipher_suites")

    @property
    @pulumi.getter(name="tlsMinVersion")
    def tls_min_version(self) -> str:
        return pulumi.get(self, "tls_min_version")

    @property
    @pulumi.getter(name="tlsPrivateKeyFile")
    def tls_private_key_file(self) -> str:
        return pulumi.get(self, "tls_private_key_file")

    @property
    @pulumi.getter(name="tokenAuthFile")
    def token_auth_file(self) -> str:
        return pulumi.get(self, "token_auth_file")

    @property
    @pulumi.getter(name="anonymousAuth")
    def anonymous_auth(self) -> Optional['outputs.GetClusterKubeApiServerAnonymousAuthResult']:
        return pulumi.get(self, "anonymous_auth")


@pulumi.output_type
class GetClusterKubeApiServerAnonymousAuthResult(dict):
    def __init__(__self__, *,
                 value: bool):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterKubeControllerManagerResult(dict):
    def __init__(__self__, *,
                 allocate_node_cidrs: bool,
                 attach_detach_reconcile_sync_period: str,
                 authentication_kubeconfig: str,
                 authorization_always_allow_paths: Sequence[str],
                 authorization_kubeconfig: str,
                 cidr_allocator_type: str,
                 cloud_provider: str,
                 cluster_cidr: str,
                 cluster_name: str,
                 concurrent_deployment_syncs: int,
                 concurrent_endpoint_syncs: int,
                 concurrent_namespace_syncs: int,
                 concurrent_rc_syncs: int,
                 concurrent_replicaset_syncs: int,
                 concurrent_resource_quota_syncs: int,
                 concurrent_service_syncs: int,
                 concurrent_serviceaccount_token_syncs: int,
                 configure_cloud_routes: bool,
                 controllers: Sequence[str],
                 disable_attach_detach_reconcile_sync: bool,
                 enable_leader_migration: bool,
                 enable_profiling: bool,
                 experimental_cluster_signing_duration: str,
                 external_cloud_volume_plugin: str,
                 feature_gates: Mapping[str, str],
                 horizontal_pod_autoscaler_cpu_initialization_period: str,
                 horizontal_pod_autoscaler_downscale_delay: str,
                 horizontal_pod_autoscaler_downscale_stabilization: str,
                 horizontal_pod_autoscaler_initial_readiness_delay: str,
                 horizontal_pod_autoscaler_sync_period: str,
                 horizontal_pod_autoscaler_tolerance: str,
                 horizontal_pod_autoscaler_upscale_delay: str,
                 horizontal_pod_autoscaler_use_rest_clients: bool,
                 image: str,
                 kube_api_burst: int,
                 kube_api_qps: str,
                 leader_elections: Sequence['outputs.GetClusterKubeControllerManagerLeaderElectionResult'],
                 log_format: str,
                 log_level: int,
                 master: str,
                 min_resync_period: str,
                 node_cidr_mask_size: int,
                 node_monitor_grace_period: str,
                 node_monitor_period: str,
                 pod_eviction_timeout: str,
                 root_ca_file: str,
                 service_account_private_key_file: str,
                 terminated_pod_gc_threshold: int,
                 tls_cert_file: str,
                 tls_cipher_suites: Sequence[str],
                 tls_min_version: str,
                 tls_private_key_file: str,
                 use_service_account_credentials: bool):
        """
        :param str cloud_provider: - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        """
        pulumi.set(__self__, "allocate_node_cidrs", allocate_node_cidrs)
        pulumi.set(__self__, "attach_detach_reconcile_sync_period", attach_detach_reconcile_sync_period)
        pulumi.set(__self__, "authentication_kubeconfig", authentication_kubeconfig)
        pulumi.set(__self__, "authorization_always_allow_paths", authorization_always_allow_paths)
        pulumi.set(__self__, "authorization_kubeconfig", authorization_kubeconfig)
        pulumi.set(__self__, "cidr_allocator_type", cidr_allocator_type)
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "cluster_cidr", cluster_cidr)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "concurrent_deployment_syncs", concurrent_deployment_syncs)
        pulumi.set(__self__, "concurrent_endpoint_syncs", concurrent_endpoint_syncs)
        pulumi.set(__self__, "concurrent_namespace_syncs", concurrent_namespace_syncs)
        pulumi.set(__self__, "concurrent_rc_syncs", concurrent_rc_syncs)
        pulumi.set(__self__, "concurrent_replicaset_syncs", concurrent_replicaset_syncs)
        pulumi.set(__self__, "concurrent_resource_quota_syncs", concurrent_resource_quota_syncs)
        pulumi.set(__self__, "concurrent_service_syncs", concurrent_service_syncs)
        pulumi.set(__self__, "concurrent_serviceaccount_token_syncs", concurrent_serviceaccount_token_syncs)
        pulumi.set(__self__, "configure_cloud_routes", configure_cloud_routes)
        pulumi.set(__self__, "controllers", controllers)
        pulumi.set(__self__, "disable_attach_detach_reconcile_sync", disable_attach_detach_reconcile_sync)
        pulumi.set(__self__, "enable_leader_migration", enable_leader_migration)
        pulumi.set(__self__, "enable_profiling", enable_profiling)
        pulumi.set(__self__, "experimental_cluster_signing_duration", experimental_cluster_signing_duration)
        pulumi.set(__self__, "external_cloud_volume_plugin", external_cloud_volume_plugin)
        pulumi.set(__self__, "feature_gates", feature_gates)
        pulumi.set(__self__, "horizontal_pod_autoscaler_cpu_initialization_period", horizontal_pod_autoscaler_cpu_initialization_period)
        pulumi.set(__self__, "horizontal_pod_autoscaler_downscale_delay", horizontal_pod_autoscaler_downscale_delay)
        pulumi.set(__self__, "horizontal_pod_autoscaler_downscale_stabilization", horizontal_pod_autoscaler_downscale_stabilization)
        pulumi.set(__self__, "horizontal_pod_autoscaler_initial_readiness_delay", horizontal_pod_autoscaler_initial_readiness_delay)
        pulumi.set(__self__, "horizontal_pod_autoscaler_sync_period", horizontal_pod_autoscaler_sync_period)
        pulumi.set(__self__, "horizontal_pod_autoscaler_tolerance", horizontal_pod_autoscaler_tolerance)
        pulumi.set(__self__, "horizontal_pod_autoscaler_upscale_delay", horizontal_pod_autoscaler_upscale_delay)
        pulumi.set(__self__, "horizontal_pod_autoscaler_use_rest_clients", horizontal_pod_autoscaler_use_rest_clients)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "kube_api_burst", kube_api_burst)
        pulumi.set(__self__, "kube_api_qps", kube_api_qps)
        pulumi.set(__self__, "leader_elections", leader_elections)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "min_resync_period", min_resync_period)
        pulumi.set(__self__, "node_cidr_mask_size", node_cidr_mask_size)
        pulumi.set(__self__, "node_monitor_grace_period", node_monitor_grace_period)
        pulumi.set(__self__, "node_monitor_period", node_monitor_period)
        pulumi.set(__self__, "pod_eviction_timeout", pod_eviction_timeout)
        pulumi.set(__self__, "root_ca_file", root_ca_file)
        pulumi.set(__self__, "service_account_private_key_file", service_account_private_key_file)
        pulumi.set(__self__, "terminated_pod_gc_threshold", terminated_pod_gc_threshold)
        pulumi.set(__self__, "tls_cert_file", tls_cert_file)
        pulumi.set(__self__, "tls_cipher_suites", tls_cipher_suites)
        pulumi.set(__self__, "tls_min_version", tls_min_version)
        pulumi.set(__self__, "tls_private_key_file", tls_private_key_file)
        pulumi.set(__self__, "use_service_account_credentials", use_service_account_credentials)

    @property
    @pulumi.getter(name="allocateNodeCidrs")
    def allocate_node_cidrs(self) -> bool:
        return pulumi.get(self, "allocate_node_cidrs")

    @property
    @pulumi.getter(name="attachDetachReconcileSyncPeriod")
    def attach_detach_reconcile_sync_period(self) -> str:
        return pulumi.get(self, "attach_detach_reconcile_sync_period")

    @property
    @pulumi.getter(name="authenticationKubeconfig")
    def authentication_kubeconfig(self) -> str:
        return pulumi.get(self, "authentication_kubeconfig")

    @property
    @pulumi.getter(name="authorizationAlwaysAllowPaths")
    def authorization_always_allow_paths(self) -> Sequence[str]:
        return pulumi.get(self, "authorization_always_allow_paths")

    @property
    @pulumi.getter(name="authorizationKubeconfig")
    def authorization_kubeconfig(self) -> str:
        return pulumi.get(self, "authorization_kubeconfig")

    @property
    @pulumi.getter(name="cidrAllocatorType")
    def cidr_allocator_type(self) -> str:
        return pulumi.get(self, "cidr_allocator_type")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="clusterCidr")
    def cluster_cidr(self) -> str:
        return pulumi.get(self, "cluster_cidr")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="concurrentDeploymentSyncs")
    def concurrent_deployment_syncs(self) -> int:
        return pulumi.get(self, "concurrent_deployment_syncs")

    @property
    @pulumi.getter(name="concurrentEndpointSyncs")
    def concurrent_endpoint_syncs(self) -> int:
        return pulumi.get(self, "concurrent_endpoint_syncs")

    @property
    @pulumi.getter(name="concurrentNamespaceSyncs")
    def concurrent_namespace_syncs(self) -> int:
        return pulumi.get(self, "concurrent_namespace_syncs")

    @property
    @pulumi.getter(name="concurrentRcSyncs")
    def concurrent_rc_syncs(self) -> int:
        return pulumi.get(self, "concurrent_rc_syncs")

    @property
    @pulumi.getter(name="concurrentReplicasetSyncs")
    def concurrent_replicaset_syncs(self) -> int:
        return pulumi.get(self, "concurrent_replicaset_syncs")

    @property
    @pulumi.getter(name="concurrentResourceQuotaSyncs")
    def concurrent_resource_quota_syncs(self) -> int:
        return pulumi.get(self, "concurrent_resource_quota_syncs")

    @property
    @pulumi.getter(name="concurrentServiceSyncs")
    def concurrent_service_syncs(self) -> int:
        return pulumi.get(self, "concurrent_service_syncs")

    @property
    @pulumi.getter(name="concurrentServiceaccountTokenSyncs")
    def concurrent_serviceaccount_token_syncs(self) -> int:
        return pulumi.get(self, "concurrent_serviceaccount_token_syncs")

    @property
    @pulumi.getter(name="configureCloudRoutes")
    def configure_cloud_routes(self) -> bool:
        return pulumi.get(self, "configure_cloud_routes")

    @property
    @pulumi.getter
    def controllers(self) -> Sequence[str]:
        return pulumi.get(self, "controllers")

    @property
    @pulumi.getter(name="disableAttachDetachReconcileSync")
    def disable_attach_detach_reconcile_sync(self) -> bool:
        return pulumi.get(self, "disable_attach_detach_reconcile_sync")

    @property
    @pulumi.getter(name="enableLeaderMigration")
    def enable_leader_migration(self) -> bool:
        return pulumi.get(self, "enable_leader_migration")

    @property
    @pulumi.getter(name="enableProfiling")
    def enable_profiling(self) -> bool:
        return pulumi.get(self, "enable_profiling")

    @property
    @pulumi.getter(name="experimentalClusterSigningDuration")
    def experimental_cluster_signing_duration(self) -> str:
        return pulumi.get(self, "experimental_cluster_signing_duration")

    @property
    @pulumi.getter(name="externalCloudVolumePlugin")
    def external_cloud_volume_plugin(self) -> str:
        return pulumi.get(self, "external_cloud_volume_plugin")

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Mapping[str, str]:
        return pulumi.get(self, "feature_gates")

    @property
    @pulumi.getter(name="horizontalPodAutoscalerCpuInitializationPeriod")
    def horizontal_pod_autoscaler_cpu_initialization_period(self) -> str:
        return pulumi.get(self, "horizontal_pod_autoscaler_cpu_initialization_period")

    @property
    @pulumi.getter(name="horizontalPodAutoscalerDownscaleDelay")
    def horizontal_pod_autoscaler_downscale_delay(self) -> str:
        return pulumi.get(self, "horizontal_pod_autoscaler_downscale_delay")

    @property
    @pulumi.getter(name="horizontalPodAutoscalerDownscaleStabilization")
    def horizontal_pod_autoscaler_downscale_stabilization(self) -> str:
        return pulumi.get(self, "horizontal_pod_autoscaler_downscale_stabilization")

    @property
    @pulumi.getter(name="horizontalPodAutoscalerInitialReadinessDelay")
    def horizontal_pod_autoscaler_initial_readiness_delay(self) -> str:
        return pulumi.get(self, "horizontal_pod_autoscaler_initial_readiness_delay")

    @property
    @pulumi.getter(name="horizontalPodAutoscalerSyncPeriod")
    def horizontal_pod_autoscaler_sync_period(self) -> str:
        return pulumi.get(self, "horizontal_pod_autoscaler_sync_period")

    @property
    @pulumi.getter(name="horizontalPodAutoscalerTolerance")
    def horizontal_pod_autoscaler_tolerance(self) -> str:
        return pulumi.get(self, "horizontal_pod_autoscaler_tolerance")

    @property
    @pulumi.getter(name="horizontalPodAutoscalerUpscaleDelay")
    def horizontal_pod_autoscaler_upscale_delay(self) -> str:
        return pulumi.get(self, "horizontal_pod_autoscaler_upscale_delay")

    @property
    @pulumi.getter(name="horizontalPodAutoscalerUseRestClients")
    def horizontal_pod_autoscaler_use_rest_clients(self) -> bool:
        return pulumi.get(self, "horizontal_pod_autoscaler_use_rest_clients")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="kubeApiBurst")
    def kube_api_burst(self) -> int:
        return pulumi.get(self, "kube_api_burst")

    @property
    @pulumi.getter(name="kubeApiQps")
    def kube_api_qps(self) -> str:
        return pulumi.get(self, "kube_api_qps")

    @property
    @pulumi.getter(name="leaderElections")
    def leader_elections(self) -> Sequence['outputs.GetClusterKubeControllerManagerLeaderElectionResult']:
        return pulumi.get(self, "leader_elections")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> str:
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> int:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter
    def master(self) -> str:
        return pulumi.get(self, "master")

    @property
    @pulumi.getter(name="minResyncPeriod")
    def min_resync_period(self) -> str:
        return pulumi.get(self, "min_resync_period")

    @property
    @pulumi.getter(name="nodeCidrMaskSize")
    def node_cidr_mask_size(self) -> int:
        return pulumi.get(self, "node_cidr_mask_size")

    @property
    @pulumi.getter(name="nodeMonitorGracePeriod")
    def node_monitor_grace_period(self) -> str:
        return pulumi.get(self, "node_monitor_grace_period")

    @property
    @pulumi.getter(name="nodeMonitorPeriod")
    def node_monitor_period(self) -> str:
        return pulumi.get(self, "node_monitor_period")

    @property
    @pulumi.getter(name="podEvictionTimeout")
    def pod_eviction_timeout(self) -> str:
        return pulumi.get(self, "pod_eviction_timeout")

    @property
    @pulumi.getter(name="rootCaFile")
    def root_ca_file(self) -> str:
        return pulumi.get(self, "root_ca_file")

    @property
    @pulumi.getter(name="serviceAccountPrivateKeyFile")
    def service_account_private_key_file(self) -> str:
        return pulumi.get(self, "service_account_private_key_file")

    @property
    @pulumi.getter(name="terminatedPodGcThreshold")
    def terminated_pod_gc_threshold(self) -> int:
        return pulumi.get(self, "terminated_pod_gc_threshold")

    @property
    @pulumi.getter(name="tlsCertFile")
    def tls_cert_file(self) -> str:
        return pulumi.get(self, "tls_cert_file")

    @property
    @pulumi.getter(name="tlsCipherSuites")
    def tls_cipher_suites(self) -> Sequence[str]:
        return pulumi.get(self, "tls_cipher_suites")

    @property
    @pulumi.getter(name="tlsMinVersion")
    def tls_min_version(self) -> str:
        return pulumi.get(self, "tls_min_version")

    @property
    @pulumi.getter(name="tlsPrivateKeyFile")
    def tls_private_key_file(self) -> str:
        return pulumi.get(self, "tls_private_key_file")

    @property
    @pulumi.getter(name="useServiceAccountCredentials")
    def use_service_account_credentials(self) -> bool:
        return pulumi.get(self, "use_service_account_credentials")


@pulumi.output_type
class GetClusterKubeControllerManagerLeaderElectionResult(dict):
    def __init__(__self__, *,
                 leader_elect: bool,
                 leader_elect_lease_duration: str,
                 leader_elect_renew_deadline_duration: str,
                 leader_elect_resource_lock: str,
                 leader_elect_resource_name: str,
                 leader_elect_resource_namespace: str,
                 leader_elect_retry_period: str):
        pulumi.set(__self__, "leader_elect", leader_elect)
        pulumi.set(__self__, "leader_elect_lease_duration", leader_elect_lease_duration)
        pulumi.set(__self__, "leader_elect_renew_deadline_duration", leader_elect_renew_deadline_duration)
        pulumi.set(__self__, "leader_elect_resource_lock", leader_elect_resource_lock)
        pulumi.set(__self__, "leader_elect_resource_name", leader_elect_resource_name)
        pulumi.set(__self__, "leader_elect_resource_namespace", leader_elect_resource_namespace)
        pulumi.set(__self__, "leader_elect_retry_period", leader_elect_retry_period)

    @property
    @pulumi.getter(name="leaderElect")
    def leader_elect(self) -> bool:
        return pulumi.get(self, "leader_elect")

    @property
    @pulumi.getter(name="leaderElectLeaseDuration")
    def leader_elect_lease_duration(self) -> str:
        return pulumi.get(self, "leader_elect_lease_duration")

    @property
    @pulumi.getter(name="leaderElectRenewDeadlineDuration")
    def leader_elect_renew_deadline_duration(self) -> str:
        return pulumi.get(self, "leader_elect_renew_deadline_duration")

    @property
    @pulumi.getter(name="leaderElectResourceLock")
    def leader_elect_resource_lock(self) -> str:
        return pulumi.get(self, "leader_elect_resource_lock")

    @property
    @pulumi.getter(name="leaderElectResourceName")
    def leader_elect_resource_name(self) -> str:
        return pulumi.get(self, "leader_elect_resource_name")

    @property
    @pulumi.getter(name="leaderElectResourceNamespace")
    def leader_elect_resource_namespace(self) -> str:
        return pulumi.get(self, "leader_elect_resource_namespace")

    @property
    @pulumi.getter(name="leaderElectRetryPeriod")
    def leader_elect_retry_period(self) -> str:
        return pulumi.get(self, "leader_elect_retry_period")


@pulumi.output_type
class GetClusterKubeDnResult(dict):
    def __init__(__self__, *,
                 affinities: Sequence['outputs.GetClusterKubeDnAffinityResult'],
                 cache_max_concurrent: int,
                 cache_max_size: int,
                 core_dns_image: str,
                 cpa_image: str,
                 cpu_request: str,
                 domain: str,
                 external_core_file: str,
                 memory_limit: str,
                 memory_request: str,
                 node_local_dns: Sequence['outputs.GetClusterKubeDnNodeLocalDnResult'],
                 provider: str,
                 server_ip: str,
                 stub_domains: Sequence['outputs.GetClusterKubeDnStubDomainResult'],
                 tolerations: Sequence['outputs.GetClusterKubeDnTolerationResult'],
                 upstream_nameservers: Sequence[str]):
        pulumi.set(__self__, "affinities", affinities)
        pulumi.set(__self__, "cache_max_concurrent", cache_max_concurrent)
        pulumi.set(__self__, "cache_max_size", cache_max_size)
        pulumi.set(__self__, "core_dns_image", core_dns_image)
        pulumi.set(__self__, "cpa_image", cpa_image)
        pulumi.set(__self__, "cpu_request", cpu_request)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "external_core_file", external_core_file)
        pulumi.set(__self__, "memory_limit", memory_limit)
        pulumi.set(__self__, "memory_request", memory_request)
        pulumi.set(__self__, "node_local_dns", node_local_dns)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "server_ip", server_ip)
        pulumi.set(__self__, "stub_domains", stub_domains)
        pulumi.set(__self__, "tolerations", tolerations)
        pulumi.set(__self__, "upstream_nameservers", upstream_nameservers)

    @property
    @pulumi.getter
    def affinities(self) -> Sequence['outputs.GetClusterKubeDnAffinityResult']:
        return pulumi.get(self, "affinities")

    @property
    @pulumi.getter(name="cacheMaxConcurrent")
    def cache_max_concurrent(self) -> int:
        return pulumi.get(self, "cache_max_concurrent")

    @property
    @pulumi.getter(name="cacheMaxSize")
    def cache_max_size(self) -> int:
        return pulumi.get(self, "cache_max_size")

    @property
    @pulumi.getter(name="coreDnsImage")
    def core_dns_image(self) -> str:
        return pulumi.get(self, "core_dns_image")

    @property
    @pulumi.getter(name="cpaImage")
    def cpa_image(self) -> str:
        return pulumi.get(self, "cpa_image")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> str:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter
    def domain(self) -> str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="externalCoreFile")
    def external_core_file(self) -> str:
        return pulumi.get(self, "external_core_file")

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> str:
        return pulumi.get(self, "memory_limit")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> str:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter(name="nodeLocalDns")
    def node_local_dns(self) -> Sequence['outputs.GetClusterKubeDnNodeLocalDnResult']:
        return pulumi.get(self, "node_local_dns")

    @property
    @pulumi.getter
    def provider(self) -> str:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="serverIp")
    def server_ip(self) -> str:
        return pulumi.get(self, "server_ip")

    @property
    @pulumi.getter(name="stubDomains")
    def stub_domains(self) -> Sequence['outputs.GetClusterKubeDnStubDomainResult']:
        return pulumi.get(self, "stub_domains")

    @property
    @pulumi.getter
    def tolerations(self) -> Sequence['outputs.GetClusterKubeDnTolerationResult']:
        return pulumi.get(self, "tolerations")

    @property
    @pulumi.getter(name="upstreamNameservers")
    def upstream_nameservers(self) -> Sequence[str]:
        return pulumi.get(self, "upstream_nameservers")


@pulumi.output_type
class GetClusterKubeDnAffinityResult(dict):
    def __init__(__self__, *,
                 node_affinities: Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityResult'],
                 pod_affinities: Sequence['outputs.GetClusterKubeDnAffinityPodAffinityResult'],
                 pod_anti_affinities: Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityResult']):
        pulumi.set(__self__, "node_affinities", node_affinities)
        pulumi.set(__self__, "pod_affinities", pod_affinities)
        pulumi.set(__self__, "pod_anti_affinities", pod_anti_affinities)

    @property
    @pulumi.getter(name="nodeAffinities")
    def node_affinities(self) -> Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityResult']:
        return pulumi.get(self, "node_affinities")

    @property
    @pulumi.getter(name="podAffinities")
    def pod_affinities(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAffinityResult']:
        return pulumi.get(self, "pod_affinities")

    @property
    @pulumi.getter(name="podAntiAffinities")
    def pod_anti_affinities(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityResult']:
        return pulumi.get(self, "pod_anti_affinities")


@pulumi.output_type
class GetClusterKubeDnAffinityNodeAffinityResult(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult'],
                 required_during_scheduling_ignored_during_executions: Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult']):
        pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        pulumi.set(__self__, "required_during_scheduling_ignored_during_executions", required_during_scheduling_ignored_during_executions)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult']:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecutions")
    def required_during_scheduling_ignored_during_executions(self) -> Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_executions")


@pulumi.output_type
class GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 preferences: Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceResult'],
                 weight: int):
        pulumi.set(__self__, "preferences", preferences)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preferences(self) -> Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceResult']:
        return pulumi.get(self, "preferences")

    @property
    @pulumi.getter
    def weight(self) -> int:
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceResult(dict):
    def __init__(__self__, *,
                 match_expressions: Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionResult'],
                 match_fields: Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldResult']):
        pulumi.set(__self__, "match_expressions", match_expressions)
        pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionResult']:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldResult']:
        return pulumi.get(self, "match_fields")


@pulumi.output_type
class GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterKubeDnAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldResult(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 node_selector_terms: Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermResult']):
        pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermResult']:
        return pulumi.get(self, "node_selector_terms")


@pulumi.output_type
class GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermResult(dict):
    def __init__(__self__, *,
                 match_expressions: Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionResult'],
                 match_fields: Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchFieldResult']):
        pulumi.set(__self__, "match_expressions", match_expressions)
        pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionResult']:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Sequence['outputs.GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchFieldResult']:
        return pulumi.get(self, "match_fields")


@pulumi.output_type
class GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterKubeDnAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchFieldResult(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAffinityResult(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Sequence['outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult'],
                 required_during_scheduling_ignored_during_executions: Sequence['outputs.GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult']):
        pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        pulumi.set(__self__, "required_during_scheduling_ignored_during_executions", required_during_scheduling_ignored_during_executions)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult']:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecutions")
    def required_during_scheduling_ignored_during_executions(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_executions")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 pod_affinity_terms: Sequence['outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult'],
                 weight: int):
        pulumi.set(__self__, "pod_affinity_terms", pod_affinity_terms)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerms")
    def pod_affinity_terms(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult']:
        return pulumi.get(self, "pod_affinity_terms")

    @property
    @pulumi.getter
    def weight(self) -> int:
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult(dict):
    def __init__(__self__, *,
                 label_selectors: Sequence['outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult'],
                 namespace_selectors: Sequence['outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorResult'],
                 namespaces: Sequence[str],
                 topology_key: str):
        pulumi.set(__self__, "label_selectors", label_selectors)
        pulumi.set(__self__, "namespace_selectors", namespace_selectors)
        pulumi.set(__self__, "namespaces", namespaces)
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult']:
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter(name="namespaceSelectors")
    def namespace_selectors(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorResult']:
        return pulumi.get(self, "namespace_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Sequence[str]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Sequence['outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult'],
                 match_labels: Mapping[str, str]):
        pulumi.set(__self__, "match_expressions", match_expressions)
        pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult']:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Mapping[str, str]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Sequence['outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionResult'],
                 match_labels: Mapping[str, str]):
        pulumi.set(__self__, "match_expressions", match_expressions)
        pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionResult']:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Mapping[str, str]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 label_selectors: Sequence['outputs.GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult'],
                 namespace_selectors: Sequence['outputs.GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorResult'],
                 namespaces: Sequence[str],
                 topology_key: str):
        pulumi.set(__self__, "label_selectors", label_selectors)
        pulumi.set(__self__, "namespace_selectors", namespace_selectors)
        pulumi.set(__self__, "namespaces", namespaces)
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult']:
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter(name="namespaceSelectors")
    def namespace_selectors(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorResult']:
        return pulumi.get(self, "namespace_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Sequence[str]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Sequence['outputs.GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult'],
                 match_labels: Mapping[str, str]):
        pulumi.set(__self__, "match_expressions", match_expressions)
        pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult']:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Mapping[str, str]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Sequence['outputs.GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionResult'],
                 match_labels: Mapping[str, str]):
        pulumi.set(__self__, "match_expressions", match_expressions)
        pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionResult']:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Mapping[str, str]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAntiAffinityResult(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult'],
                 required_during_scheduling_ignored_during_executions: Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult']):
        pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        pulumi.set(__self__, "required_during_scheduling_ignored_during_executions", required_during_scheduling_ignored_during_executions)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult']:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecutions")
    def required_during_scheduling_ignored_during_executions(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_executions")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 pod_affinity_terms: Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult'],
                 weight: int):
        pulumi.set(__self__, "pod_affinity_terms", pod_affinity_terms)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerms")
    def pod_affinity_terms(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult']:
        return pulumi.get(self, "pod_affinity_terms")

    @property
    @pulumi.getter
    def weight(self) -> int:
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult(dict):
    def __init__(__self__, *,
                 label_selectors: Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult'],
                 namespace_selectors: Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorResult'],
                 namespaces: Sequence[str],
                 topology_key: str):
        pulumi.set(__self__, "label_selectors", label_selectors)
        pulumi.set(__self__, "namespace_selectors", namespace_selectors)
        pulumi.set(__self__, "namespaces", namespaces)
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult']:
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter(name="namespaceSelectors")
    def namespace_selectors(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorResult']:
        return pulumi.get(self, "namespace_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Sequence[str]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult'],
                 match_labels: Mapping[str, str]):
        pulumi.set(__self__, "match_expressions", match_expressions)
        pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult']:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Mapping[str, str]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionResult'],
                 match_labels: Mapping[str, str]):
        pulumi.set(__self__, "match_expressions", match_expressions)
        pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionResult']:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Mapping[str, str]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 label_selectors: Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult'],
                 namespace_selectors: Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorResult'],
                 namespaces: Sequence[str],
                 topology_key: str):
        pulumi.set(__self__, "label_selectors", label_selectors)
        pulumi.set(__self__, "namespace_selectors", namespace_selectors)
        pulumi.set(__self__, "namespaces", namespaces)
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult']:
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter(name="namespaceSelectors")
    def namespace_selectors(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorResult']:
        return pulumi.get(self, "namespace_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Sequence[str]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult'],
                 match_labels: Mapping[str, str]):
        pulumi.set(__self__, "match_expressions", match_expressions)
        pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult']:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Mapping[str, str]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionResult'],
                 match_labels: Mapping[str, str]):
        pulumi.set(__self__, "match_expressions", match_expressions)
        pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Sequence['outputs.GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionResult']:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Mapping[str, str]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetClusterKubeDnAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterKubeDnNodeLocalDnResult(dict):
    def __init__(__self__, *,
                 cpu_request: str,
                 enabled: bool,
                 forward_to_kube_dns: bool,
                 image: str,
                 local_ip: str,
                 memory_request: str,
                 pod_annotations: Mapping[str, str]):
        pulumi.set(__self__, "cpu_request", cpu_request)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "forward_to_kube_dns", forward_to_kube_dns)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "local_ip", local_ip)
        pulumi.set(__self__, "memory_request", memory_request)
        pulumi.set(__self__, "pod_annotations", pod_annotations)

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> str:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="forwardToKubeDns")
    def forward_to_kube_dns(self) -> bool:
        return pulumi.get(self, "forward_to_kube_dns")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="localIp")
    def local_ip(self) -> str:
        return pulumi.get(self, "local_ip")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> str:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter(name="podAnnotations")
    def pod_annotations(self) -> Mapping[str, str]:
        return pulumi.get(self, "pod_annotations")


@pulumi.output_type
class GetClusterKubeDnStubDomainResult(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterKubeDnTolerationResult(dict):
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 operator: str,
                 toleration_seconds: int,
                 value: str):
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> int:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterKubeProxyResult(dict):
    def __init__(__self__, *,
                 bind_address: str,
                 cluster_cidr: str,
                 conntrack_max_per_core: int,
                 conntrack_min: int,
                 cpu_limit: str,
                 cpu_request: str,
                 enabled: bool,
                 feature_gates: Mapping[str, str],
                 hostname_override: str,
                 image: str,
                 ip_vs_exclude_cidrs: Sequence[str],
                 ip_vs_min_sync_period: str,
                 ip_vs_scheduler: str,
                 ip_vs_sync_period: str,
                 log_level: int,
                 master: str,
                 memory_limit: str,
                 memory_request: str,
                 metrics_bind_address: str,
                 proxy_mode: str):
        pulumi.set(__self__, "bind_address", bind_address)
        pulumi.set(__self__, "cluster_cidr", cluster_cidr)
        pulumi.set(__self__, "conntrack_max_per_core", conntrack_max_per_core)
        pulumi.set(__self__, "conntrack_min", conntrack_min)
        pulumi.set(__self__, "cpu_limit", cpu_limit)
        pulumi.set(__self__, "cpu_request", cpu_request)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "feature_gates", feature_gates)
        pulumi.set(__self__, "hostname_override", hostname_override)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "ip_vs_exclude_cidrs", ip_vs_exclude_cidrs)
        pulumi.set(__self__, "ip_vs_min_sync_period", ip_vs_min_sync_period)
        pulumi.set(__self__, "ip_vs_scheduler", ip_vs_scheduler)
        pulumi.set(__self__, "ip_vs_sync_period", ip_vs_sync_period)
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "memory_limit", memory_limit)
        pulumi.set(__self__, "memory_request", memory_request)
        pulumi.set(__self__, "metrics_bind_address", metrics_bind_address)
        pulumi.set(__self__, "proxy_mode", proxy_mode)

    @property
    @pulumi.getter(name="bindAddress")
    def bind_address(self) -> str:
        return pulumi.get(self, "bind_address")

    @property
    @pulumi.getter(name="clusterCidr")
    def cluster_cidr(self) -> str:
        return pulumi.get(self, "cluster_cidr")

    @property
    @pulumi.getter(name="conntrackMaxPerCore")
    def conntrack_max_per_core(self) -> int:
        return pulumi.get(self, "conntrack_max_per_core")

    @property
    @pulumi.getter(name="conntrackMin")
    def conntrack_min(self) -> int:
        return pulumi.get(self, "conntrack_min")

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> str:
        return pulumi.get(self, "cpu_limit")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> str:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Mapping[str, str]:
        return pulumi.get(self, "feature_gates")

    @property
    @pulumi.getter(name="hostnameOverride")
    def hostname_override(self) -> str:
        return pulumi.get(self, "hostname_override")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="ipVsExcludeCidrs")
    def ip_vs_exclude_cidrs(self) -> Sequence[str]:
        return pulumi.get(self, "ip_vs_exclude_cidrs")

    @property
    @pulumi.getter(name="ipVsMinSyncPeriod")
    def ip_vs_min_sync_period(self) -> str:
        return pulumi.get(self, "ip_vs_min_sync_period")

    @property
    @pulumi.getter(name="ipVsScheduler")
    def ip_vs_scheduler(self) -> str:
        return pulumi.get(self, "ip_vs_scheduler")

    @property
    @pulumi.getter(name="ipVsSyncPeriod")
    def ip_vs_sync_period(self) -> str:
        return pulumi.get(self, "ip_vs_sync_period")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> int:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter
    def master(self) -> str:
        return pulumi.get(self, "master")

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> str:
        return pulumi.get(self, "memory_limit")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> str:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter(name="metricsBindAddress")
    def metrics_bind_address(self) -> str:
        return pulumi.get(self, "metrics_bind_address")

    @property
    @pulumi.getter(name="proxyMode")
    def proxy_mode(self) -> str:
        return pulumi.get(self, "proxy_mode")


@pulumi.output_type
class GetClusterKubeSchedulerResult(dict):
    def __init__(__self__, *,
                 authentication_kubeconfig: str,
                 authorization_always_allow_paths: Sequence[str],
                 authorization_kubeconfig: str,
                 burst: int,
                 enable_profiling: bool,
                 feature_gates: Mapping[str, str],
                 image: str,
                 leader_elections: Sequence['outputs.GetClusterKubeSchedulerLeaderElectionResult'],
                 log_format: str,
                 log_level: int,
                 master: str,
                 max_persistent_volumes: int,
                 qps: str,
                 tls_cert_file: str,
                 tls_private_key_file: str,
                 use_policy_config_map: bool):
        pulumi.set(__self__, "authentication_kubeconfig", authentication_kubeconfig)
        pulumi.set(__self__, "authorization_always_allow_paths", authorization_always_allow_paths)
        pulumi.set(__self__, "authorization_kubeconfig", authorization_kubeconfig)
        pulumi.set(__self__, "burst", burst)
        pulumi.set(__self__, "enable_profiling", enable_profiling)
        pulumi.set(__self__, "feature_gates", feature_gates)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "leader_elections", leader_elections)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "master", master)
        pulumi.set(__self__, "max_persistent_volumes", max_persistent_volumes)
        pulumi.set(__self__, "qps", qps)
        pulumi.set(__self__, "tls_cert_file", tls_cert_file)
        pulumi.set(__self__, "tls_private_key_file", tls_private_key_file)
        pulumi.set(__self__, "use_policy_config_map", use_policy_config_map)

    @property
    @pulumi.getter(name="authenticationKubeconfig")
    def authentication_kubeconfig(self) -> str:
        return pulumi.get(self, "authentication_kubeconfig")

    @property
    @pulumi.getter(name="authorizationAlwaysAllowPaths")
    def authorization_always_allow_paths(self) -> Sequence[str]:
        return pulumi.get(self, "authorization_always_allow_paths")

    @property
    @pulumi.getter(name="authorizationKubeconfig")
    def authorization_kubeconfig(self) -> str:
        return pulumi.get(self, "authorization_kubeconfig")

    @property
    @pulumi.getter
    def burst(self) -> int:
        return pulumi.get(self, "burst")

    @property
    @pulumi.getter(name="enableProfiling")
    def enable_profiling(self) -> bool:
        return pulumi.get(self, "enable_profiling")

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Mapping[str, str]:
        return pulumi.get(self, "feature_gates")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="leaderElections")
    def leader_elections(self) -> Sequence['outputs.GetClusterKubeSchedulerLeaderElectionResult']:
        return pulumi.get(self, "leader_elections")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> str:
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> int:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter
    def master(self) -> str:
        return pulumi.get(self, "master")

    @property
    @pulumi.getter(name="maxPersistentVolumes")
    def max_persistent_volumes(self) -> int:
        return pulumi.get(self, "max_persistent_volumes")

    @property
    @pulumi.getter
    def qps(self) -> str:
        return pulumi.get(self, "qps")

    @property
    @pulumi.getter(name="tlsCertFile")
    def tls_cert_file(self) -> str:
        return pulumi.get(self, "tls_cert_file")

    @property
    @pulumi.getter(name="tlsPrivateKeyFile")
    def tls_private_key_file(self) -> str:
        return pulumi.get(self, "tls_private_key_file")

    @property
    @pulumi.getter(name="usePolicyConfigMap")
    def use_policy_config_map(self) -> bool:
        return pulumi.get(self, "use_policy_config_map")


@pulumi.output_type
class GetClusterKubeSchedulerLeaderElectionResult(dict):
    def __init__(__self__, *,
                 leader_elect: bool,
                 leader_elect_lease_duration: str,
                 leader_elect_renew_deadline_duration: str,
                 leader_elect_resource_lock: str,
                 leader_elect_resource_name: str,
                 leader_elect_resource_namespace: str,
                 leader_elect_retry_period: str):
        pulumi.set(__self__, "leader_elect", leader_elect)
        pulumi.set(__self__, "leader_elect_lease_duration", leader_elect_lease_duration)
        pulumi.set(__self__, "leader_elect_renew_deadline_duration", leader_elect_renew_deadline_duration)
        pulumi.set(__self__, "leader_elect_resource_lock", leader_elect_resource_lock)
        pulumi.set(__self__, "leader_elect_resource_name", leader_elect_resource_name)
        pulumi.set(__self__, "leader_elect_resource_namespace", leader_elect_resource_namespace)
        pulumi.set(__self__, "leader_elect_retry_period", leader_elect_retry_period)

    @property
    @pulumi.getter(name="leaderElect")
    def leader_elect(self) -> bool:
        return pulumi.get(self, "leader_elect")

    @property
    @pulumi.getter(name="leaderElectLeaseDuration")
    def leader_elect_lease_duration(self) -> str:
        return pulumi.get(self, "leader_elect_lease_duration")

    @property
    @pulumi.getter(name="leaderElectRenewDeadlineDuration")
    def leader_elect_renew_deadline_duration(self) -> str:
        return pulumi.get(self, "leader_elect_renew_deadline_duration")

    @property
    @pulumi.getter(name="leaderElectResourceLock")
    def leader_elect_resource_lock(self) -> str:
        return pulumi.get(self, "leader_elect_resource_lock")

    @property
    @pulumi.getter(name="leaderElectResourceName")
    def leader_elect_resource_name(self) -> str:
        return pulumi.get(self, "leader_elect_resource_name")

    @property
    @pulumi.getter(name="leaderElectResourceNamespace")
    def leader_elect_resource_namespace(self) -> str:
        return pulumi.get(self, "leader_elect_resource_namespace")

    @property
    @pulumi.getter(name="leaderElectRetryPeriod")
    def leader_elect_retry_period(self) -> str:
        return pulumi.get(self, "leader_elect_retry_period")


@pulumi.output_type
class GetClusterKubeletResult(dict):
    def __init__(__self__, *,
                 allow_privileged: bool,
                 allowed_unsafe_sysctls: Sequence[str],
                 api_servers: str,
                 authentication_token_webhook: bool,
                 authentication_token_webhook_cache_ttl: str,
                 authorization_mode: str,
                 babysit_daemons: bool,
                 bootstrap_kubeconfig: str,
                 cgroup_driver: str,
                 cgroup_root: str,
                 client_ca_file: str,
                 cloud_provider: str,
                 cluster_dns: str,
                 cluster_domain: str,
                 configure_cbr0: bool,
                 container_log_max_files: int,
                 container_log_max_size: str,
                 cpu_cfs_quota_period: str,
                 cpu_manager_policy: str,
                 docker_disable_shared_pid: bool,
                 enable_cadvisor_json_endpoints: bool,
                 enable_custom_metrics: bool,
                 enable_debugging_handlers: bool,
                 enforce_node_allocatable: str,
                 event_burst: int,
                 event_qps: int,
                 eviction_hard: str,
                 eviction_max_pod_grace_period: int,
                 eviction_minimum_reclaim: str,
                 eviction_pressure_transition_period: str,
                 eviction_soft: str,
                 eviction_soft_grace_period: str,
                 experimental_allowed_unsafe_sysctls: Sequence[str],
                 fail_swap_on: bool,
                 feature_gates: Mapping[str, str],
                 hairpin_mode: str,
                 hostname_override: str,
                 housekeeping_interval: str,
                 image_gc_high_threshold_percent: int,
                 image_gc_low_threshold_percent: int,
                 image_pull_progress_deadline: str,
                 kernel_memcg_notification: bool,
                 kube_reserved: Mapping[str, str],
                 kube_reserved_cgroup: str,
                 kubeconfig_path: str,
                 kubelet_cgroups: str,
                 log_format: str,
                 log_level: int,
                 max_pods: int,
                 network_plugin_mtu: int,
                 network_plugin_name: str,
                 node_labels: Mapping[str, str],
                 node_status_update_frequency: str,
                 non_masquerade_cidr: str,
                 nvidia_gp_us: int,
                 pod_cidr: str,
                 pod_infra_container_image: str,
                 pod_manifest_path: str,
                 pod_pids_limit: int,
                 protect_kernel_defaults: bool,
                 read_only_port: int,
                 reconcile_cidr: bool,
                 register_node: bool,
                 register_schedulable: bool,
                 registry_burst: int,
                 registry_pull_qps: int,
                 require_kubeconfig: bool,
                 resolver_config: str,
                 root_dir: str,
                 rotate_certificates: bool,
                 runtime_cgroups: str,
                 runtime_request_timeout: str,
                 seccomp_profile_root: str,
                 serialize_image_pulls: bool,
                 shutdown_grace_period: str,
                 shutdown_grace_period_critical_pods: str,
                 streaming_connection_idle_timeout: str,
                 system_cgroups: str,
                 system_reserved: Mapping[str, str],
                 system_reserved_cgroup: str,
                 taints: Sequence[str],
                 tls_cert_file: str,
                 tls_cipher_suites: Sequence[str],
                 tls_min_version: str,
                 tls_private_key_file: str,
                 topology_manager_policy: str,
                 volume_plugin_directory: str,
                 volume_stats_agg_period: str,
                 anonymous_auth: Optional['outputs.GetClusterKubeletAnonymousAuthResult'] = None,
                 cpu_cfs_quota: Optional['outputs.GetClusterKubeletCpuCfsQuotaResult'] = None):
        """
        :param str cloud_provider: - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        :param str non_masquerade_cidr: - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
        :param str pod_cidr: - String - PodCIDR is the CIDR from which we allocate IPs for pods.
        """
        pulumi.set(__self__, "allow_privileged", allow_privileged)
        pulumi.set(__self__, "allowed_unsafe_sysctls", allowed_unsafe_sysctls)
        pulumi.set(__self__, "api_servers", api_servers)
        pulumi.set(__self__, "authentication_token_webhook", authentication_token_webhook)
        pulumi.set(__self__, "authentication_token_webhook_cache_ttl", authentication_token_webhook_cache_ttl)
        pulumi.set(__self__, "authorization_mode", authorization_mode)
        pulumi.set(__self__, "babysit_daemons", babysit_daemons)
        pulumi.set(__self__, "bootstrap_kubeconfig", bootstrap_kubeconfig)
        pulumi.set(__self__, "cgroup_driver", cgroup_driver)
        pulumi.set(__self__, "cgroup_root", cgroup_root)
        pulumi.set(__self__, "client_ca_file", client_ca_file)
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "cluster_dns", cluster_dns)
        pulumi.set(__self__, "cluster_domain", cluster_domain)
        pulumi.set(__self__, "configure_cbr0", configure_cbr0)
        pulumi.set(__self__, "container_log_max_files", container_log_max_files)
        pulumi.set(__self__, "container_log_max_size", container_log_max_size)
        pulumi.set(__self__, "cpu_cfs_quota_period", cpu_cfs_quota_period)
        pulumi.set(__self__, "cpu_manager_policy", cpu_manager_policy)
        pulumi.set(__self__, "docker_disable_shared_pid", docker_disable_shared_pid)
        pulumi.set(__self__, "enable_cadvisor_json_endpoints", enable_cadvisor_json_endpoints)
        pulumi.set(__self__, "enable_custom_metrics", enable_custom_metrics)
        pulumi.set(__self__, "enable_debugging_handlers", enable_debugging_handlers)
        pulumi.set(__self__, "enforce_node_allocatable", enforce_node_allocatable)
        pulumi.set(__self__, "event_burst", event_burst)
        pulumi.set(__self__, "event_qps", event_qps)
        pulumi.set(__self__, "eviction_hard", eviction_hard)
        pulumi.set(__self__, "eviction_max_pod_grace_period", eviction_max_pod_grace_period)
        pulumi.set(__self__, "eviction_minimum_reclaim", eviction_minimum_reclaim)
        pulumi.set(__self__, "eviction_pressure_transition_period", eviction_pressure_transition_period)
        pulumi.set(__self__, "eviction_soft", eviction_soft)
        pulumi.set(__self__, "eviction_soft_grace_period", eviction_soft_grace_period)
        pulumi.set(__self__, "experimental_allowed_unsafe_sysctls", experimental_allowed_unsafe_sysctls)
        pulumi.set(__self__, "fail_swap_on", fail_swap_on)
        pulumi.set(__self__, "feature_gates", feature_gates)
        pulumi.set(__self__, "hairpin_mode", hairpin_mode)
        pulumi.set(__self__, "hostname_override", hostname_override)
        pulumi.set(__self__, "housekeeping_interval", housekeeping_interval)
        pulumi.set(__self__, "image_gc_high_threshold_percent", image_gc_high_threshold_percent)
        pulumi.set(__self__, "image_gc_low_threshold_percent", image_gc_low_threshold_percent)
        pulumi.set(__self__, "image_pull_progress_deadline", image_pull_progress_deadline)
        pulumi.set(__self__, "kernel_memcg_notification", kernel_memcg_notification)
        pulumi.set(__self__, "kube_reserved", kube_reserved)
        pulumi.set(__self__, "kube_reserved_cgroup", kube_reserved_cgroup)
        pulumi.set(__self__, "kubeconfig_path", kubeconfig_path)
        pulumi.set(__self__, "kubelet_cgroups", kubelet_cgroups)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "max_pods", max_pods)
        pulumi.set(__self__, "network_plugin_mtu", network_plugin_mtu)
        pulumi.set(__self__, "network_plugin_name", network_plugin_name)
        pulumi.set(__self__, "node_labels", node_labels)
        pulumi.set(__self__, "node_status_update_frequency", node_status_update_frequency)
        pulumi.set(__self__, "non_masquerade_cidr", non_masquerade_cidr)
        pulumi.set(__self__, "nvidia_gp_us", nvidia_gp_us)
        pulumi.set(__self__, "pod_cidr", pod_cidr)
        pulumi.set(__self__, "pod_infra_container_image", pod_infra_container_image)
        pulumi.set(__self__, "pod_manifest_path", pod_manifest_path)
        pulumi.set(__self__, "pod_pids_limit", pod_pids_limit)
        pulumi.set(__self__, "protect_kernel_defaults", protect_kernel_defaults)
        pulumi.set(__self__, "read_only_port", read_only_port)
        pulumi.set(__self__, "reconcile_cidr", reconcile_cidr)
        pulumi.set(__self__, "register_node", register_node)
        pulumi.set(__self__, "register_schedulable", register_schedulable)
        pulumi.set(__self__, "registry_burst", registry_burst)
        pulumi.set(__self__, "registry_pull_qps", registry_pull_qps)
        pulumi.set(__self__, "require_kubeconfig", require_kubeconfig)
        pulumi.set(__self__, "resolver_config", resolver_config)
        pulumi.set(__self__, "root_dir", root_dir)
        pulumi.set(__self__, "rotate_certificates", rotate_certificates)
        pulumi.set(__self__, "runtime_cgroups", runtime_cgroups)
        pulumi.set(__self__, "runtime_request_timeout", runtime_request_timeout)
        pulumi.set(__self__, "seccomp_profile_root", seccomp_profile_root)
        pulumi.set(__self__, "serialize_image_pulls", serialize_image_pulls)
        pulumi.set(__self__, "shutdown_grace_period", shutdown_grace_period)
        pulumi.set(__self__, "shutdown_grace_period_critical_pods", shutdown_grace_period_critical_pods)
        pulumi.set(__self__, "streaming_connection_idle_timeout", streaming_connection_idle_timeout)
        pulumi.set(__self__, "system_cgroups", system_cgroups)
        pulumi.set(__self__, "system_reserved", system_reserved)
        pulumi.set(__self__, "system_reserved_cgroup", system_reserved_cgroup)
        pulumi.set(__self__, "taints", taints)
        pulumi.set(__self__, "tls_cert_file", tls_cert_file)
        pulumi.set(__self__, "tls_cipher_suites", tls_cipher_suites)
        pulumi.set(__self__, "tls_min_version", tls_min_version)
        pulumi.set(__self__, "tls_private_key_file", tls_private_key_file)
        pulumi.set(__self__, "topology_manager_policy", topology_manager_policy)
        pulumi.set(__self__, "volume_plugin_directory", volume_plugin_directory)
        pulumi.set(__self__, "volume_stats_agg_period", volume_stats_agg_period)
        if anonymous_auth is not None:
            pulumi.set(__self__, "anonymous_auth", anonymous_auth)
        if cpu_cfs_quota is not None:
            pulumi.set(__self__, "cpu_cfs_quota", cpu_cfs_quota)

    @property
    @pulumi.getter(name="allowPrivileged")
    def allow_privileged(self) -> bool:
        return pulumi.get(self, "allow_privileged")

    @property
    @pulumi.getter(name="allowedUnsafeSysctls")
    def allowed_unsafe_sysctls(self) -> Sequence[str]:
        return pulumi.get(self, "allowed_unsafe_sysctls")

    @property
    @pulumi.getter(name="apiServers")
    def api_servers(self) -> str:
        return pulumi.get(self, "api_servers")

    @property
    @pulumi.getter(name="authenticationTokenWebhook")
    def authentication_token_webhook(self) -> bool:
        return pulumi.get(self, "authentication_token_webhook")

    @property
    @pulumi.getter(name="authenticationTokenWebhookCacheTtl")
    def authentication_token_webhook_cache_ttl(self) -> str:
        return pulumi.get(self, "authentication_token_webhook_cache_ttl")

    @property
    @pulumi.getter(name="authorizationMode")
    def authorization_mode(self) -> str:
        return pulumi.get(self, "authorization_mode")

    @property
    @pulumi.getter(name="babysitDaemons")
    def babysit_daemons(self) -> bool:
        return pulumi.get(self, "babysit_daemons")

    @property
    @pulumi.getter(name="bootstrapKubeconfig")
    def bootstrap_kubeconfig(self) -> str:
        return pulumi.get(self, "bootstrap_kubeconfig")

    @property
    @pulumi.getter(name="cgroupDriver")
    def cgroup_driver(self) -> str:
        return pulumi.get(self, "cgroup_driver")

    @property
    @pulumi.getter(name="cgroupRoot")
    def cgroup_root(self) -> str:
        return pulumi.get(self, "cgroup_root")

    @property
    @pulumi.getter(name="clientCaFile")
    def client_ca_file(self) -> str:
        return pulumi.get(self, "client_ca_file")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="clusterDns")
    def cluster_dns(self) -> str:
        return pulumi.get(self, "cluster_dns")

    @property
    @pulumi.getter(name="clusterDomain")
    def cluster_domain(self) -> str:
        return pulumi.get(self, "cluster_domain")

    @property
    @pulumi.getter(name="configureCbr0")
    def configure_cbr0(self) -> bool:
        return pulumi.get(self, "configure_cbr0")

    @property
    @pulumi.getter(name="containerLogMaxFiles")
    def container_log_max_files(self) -> int:
        return pulumi.get(self, "container_log_max_files")

    @property
    @pulumi.getter(name="containerLogMaxSize")
    def container_log_max_size(self) -> str:
        return pulumi.get(self, "container_log_max_size")

    @property
    @pulumi.getter(name="cpuCfsQuotaPeriod")
    def cpu_cfs_quota_period(self) -> str:
        return pulumi.get(self, "cpu_cfs_quota_period")

    @property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> str:
        return pulumi.get(self, "cpu_manager_policy")

    @property
    @pulumi.getter(name="dockerDisableSharedPid")
    def docker_disable_shared_pid(self) -> bool:
        return pulumi.get(self, "docker_disable_shared_pid")

    @property
    @pulumi.getter(name="enableCadvisorJsonEndpoints")
    def enable_cadvisor_json_endpoints(self) -> bool:
        return pulumi.get(self, "enable_cadvisor_json_endpoints")

    @property
    @pulumi.getter(name="enableCustomMetrics")
    def enable_custom_metrics(self) -> bool:
        return pulumi.get(self, "enable_custom_metrics")

    @property
    @pulumi.getter(name="enableDebuggingHandlers")
    def enable_debugging_handlers(self) -> bool:
        return pulumi.get(self, "enable_debugging_handlers")

    @property
    @pulumi.getter(name="enforceNodeAllocatable")
    def enforce_node_allocatable(self) -> str:
        return pulumi.get(self, "enforce_node_allocatable")

    @property
    @pulumi.getter(name="eventBurst")
    def event_burst(self) -> int:
        return pulumi.get(self, "event_burst")

    @property
    @pulumi.getter(name="eventQps")
    def event_qps(self) -> int:
        return pulumi.get(self, "event_qps")

    @property
    @pulumi.getter(name="evictionHard")
    def eviction_hard(self) -> str:
        return pulumi.get(self, "eviction_hard")

    @property
    @pulumi.getter(name="evictionMaxPodGracePeriod")
    def eviction_max_pod_grace_period(self) -> int:
        return pulumi.get(self, "eviction_max_pod_grace_period")

    @property
    @pulumi.getter(name="evictionMinimumReclaim")
    def eviction_minimum_reclaim(self) -> str:
        return pulumi.get(self, "eviction_minimum_reclaim")

    @property
    @pulumi.getter(name="evictionPressureTransitionPeriod")
    def eviction_pressure_transition_period(self) -> str:
        return pulumi.get(self, "eviction_pressure_transition_period")

    @property
    @pulumi.getter(name="evictionSoft")
    def eviction_soft(self) -> str:
        return pulumi.get(self, "eviction_soft")

    @property
    @pulumi.getter(name="evictionSoftGracePeriod")
    def eviction_soft_grace_period(self) -> str:
        return pulumi.get(self, "eviction_soft_grace_period")

    @property
    @pulumi.getter(name="experimentalAllowedUnsafeSysctls")
    def experimental_allowed_unsafe_sysctls(self) -> Sequence[str]:
        return pulumi.get(self, "experimental_allowed_unsafe_sysctls")

    @property
    @pulumi.getter(name="failSwapOn")
    def fail_swap_on(self) -> bool:
        return pulumi.get(self, "fail_swap_on")

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Mapping[str, str]:
        return pulumi.get(self, "feature_gates")

    @property
    @pulumi.getter(name="hairpinMode")
    def hairpin_mode(self) -> str:
        return pulumi.get(self, "hairpin_mode")

    @property
    @pulumi.getter(name="hostnameOverride")
    def hostname_override(self) -> str:
        return pulumi.get(self, "hostname_override")

    @property
    @pulumi.getter(name="housekeepingInterval")
    def housekeeping_interval(self) -> str:
        return pulumi.get(self, "housekeeping_interval")

    @property
    @pulumi.getter(name="imageGcHighThresholdPercent")
    def image_gc_high_threshold_percent(self) -> int:
        return pulumi.get(self, "image_gc_high_threshold_percent")

    @property
    @pulumi.getter(name="imageGcLowThresholdPercent")
    def image_gc_low_threshold_percent(self) -> int:
        return pulumi.get(self, "image_gc_low_threshold_percent")

    @property
    @pulumi.getter(name="imagePullProgressDeadline")
    def image_pull_progress_deadline(self) -> str:
        return pulumi.get(self, "image_pull_progress_deadline")

    @property
    @pulumi.getter(name="kernelMemcgNotification")
    def kernel_memcg_notification(self) -> bool:
        return pulumi.get(self, "kernel_memcg_notification")

    @property
    @pulumi.getter(name="kubeReserved")
    def kube_reserved(self) -> Mapping[str, str]:
        return pulumi.get(self, "kube_reserved")

    @property
    @pulumi.getter(name="kubeReservedCgroup")
    def kube_reserved_cgroup(self) -> str:
        return pulumi.get(self, "kube_reserved_cgroup")

    @property
    @pulumi.getter(name="kubeconfigPath")
    def kubeconfig_path(self) -> str:
        return pulumi.get(self, "kubeconfig_path")

    @property
    @pulumi.getter(name="kubeletCgroups")
    def kubelet_cgroups(self) -> str:
        return pulumi.get(self, "kubelet_cgroups")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> str:
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> int:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> int:
        return pulumi.get(self, "max_pods")

    @property
    @pulumi.getter(name="networkPluginMtu")
    def network_plugin_mtu(self) -> int:
        return pulumi.get(self, "network_plugin_mtu")

    @property
    @pulumi.getter(name="networkPluginName")
    def network_plugin_name(self) -> str:
        return pulumi.get(self, "network_plugin_name")

    @property
    @pulumi.getter(name="nodeLabels")
    def node_labels(self) -> Mapping[str, str]:
        return pulumi.get(self, "node_labels")

    @property
    @pulumi.getter(name="nodeStatusUpdateFrequency")
    def node_status_update_frequency(self) -> str:
        return pulumi.get(self, "node_status_update_frequency")

    @property
    @pulumi.getter(name="nonMasqueradeCidr")
    def non_masquerade_cidr(self) -> str:
        """
        - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
        """
        return pulumi.get(self, "non_masquerade_cidr")

    @property
    @pulumi.getter(name="nvidiaGpUs")
    def nvidia_gp_us(self) -> int:
        return pulumi.get(self, "nvidia_gp_us")

    @property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> str:
        """
        - String - PodCIDR is the CIDR from which we allocate IPs for pods.
        """
        return pulumi.get(self, "pod_cidr")

    @property
    @pulumi.getter(name="podInfraContainerImage")
    def pod_infra_container_image(self) -> str:
        return pulumi.get(self, "pod_infra_container_image")

    @property
    @pulumi.getter(name="podManifestPath")
    def pod_manifest_path(self) -> str:
        return pulumi.get(self, "pod_manifest_path")

    @property
    @pulumi.getter(name="podPidsLimit")
    def pod_pids_limit(self) -> int:
        return pulumi.get(self, "pod_pids_limit")

    @property
    @pulumi.getter(name="protectKernelDefaults")
    def protect_kernel_defaults(self) -> bool:
        return pulumi.get(self, "protect_kernel_defaults")

    @property
    @pulumi.getter(name="readOnlyPort")
    def read_only_port(self) -> int:
        return pulumi.get(self, "read_only_port")

    @property
    @pulumi.getter(name="reconcileCidr")
    def reconcile_cidr(self) -> bool:
        return pulumi.get(self, "reconcile_cidr")

    @property
    @pulumi.getter(name="registerNode")
    def register_node(self) -> bool:
        return pulumi.get(self, "register_node")

    @property
    @pulumi.getter(name="registerSchedulable")
    def register_schedulable(self) -> bool:
        return pulumi.get(self, "register_schedulable")

    @property
    @pulumi.getter(name="registryBurst")
    def registry_burst(self) -> int:
        return pulumi.get(self, "registry_burst")

    @property
    @pulumi.getter(name="registryPullQps")
    def registry_pull_qps(self) -> int:
        return pulumi.get(self, "registry_pull_qps")

    @property
    @pulumi.getter(name="requireKubeconfig")
    def require_kubeconfig(self) -> bool:
        return pulumi.get(self, "require_kubeconfig")

    @property
    @pulumi.getter(name="resolverConfig")
    def resolver_config(self) -> str:
        return pulumi.get(self, "resolver_config")

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> str:
        return pulumi.get(self, "root_dir")

    @property
    @pulumi.getter(name="rotateCertificates")
    def rotate_certificates(self) -> bool:
        return pulumi.get(self, "rotate_certificates")

    @property
    @pulumi.getter(name="runtimeCgroups")
    def runtime_cgroups(self) -> str:
        return pulumi.get(self, "runtime_cgroups")

    @property
    @pulumi.getter(name="runtimeRequestTimeout")
    def runtime_request_timeout(self) -> str:
        return pulumi.get(self, "runtime_request_timeout")

    @property
    @pulumi.getter(name="seccompProfileRoot")
    def seccomp_profile_root(self) -> str:
        return pulumi.get(self, "seccomp_profile_root")

    @property
    @pulumi.getter(name="serializeImagePulls")
    def serialize_image_pulls(self) -> bool:
        return pulumi.get(self, "serialize_image_pulls")

    @property
    @pulumi.getter(name="shutdownGracePeriod")
    def shutdown_grace_period(self) -> str:
        return pulumi.get(self, "shutdown_grace_period")

    @property
    @pulumi.getter(name="shutdownGracePeriodCriticalPods")
    def shutdown_grace_period_critical_pods(self) -> str:
        return pulumi.get(self, "shutdown_grace_period_critical_pods")

    @property
    @pulumi.getter(name="streamingConnectionIdleTimeout")
    def streaming_connection_idle_timeout(self) -> str:
        return pulumi.get(self, "streaming_connection_idle_timeout")

    @property
    @pulumi.getter(name="systemCgroups")
    def system_cgroups(self) -> str:
        return pulumi.get(self, "system_cgroups")

    @property
    @pulumi.getter(name="systemReserved")
    def system_reserved(self) -> Mapping[str, str]:
        return pulumi.get(self, "system_reserved")

    @property
    @pulumi.getter(name="systemReservedCgroup")
    def system_reserved_cgroup(self) -> str:
        return pulumi.get(self, "system_reserved_cgroup")

    @property
    @pulumi.getter
    def taints(self) -> Sequence[str]:
        return pulumi.get(self, "taints")

    @property
    @pulumi.getter(name="tlsCertFile")
    def tls_cert_file(self) -> str:
        return pulumi.get(self, "tls_cert_file")

    @property
    @pulumi.getter(name="tlsCipherSuites")
    def tls_cipher_suites(self) -> Sequence[str]:
        return pulumi.get(self, "tls_cipher_suites")

    @property
    @pulumi.getter(name="tlsMinVersion")
    def tls_min_version(self) -> str:
        return pulumi.get(self, "tls_min_version")

    @property
    @pulumi.getter(name="tlsPrivateKeyFile")
    def tls_private_key_file(self) -> str:
        return pulumi.get(self, "tls_private_key_file")

    @property
    @pulumi.getter(name="topologyManagerPolicy")
    def topology_manager_policy(self) -> str:
        return pulumi.get(self, "topology_manager_policy")

    @property
    @pulumi.getter(name="volumePluginDirectory")
    def volume_plugin_directory(self) -> str:
        return pulumi.get(self, "volume_plugin_directory")

    @property
    @pulumi.getter(name="volumeStatsAggPeriod")
    def volume_stats_agg_period(self) -> str:
        return pulumi.get(self, "volume_stats_agg_period")

    @property
    @pulumi.getter(name="anonymousAuth")
    def anonymous_auth(self) -> Optional['outputs.GetClusterKubeletAnonymousAuthResult']:
        return pulumi.get(self, "anonymous_auth")

    @property
    @pulumi.getter(name="cpuCfsQuota")
    def cpu_cfs_quota(self) -> Optional['outputs.GetClusterKubeletCpuCfsQuotaResult']:
        return pulumi.get(self, "cpu_cfs_quota")


@pulumi.output_type
class GetClusterKubeletAnonymousAuthResult(dict):
    def __init__(__self__, *,
                 value: bool):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterKubeletCpuCfsQuotaResult(dict):
    def __init__(__self__, *,
                 value: bool):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterMasterKubeletResult(dict):
    def __init__(__self__, *,
                 allow_privileged: bool,
                 allowed_unsafe_sysctls: Sequence[str],
                 api_servers: str,
                 authentication_token_webhook: bool,
                 authentication_token_webhook_cache_ttl: str,
                 authorization_mode: str,
                 babysit_daemons: bool,
                 bootstrap_kubeconfig: str,
                 cgroup_driver: str,
                 cgroup_root: str,
                 client_ca_file: str,
                 cloud_provider: str,
                 cluster_dns: str,
                 cluster_domain: str,
                 configure_cbr0: bool,
                 container_log_max_files: int,
                 container_log_max_size: str,
                 cpu_cfs_quota_period: str,
                 cpu_manager_policy: str,
                 docker_disable_shared_pid: bool,
                 enable_cadvisor_json_endpoints: bool,
                 enable_custom_metrics: bool,
                 enable_debugging_handlers: bool,
                 enforce_node_allocatable: str,
                 event_burst: int,
                 event_qps: int,
                 eviction_hard: str,
                 eviction_max_pod_grace_period: int,
                 eviction_minimum_reclaim: str,
                 eviction_pressure_transition_period: str,
                 eviction_soft: str,
                 eviction_soft_grace_period: str,
                 experimental_allowed_unsafe_sysctls: Sequence[str],
                 fail_swap_on: bool,
                 feature_gates: Mapping[str, str],
                 hairpin_mode: str,
                 hostname_override: str,
                 housekeeping_interval: str,
                 image_gc_high_threshold_percent: int,
                 image_gc_low_threshold_percent: int,
                 image_pull_progress_deadline: str,
                 kernel_memcg_notification: bool,
                 kube_reserved: Mapping[str, str],
                 kube_reserved_cgroup: str,
                 kubeconfig_path: str,
                 kubelet_cgroups: str,
                 log_format: str,
                 log_level: int,
                 max_pods: int,
                 network_plugin_mtu: int,
                 network_plugin_name: str,
                 node_labels: Mapping[str, str],
                 node_status_update_frequency: str,
                 non_masquerade_cidr: str,
                 nvidia_gp_us: int,
                 pod_cidr: str,
                 pod_infra_container_image: str,
                 pod_manifest_path: str,
                 pod_pids_limit: int,
                 protect_kernel_defaults: bool,
                 read_only_port: int,
                 reconcile_cidr: bool,
                 register_node: bool,
                 register_schedulable: bool,
                 registry_burst: int,
                 registry_pull_qps: int,
                 require_kubeconfig: bool,
                 resolver_config: str,
                 root_dir: str,
                 rotate_certificates: bool,
                 runtime_cgroups: str,
                 runtime_request_timeout: str,
                 seccomp_profile_root: str,
                 serialize_image_pulls: bool,
                 shutdown_grace_period: str,
                 shutdown_grace_period_critical_pods: str,
                 streaming_connection_idle_timeout: str,
                 system_cgroups: str,
                 system_reserved: Mapping[str, str],
                 system_reserved_cgroup: str,
                 taints: Sequence[str],
                 tls_cert_file: str,
                 tls_cipher_suites: Sequence[str],
                 tls_min_version: str,
                 tls_private_key_file: str,
                 topology_manager_policy: str,
                 volume_plugin_directory: str,
                 volume_stats_agg_period: str,
                 anonymous_auth: Optional['outputs.GetClusterMasterKubeletAnonymousAuthResult'] = None,
                 cpu_cfs_quota: Optional['outputs.GetClusterMasterKubeletCpuCfsQuotaResult'] = None):
        """
        :param str cloud_provider: - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        :param str non_masquerade_cidr: - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
        :param str pod_cidr: - String - PodCIDR is the CIDR from which we allocate IPs for pods.
        """
        pulumi.set(__self__, "allow_privileged", allow_privileged)
        pulumi.set(__self__, "allowed_unsafe_sysctls", allowed_unsafe_sysctls)
        pulumi.set(__self__, "api_servers", api_servers)
        pulumi.set(__self__, "authentication_token_webhook", authentication_token_webhook)
        pulumi.set(__self__, "authentication_token_webhook_cache_ttl", authentication_token_webhook_cache_ttl)
        pulumi.set(__self__, "authorization_mode", authorization_mode)
        pulumi.set(__self__, "babysit_daemons", babysit_daemons)
        pulumi.set(__self__, "bootstrap_kubeconfig", bootstrap_kubeconfig)
        pulumi.set(__self__, "cgroup_driver", cgroup_driver)
        pulumi.set(__self__, "cgroup_root", cgroup_root)
        pulumi.set(__self__, "client_ca_file", client_ca_file)
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "cluster_dns", cluster_dns)
        pulumi.set(__self__, "cluster_domain", cluster_domain)
        pulumi.set(__self__, "configure_cbr0", configure_cbr0)
        pulumi.set(__self__, "container_log_max_files", container_log_max_files)
        pulumi.set(__self__, "container_log_max_size", container_log_max_size)
        pulumi.set(__self__, "cpu_cfs_quota_period", cpu_cfs_quota_period)
        pulumi.set(__self__, "cpu_manager_policy", cpu_manager_policy)
        pulumi.set(__self__, "docker_disable_shared_pid", docker_disable_shared_pid)
        pulumi.set(__self__, "enable_cadvisor_json_endpoints", enable_cadvisor_json_endpoints)
        pulumi.set(__self__, "enable_custom_metrics", enable_custom_metrics)
        pulumi.set(__self__, "enable_debugging_handlers", enable_debugging_handlers)
        pulumi.set(__self__, "enforce_node_allocatable", enforce_node_allocatable)
        pulumi.set(__self__, "event_burst", event_burst)
        pulumi.set(__self__, "event_qps", event_qps)
        pulumi.set(__self__, "eviction_hard", eviction_hard)
        pulumi.set(__self__, "eviction_max_pod_grace_period", eviction_max_pod_grace_period)
        pulumi.set(__self__, "eviction_minimum_reclaim", eviction_minimum_reclaim)
        pulumi.set(__self__, "eviction_pressure_transition_period", eviction_pressure_transition_period)
        pulumi.set(__self__, "eviction_soft", eviction_soft)
        pulumi.set(__self__, "eviction_soft_grace_period", eviction_soft_grace_period)
        pulumi.set(__self__, "experimental_allowed_unsafe_sysctls", experimental_allowed_unsafe_sysctls)
        pulumi.set(__self__, "fail_swap_on", fail_swap_on)
        pulumi.set(__self__, "feature_gates", feature_gates)
        pulumi.set(__self__, "hairpin_mode", hairpin_mode)
        pulumi.set(__self__, "hostname_override", hostname_override)
        pulumi.set(__self__, "housekeeping_interval", housekeeping_interval)
        pulumi.set(__self__, "image_gc_high_threshold_percent", image_gc_high_threshold_percent)
        pulumi.set(__self__, "image_gc_low_threshold_percent", image_gc_low_threshold_percent)
        pulumi.set(__self__, "image_pull_progress_deadline", image_pull_progress_deadline)
        pulumi.set(__self__, "kernel_memcg_notification", kernel_memcg_notification)
        pulumi.set(__self__, "kube_reserved", kube_reserved)
        pulumi.set(__self__, "kube_reserved_cgroup", kube_reserved_cgroup)
        pulumi.set(__self__, "kubeconfig_path", kubeconfig_path)
        pulumi.set(__self__, "kubelet_cgroups", kubelet_cgroups)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "max_pods", max_pods)
        pulumi.set(__self__, "network_plugin_mtu", network_plugin_mtu)
        pulumi.set(__self__, "network_plugin_name", network_plugin_name)
        pulumi.set(__self__, "node_labels", node_labels)
        pulumi.set(__self__, "node_status_update_frequency", node_status_update_frequency)
        pulumi.set(__self__, "non_masquerade_cidr", non_masquerade_cidr)
        pulumi.set(__self__, "nvidia_gp_us", nvidia_gp_us)
        pulumi.set(__self__, "pod_cidr", pod_cidr)
        pulumi.set(__self__, "pod_infra_container_image", pod_infra_container_image)
        pulumi.set(__self__, "pod_manifest_path", pod_manifest_path)
        pulumi.set(__self__, "pod_pids_limit", pod_pids_limit)
        pulumi.set(__self__, "protect_kernel_defaults", protect_kernel_defaults)
        pulumi.set(__self__, "read_only_port", read_only_port)
        pulumi.set(__self__, "reconcile_cidr", reconcile_cidr)
        pulumi.set(__self__, "register_node", register_node)
        pulumi.set(__self__, "register_schedulable", register_schedulable)
        pulumi.set(__self__, "registry_burst", registry_burst)
        pulumi.set(__self__, "registry_pull_qps", registry_pull_qps)
        pulumi.set(__self__, "require_kubeconfig", require_kubeconfig)
        pulumi.set(__self__, "resolver_config", resolver_config)
        pulumi.set(__self__, "root_dir", root_dir)
        pulumi.set(__self__, "rotate_certificates", rotate_certificates)
        pulumi.set(__self__, "runtime_cgroups", runtime_cgroups)
        pulumi.set(__self__, "runtime_request_timeout", runtime_request_timeout)
        pulumi.set(__self__, "seccomp_profile_root", seccomp_profile_root)
        pulumi.set(__self__, "serialize_image_pulls", serialize_image_pulls)
        pulumi.set(__self__, "shutdown_grace_period", shutdown_grace_period)
        pulumi.set(__self__, "shutdown_grace_period_critical_pods", shutdown_grace_period_critical_pods)
        pulumi.set(__self__, "streaming_connection_idle_timeout", streaming_connection_idle_timeout)
        pulumi.set(__self__, "system_cgroups", system_cgroups)
        pulumi.set(__self__, "system_reserved", system_reserved)
        pulumi.set(__self__, "system_reserved_cgroup", system_reserved_cgroup)
        pulumi.set(__self__, "taints", taints)
        pulumi.set(__self__, "tls_cert_file", tls_cert_file)
        pulumi.set(__self__, "tls_cipher_suites", tls_cipher_suites)
        pulumi.set(__self__, "tls_min_version", tls_min_version)
        pulumi.set(__self__, "tls_private_key_file", tls_private_key_file)
        pulumi.set(__self__, "topology_manager_policy", topology_manager_policy)
        pulumi.set(__self__, "volume_plugin_directory", volume_plugin_directory)
        pulumi.set(__self__, "volume_stats_agg_period", volume_stats_agg_period)
        if anonymous_auth is not None:
            pulumi.set(__self__, "anonymous_auth", anonymous_auth)
        if cpu_cfs_quota is not None:
            pulumi.set(__self__, "cpu_cfs_quota", cpu_cfs_quota)

    @property
    @pulumi.getter(name="allowPrivileged")
    def allow_privileged(self) -> bool:
        return pulumi.get(self, "allow_privileged")

    @property
    @pulumi.getter(name="allowedUnsafeSysctls")
    def allowed_unsafe_sysctls(self) -> Sequence[str]:
        return pulumi.get(self, "allowed_unsafe_sysctls")

    @property
    @pulumi.getter(name="apiServers")
    def api_servers(self) -> str:
        return pulumi.get(self, "api_servers")

    @property
    @pulumi.getter(name="authenticationTokenWebhook")
    def authentication_token_webhook(self) -> bool:
        return pulumi.get(self, "authentication_token_webhook")

    @property
    @pulumi.getter(name="authenticationTokenWebhookCacheTtl")
    def authentication_token_webhook_cache_ttl(self) -> str:
        return pulumi.get(self, "authentication_token_webhook_cache_ttl")

    @property
    @pulumi.getter(name="authorizationMode")
    def authorization_mode(self) -> str:
        return pulumi.get(self, "authorization_mode")

    @property
    @pulumi.getter(name="babysitDaemons")
    def babysit_daemons(self) -> bool:
        return pulumi.get(self, "babysit_daemons")

    @property
    @pulumi.getter(name="bootstrapKubeconfig")
    def bootstrap_kubeconfig(self) -> str:
        return pulumi.get(self, "bootstrap_kubeconfig")

    @property
    @pulumi.getter(name="cgroupDriver")
    def cgroup_driver(self) -> str:
        return pulumi.get(self, "cgroup_driver")

    @property
    @pulumi.getter(name="cgroupRoot")
    def cgroup_root(self) -> str:
        return pulumi.get(self, "cgroup_root")

    @property
    @pulumi.getter(name="clientCaFile")
    def client_ca_file(self) -> str:
        return pulumi.get(self, "client_ca_file")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="clusterDns")
    def cluster_dns(self) -> str:
        return pulumi.get(self, "cluster_dns")

    @property
    @pulumi.getter(name="clusterDomain")
    def cluster_domain(self) -> str:
        return pulumi.get(self, "cluster_domain")

    @property
    @pulumi.getter(name="configureCbr0")
    def configure_cbr0(self) -> bool:
        return pulumi.get(self, "configure_cbr0")

    @property
    @pulumi.getter(name="containerLogMaxFiles")
    def container_log_max_files(self) -> int:
        return pulumi.get(self, "container_log_max_files")

    @property
    @pulumi.getter(name="containerLogMaxSize")
    def container_log_max_size(self) -> str:
        return pulumi.get(self, "container_log_max_size")

    @property
    @pulumi.getter(name="cpuCfsQuotaPeriod")
    def cpu_cfs_quota_period(self) -> str:
        return pulumi.get(self, "cpu_cfs_quota_period")

    @property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> str:
        return pulumi.get(self, "cpu_manager_policy")

    @property
    @pulumi.getter(name="dockerDisableSharedPid")
    def docker_disable_shared_pid(self) -> bool:
        return pulumi.get(self, "docker_disable_shared_pid")

    @property
    @pulumi.getter(name="enableCadvisorJsonEndpoints")
    def enable_cadvisor_json_endpoints(self) -> bool:
        return pulumi.get(self, "enable_cadvisor_json_endpoints")

    @property
    @pulumi.getter(name="enableCustomMetrics")
    def enable_custom_metrics(self) -> bool:
        return pulumi.get(self, "enable_custom_metrics")

    @property
    @pulumi.getter(name="enableDebuggingHandlers")
    def enable_debugging_handlers(self) -> bool:
        return pulumi.get(self, "enable_debugging_handlers")

    @property
    @pulumi.getter(name="enforceNodeAllocatable")
    def enforce_node_allocatable(self) -> str:
        return pulumi.get(self, "enforce_node_allocatable")

    @property
    @pulumi.getter(name="eventBurst")
    def event_burst(self) -> int:
        return pulumi.get(self, "event_burst")

    @property
    @pulumi.getter(name="eventQps")
    def event_qps(self) -> int:
        return pulumi.get(self, "event_qps")

    @property
    @pulumi.getter(name="evictionHard")
    def eviction_hard(self) -> str:
        return pulumi.get(self, "eviction_hard")

    @property
    @pulumi.getter(name="evictionMaxPodGracePeriod")
    def eviction_max_pod_grace_period(self) -> int:
        return pulumi.get(self, "eviction_max_pod_grace_period")

    @property
    @pulumi.getter(name="evictionMinimumReclaim")
    def eviction_minimum_reclaim(self) -> str:
        return pulumi.get(self, "eviction_minimum_reclaim")

    @property
    @pulumi.getter(name="evictionPressureTransitionPeriod")
    def eviction_pressure_transition_period(self) -> str:
        return pulumi.get(self, "eviction_pressure_transition_period")

    @property
    @pulumi.getter(name="evictionSoft")
    def eviction_soft(self) -> str:
        return pulumi.get(self, "eviction_soft")

    @property
    @pulumi.getter(name="evictionSoftGracePeriod")
    def eviction_soft_grace_period(self) -> str:
        return pulumi.get(self, "eviction_soft_grace_period")

    @property
    @pulumi.getter(name="experimentalAllowedUnsafeSysctls")
    def experimental_allowed_unsafe_sysctls(self) -> Sequence[str]:
        return pulumi.get(self, "experimental_allowed_unsafe_sysctls")

    @property
    @pulumi.getter(name="failSwapOn")
    def fail_swap_on(self) -> bool:
        return pulumi.get(self, "fail_swap_on")

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Mapping[str, str]:
        return pulumi.get(self, "feature_gates")

    @property
    @pulumi.getter(name="hairpinMode")
    def hairpin_mode(self) -> str:
        return pulumi.get(self, "hairpin_mode")

    @property
    @pulumi.getter(name="hostnameOverride")
    def hostname_override(self) -> str:
        return pulumi.get(self, "hostname_override")

    @property
    @pulumi.getter(name="housekeepingInterval")
    def housekeeping_interval(self) -> str:
        return pulumi.get(self, "housekeeping_interval")

    @property
    @pulumi.getter(name="imageGcHighThresholdPercent")
    def image_gc_high_threshold_percent(self) -> int:
        return pulumi.get(self, "image_gc_high_threshold_percent")

    @property
    @pulumi.getter(name="imageGcLowThresholdPercent")
    def image_gc_low_threshold_percent(self) -> int:
        return pulumi.get(self, "image_gc_low_threshold_percent")

    @property
    @pulumi.getter(name="imagePullProgressDeadline")
    def image_pull_progress_deadline(self) -> str:
        return pulumi.get(self, "image_pull_progress_deadline")

    @property
    @pulumi.getter(name="kernelMemcgNotification")
    def kernel_memcg_notification(self) -> bool:
        return pulumi.get(self, "kernel_memcg_notification")

    @property
    @pulumi.getter(name="kubeReserved")
    def kube_reserved(self) -> Mapping[str, str]:
        return pulumi.get(self, "kube_reserved")

    @property
    @pulumi.getter(name="kubeReservedCgroup")
    def kube_reserved_cgroup(self) -> str:
        return pulumi.get(self, "kube_reserved_cgroup")

    @property
    @pulumi.getter(name="kubeconfigPath")
    def kubeconfig_path(self) -> str:
        return pulumi.get(self, "kubeconfig_path")

    @property
    @pulumi.getter(name="kubeletCgroups")
    def kubelet_cgroups(self) -> str:
        return pulumi.get(self, "kubelet_cgroups")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> str:
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> int:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> int:
        return pulumi.get(self, "max_pods")

    @property
    @pulumi.getter(name="networkPluginMtu")
    def network_plugin_mtu(self) -> int:
        return pulumi.get(self, "network_plugin_mtu")

    @property
    @pulumi.getter(name="networkPluginName")
    def network_plugin_name(self) -> str:
        return pulumi.get(self, "network_plugin_name")

    @property
    @pulumi.getter(name="nodeLabels")
    def node_labels(self) -> Mapping[str, str]:
        return pulumi.get(self, "node_labels")

    @property
    @pulumi.getter(name="nodeStatusUpdateFrequency")
    def node_status_update_frequency(self) -> str:
        return pulumi.get(self, "node_status_update_frequency")

    @property
    @pulumi.getter(name="nonMasqueradeCidr")
    def non_masquerade_cidr(self) -> str:
        """
        - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
        """
        return pulumi.get(self, "non_masquerade_cidr")

    @property
    @pulumi.getter(name="nvidiaGpUs")
    def nvidia_gp_us(self) -> int:
        return pulumi.get(self, "nvidia_gp_us")

    @property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> str:
        """
        - String - PodCIDR is the CIDR from which we allocate IPs for pods.
        """
        return pulumi.get(self, "pod_cidr")

    @property
    @pulumi.getter(name="podInfraContainerImage")
    def pod_infra_container_image(self) -> str:
        return pulumi.get(self, "pod_infra_container_image")

    @property
    @pulumi.getter(name="podManifestPath")
    def pod_manifest_path(self) -> str:
        return pulumi.get(self, "pod_manifest_path")

    @property
    @pulumi.getter(name="podPidsLimit")
    def pod_pids_limit(self) -> int:
        return pulumi.get(self, "pod_pids_limit")

    @property
    @pulumi.getter(name="protectKernelDefaults")
    def protect_kernel_defaults(self) -> bool:
        return pulumi.get(self, "protect_kernel_defaults")

    @property
    @pulumi.getter(name="readOnlyPort")
    def read_only_port(self) -> int:
        return pulumi.get(self, "read_only_port")

    @property
    @pulumi.getter(name="reconcileCidr")
    def reconcile_cidr(self) -> bool:
        return pulumi.get(self, "reconcile_cidr")

    @property
    @pulumi.getter(name="registerNode")
    def register_node(self) -> bool:
        return pulumi.get(self, "register_node")

    @property
    @pulumi.getter(name="registerSchedulable")
    def register_schedulable(self) -> bool:
        return pulumi.get(self, "register_schedulable")

    @property
    @pulumi.getter(name="registryBurst")
    def registry_burst(self) -> int:
        return pulumi.get(self, "registry_burst")

    @property
    @pulumi.getter(name="registryPullQps")
    def registry_pull_qps(self) -> int:
        return pulumi.get(self, "registry_pull_qps")

    @property
    @pulumi.getter(name="requireKubeconfig")
    def require_kubeconfig(self) -> bool:
        return pulumi.get(self, "require_kubeconfig")

    @property
    @pulumi.getter(name="resolverConfig")
    def resolver_config(self) -> str:
        return pulumi.get(self, "resolver_config")

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> str:
        return pulumi.get(self, "root_dir")

    @property
    @pulumi.getter(name="rotateCertificates")
    def rotate_certificates(self) -> bool:
        return pulumi.get(self, "rotate_certificates")

    @property
    @pulumi.getter(name="runtimeCgroups")
    def runtime_cgroups(self) -> str:
        return pulumi.get(self, "runtime_cgroups")

    @property
    @pulumi.getter(name="runtimeRequestTimeout")
    def runtime_request_timeout(self) -> str:
        return pulumi.get(self, "runtime_request_timeout")

    @property
    @pulumi.getter(name="seccompProfileRoot")
    def seccomp_profile_root(self) -> str:
        return pulumi.get(self, "seccomp_profile_root")

    @property
    @pulumi.getter(name="serializeImagePulls")
    def serialize_image_pulls(self) -> bool:
        return pulumi.get(self, "serialize_image_pulls")

    @property
    @pulumi.getter(name="shutdownGracePeriod")
    def shutdown_grace_period(self) -> str:
        return pulumi.get(self, "shutdown_grace_period")

    @property
    @pulumi.getter(name="shutdownGracePeriodCriticalPods")
    def shutdown_grace_period_critical_pods(self) -> str:
        return pulumi.get(self, "shutdown_grace_period_critical_pods")

    @property
    @pulumi.getter(name="streamingConnectionIdleTimeout")
    def streaming_connection_idle_timeout(self) -> str:
        return pulumi.get(self, "streaming_connection_idle_timeout")

    @property
    @pulumi.getter(name="systemCgroups")
    def system_cgroups(self) -> str:
        return pulumi.get(self, "system_cgroups")

    @property
    @pulumi.getter(name="systemReserved")
    def system_reserved(self) -> Mapping[str, str]:
        return pulumi.get(self, "system_reserved")

    @property
    @pulumi.getter(name="systemReservedCgroup")
    def system_reserved_cgroup(self) -> str:
        return pulumi.get(self, "system_reserved_cgroup")

    @property
    @pulumi.getter
    def taints(self) -> Sequence[str]:
        return pulumi.get(self, "taints")

    @property
    @pulumi.getter(name="tlsCertFile")
    def tls_cert_file(self) -> str:
        return pulumi.get(self, "tls_cert_file")

    @property
    @pulumi.getter(name="tlsCipherSuites")
    def tls_cipher_suites(self) -> Sequence[str]:
        return pulumi.get(self, "tls_cipher_suites")

    @property
    @pulumi.getter(name="tlsMinVersion")
    def tls_min_version(self) -> str:
        return pulumi.get(self, "tls_min_version")

    @property
    @pulumi.getter(name="tlsPrivateKeyFile")
    def tls_private_key_file(self) -> str:
        return pulumi.get(self, "tls_private_key_file")

    @property
    @pulumi.getter(name="topologyManagerPolicy")
    def topology_manager_policy(self) -> str:
        return pulumi.get(self, "topology_manager_policy")

    @property
    @pulumi.getter(name="volumePluginDirectory")
    def volume_plugin_directory(self) -> str:
        return pulumi.get(self, "volume_plugin_directory")

    @property
    @pulumi.getter(name="volumeStatsAggPeriod")
    def volume_stats_agg_period(self) -> str:
        return pulumi.get(self, "volume_stats_agg_period")

    @property
    @pulumi.getter(name="anonymousAuth")
    def anonymous_auth(self) -> Optional['outputs.GetClusterMasterKubeletAnonymousAuthResult']:
        return pulumi.get(self, "anonymous_auth")

    @property
    @pulumi.getter(name="cpuCfsQuota")
    def cpu_cfs_quota(self) -> Optional['outputs.GetClusterMasterKubeletCpuCfsQuotaResult']:
        return pulumi.get(self, "cpu_cfs_quota")


@pulumi.output_type
class GetClusterMasterKubeletAnonymousAuthResult(dict):
    def __init__(__self__, *,
                 value: bool):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterMasterKubeletCpuCfsQuotaResult(dict):
    def __init__(__self__, *,
                 value: bool):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterMetricsServerResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 image: str,
                 insecure: bool):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "insecure", insecure)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def insecure(self) -> bool:
        return pulumi.get(self, "insecure")


@pulumi.output_type
class GetClusterNetworkingResult(dict):
    def __init__(__self__, *,
                 amazon_vpcs: Sequence['outputs.GetClusterNetworkingAmazonVpcResult'],
                 calicos: Sequence['outputs.GetClusterNetworkingCalicoResult'],
                 canals: Sequence['outputs.GetClusterNetworkingCanalResult'],
                 cilias: Sequence['outputs.GetClusterNetworkingCiliaResult'],
                 classics: Sequence['outputs.GetClusterNetworkingClassicResult'],
                 cnis: Sequence['outputs.GetClusterNetworkingCniResult'],
                 externals: Sequence['outputs.GetClusterNetworkingExternalResult'],
                 flannels: Sequence['outputs.GetClusterNetworkingFlannelResult'],
                 gces: Sequence['outputs.GetClusterNetworkingGceResult'],
                 kopeios: Sequence['outputs.GetClusterNetworkingKopeioResult'],
                 kubenets: Sequence['outputs.GetClusterNetworkingKubenetResult'],
                 kuberouters: Sequence['outputs.GetClusterNetworkingKuberouterResult'],
                 lyft_vpcs: Sequence['outputs.GetClusterNetworkingLyftVpcResult'],
                 romanas: Sequence['outputs.GetClusterNetworkingRomanaResult'],
                 weaves: Sequence['outputs.GetClusterNetworkingWeafeResult']):
        pulumi.set(__self__, "amazon_vpcs", amazon_vpcs)
        pulumi.set(__self__, "calicos", calicos)
        pulumi.set(__self__, "canals", canals)
        pulumi.set(__self__, "cilias", cilias)
        pulumi.set(__self__, "classics", classics)
        pulumi.set(__self__, "cnis", cnis)
        pulumi.set(__self__, "externals", externals)
        pulumi.set(__self__, "flannels", flannels)
        pulumi.set(__self__, "gces", gces)
        pulumi.set(__self__, "kopeios", kopeios)
        pulumi.set(__self__, "kubenets", kubenets)
        pulumi.set(__self__, "kuberouters", kuberouters)
        pulumi.set(__self__, "lyft_vpcs", lyft_vpcs)
        pulumi.set(__self__, "romanas", romanas)
        pulumi.set(__self__, "weaves", weaves)

    @property
    @pulumi.getter(name="amazonVpcs")
    def amazon_vpcs(self) -> Sequence['outputs.GetClusterNetworkingAmazonVpcResult']:
        return pulumi.get(self, "amazon_vpcs")

    @property
    @pulumi.getter
    def calicos(self) -> Sequence['outputs.GetClusterNetworkingCalicoResult']:
        return pulumi.get(self, "calicos")

    @property
    @pulumi.getter
    def canals(self) -> Sequence['outputs.GetClusterNetworkingCanalResult']:
        return pulumi.get(self, "canals")

    @property
    @pulumi.getter
    def cilias(self) -> Sequence['outputs.GetClusterNetworkingCiliaResult']:
        return pulumi.get(self, "cilias")

    @property
    @pulumi.getter
    def classics(self) -> Sequence['outputs.GetClusterNetworkingClassicResult']:
        return pulumi.get(self, "classics")

    @property
    @pulumi.getter
    def cnis(self) -> Sequence['outputs.GetClusterNetworkingCniResult']:
        return pulumi.get(self, "cnis")

    @property
    @pulumi.getter
    def externals(self) -> Sequence['outputs.GetClusterNetworkingExternalResult']:
        return pulumi.get(self, "externals")

    @property
    @pulumi.getter
    def flannels(self) -> Sequence['outputs.GetClusterNetworkingFlannelResult']:
        return pulumi.get(self, "flannels")

    @property
    @pulumi.getter
    def gces(self) -> Sequence['outputs.GetClusterNetworkingGceResult']:
        return pulumi.get(self, "gces")

    @property
    @pulumi.getter
    def kopeios(self) -> Sequence['outputs.GetClusterNetworkingKopeioResult']:
        return pulumi.get(self, "kopeios")

    @property
    @pulumi.getter
    def kubenets(self) -> Sequence['outputs.GetClusterNetworkingKubenetResult']:
        return pulumi.get(self, "kubenets")

    @property
    @pulumi.getter
    def kuberouters(self) -> Sequence['outputs.GetClusterNetworkingKuberouterResult']:
        return pulumi.get(self, "kuberouters")

    @property
    @pulumi.getter(name="lyftVpcs")
    def lyft_vpcs(self) -> Sequence['outputs.GetClusterNetworkingLyftVpcResult']:
        return pulumi.get(self, "lyft_vpcs")

    @property
    @pulumi.getter
    def romanas(self) -> Sequence['outputs.GetClusterNetworkingRomanaResult']:
        return pulumi.get(self, "romanas")

    @property
    @pulumi.getter
    def weaves(self) -> Sequence['outputs.GetClusterNetworkingWeafeResult']:
        return pulumi.get(self, "weaves")


@pulumi.output_type
class GetClusterNetworkingAmazonVpcResult(dict):
    def __init__(__self__, *,
                 envs: Sequence['outputs.GetClusterNetworkingAmazonVpcEnvResult'],
                 image: str,
                 init_image: str):
        pulumi.set(__self__, "envs", envs)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "init_image", init_image)

    @property
    @pulumi.getter
    def envs(self) -> Sequence['outputs.GetClusterNetworkingAmazonVpcEnvResult']:
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="initImage")
    def init_image(self) -> str:
        return pulumi.get(self, "init_image")


@pulumi.output_type
class GetClusterNetworkingAmazonVpcEnvResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: - String - Name defines the cluster name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterNetworkingCalicoResult(dict):
    def __init__(__self__, *,
                 allow_ip_forwarding: bool,
                 aws_src_dst_check: str,
                 bpf_enabled: bool,
                 bpf_external_service_mode: str,
                 bpf_kube_proxy_iptables_cleanup_enabled: bool,
                 bpf_log_level: str,
                 chain_insert_mode: str,
                 cpu_request: str,
                 cross_subnet: bool,
                 encapsulation_mode: str,
                 ip_ip_mode: str,
                 iptables_backend: str,
                 ipv4_auto_detection_method: str,
                 ipv6_auto_detection_method: str,
                 log_severity_screen: str,
                 mtu: int,
                 prometheus_go_metrics_enabled: bool,
                 prometheus_metrics_enabled: bool,
                 prometheus_metrics_port: int,
                 prometheus_process_metrics_enabled: bool,
                 registry: str,
                 typha_prometheus_metrics_enabled: bool,
                 typha_prometheus_metrics_port: int,
                 typha_replicas: int,
                 version: str,
                 vxlan_mode: str,
                 wireguard_enabled: bool):
        pulumi.set(__self__, "allow_ip_forwarding", allow_ip_forwarding)
        pulumi.set(__self__, "aws_src_dst_check", aws_src_dst_check)
        pulumi.set(__self__, "bpf_enabled", bpf_enabled)
        pulumi.set(__self__, "bpf_external_service_mode", bpf_external_service_mode)
        pulumi.set(__self__, "bpf_kube_proxy_iptables_cleanup_enabled", bpf_kube_proxy_iptables_cleanup_enabled)
        pulumi.set(__self__, "bpf_log_level", bpf_log_level)
        pulumi.set(__self__, "chain_insert_mode", chain_insert_mode)
        pulumi.set(__self__, "cpu_request", cpu_request)
        pulumi.set(__self__, "cross_subnet", cross_subnet)
        pulumi.set(__self__, "encapsulation_mode", encapsulation_mode)
        pulumi.set(__self__, "ip_ip_mode", ip_ip_mode)
        pulumi.set(__self__, "iptables_backend", iptables_backend)
        pulumi.set(__self__, "ipv4_auto_detection_method", ipv4_auto_detection_method)
        pulumi.set(__self__, "ipv6_auto_detection_method", ipv6_auto_detection_method)
        pulumi.set(__self__, "log_severity_screen", log_severity_screen)
        pulumi.set(__self__, "mtu", mtu)
        pulumi.set(__self__, "prometheus_go_metrics_enabled", prometheus_go_metrics_enabled)
        pulumi.set(__self__, "prometheus_metrics_enabled", prometheus_metrics_enabled)
        pulumi.set(__self__, "prometheus_metrics_port", prometheus_metrics_port)
        pulumi.set(__self__, "prometheus_process_metrics_enabled", prometheus_process_metrics_enabled)
        pulumi.set(__self__, "registry", registry)
        pulumi.set(__self__, "typha_prometheus_metrics_enabled", typha_prometheus_metrics_enabled)
        pulumi.set(__self__, "typha_prometheus_metrics_port", typha_prometheus_metrics_port)
        pulumi.set(__self__, "typha_replicas", typha_replicas)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "vxlan_mode", vxlan_mode)
        pulumi.set(__self__, "wireguard_enabled", wireguard_enabled)

    @property
    @pulumi.getter(name="allowIpForwarding")
    def allow_ip_forwarding(self) -> bool:
        return pulumi.get(self, "allow_ip_forwarding")

    @property
    @pulumi.getter(name="awsSrcDstCheck")
    def aws_src_dst_check(self) -> str:
        return pulumi.get(self, "aws_src_dst_check")

    @property
    @pulumi.getter(name="bpfEnabled")
    def bpf_enabled(self) -> bool:
        return pulumi.get(self, "bpf_enabled")

    @property
    @pulumi.getter(name="bpfExternalServiceMode")
    def bpf_external_service_mode(self) -> str:
        return pulumi.get(self, "bpf_external_service_mode")

    @property
    @pulumi.getter(name="bpfKubeProxyIptablesCleanupEnabled")
    def bpf_kube_proxy_iptables_cleanup_enabled(self) -> bool:
        return pulumi.get(self, "bpf_kube_proxy_iptables_cleanup_enabled")

    @property
    @pulumi.getter(name="bpfLogLevel")
    def bpf_log_level(self) -> str:
        return pulumi.get(self, "bpf_log_level")

    @property
    @pulumi.getter(name="chainInsertMode")
    def chain_insert_mode(self) -> str:
        return pulumi.get(self, "chain_insert_mode")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> str:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter(name="crossSubnet")
    def cross_subnet(self) -> bool:
        return pulumi.get(self, "cross_subnet")

    @property
    @pulumi.getter(name="encapsulationMode")
    def encapsulation_mode(self) -> str:
        return pulumi.get(self, "encapsulation_mode")

    @property
    @pulumi.getter(name="ipIpMode")
    def ip_ip_mode(self) -> str:
        return pulumi.get(self, "ip_ip_mode")

    @property
    @pulumi.getter(name="iptablesBackend")
    def iptables_backend(self) -> str:
        return pulumi.get(self, "iptables_backend")

    @property
    @pulumi.getter(name="ipv4AutoDetectionMethod")
    def ipv4_auto_detection_method(self) -> str:
        return pulumi.get(self, "ipv4_auto_detection_method")

    @property
    @pulumi.getter(name="ipv6AutoDetectionMethod")
    def ipv6_auto_detection_method(self) -> str:
        return pulumi.get(self, "ipv6_auto_detection_method")

    @property
    @pulumi.getter(name="logSeverityScreen")
    def log_severity_screen(self) -> str:
        return pulumi.get(self, "log_severity_screen")

    @property
    @pulumi.getter
    def mtu(self) -> int:
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter(name="prometheusGoMetricsEnabled")
    def prometheus_go_metrics_enabled(self) -> bool:
        return pulumi.get(self, "prometheus_go_metrics_enabled")

    @property
    @pulumi.getter(name="prometheusMetricsEnabled")
    def prometheus_metrics_enabled(self) -> bool:
        return pulumi.get(self, "prometheus_metrics_enabled")

    @property
    @pulumi.getter(name="prometheusMetricsPort")
    def prometheus_metrics_port(self) -> int:
        return pulumi.get(self, "prometheus_metrics_port")

    @property
    @pulumi.getter(name="prometheusProcessMetricsEnabled")
    def prometheus_process_metrics_enabled(self) -> bool:
        return pulumi.get(self, "prometheus_process_metrics_enabled")

    @property
    @pulumi.getter
    def registry(self) -> str:
        return pulumi.get(self, "registry")

    @property
    @pulumi.getter(name="typhaPrometheusMetricsEnabled")
    def typha_prometheus_metrics_enabled(self) -> bool:
        return pulumi.get(self, "typha_prometheus_metrics_enabled")

    @property
    @pulumi.getter(name="typhaPrometheusMetricsPort")
    def typha_prometheus_metrics_port(self) -> int:
        return pulumi.get(self, "typha_prometheus_metrics_port")

    @property
    @pulumi.getter(name="typhaReplicas")
    def typha_replicas(self) -> int:
        return pulumi.get(self, "typha_replicas")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="vxlanMode")
    def vxlan_mode(self) -> str:
        return pulumi.get(self, "vxlan_mode")

    @property
    @pulumi.getter(name="wireguardEnabled")
    def wireguard_enabled(self) -> bool:
        return pulumi.get(self, "wireguard_enabled")


@pulumi.output_type
class GetClusterNetworkingCanalResult(dict):
    def __init__(__self__, *,
                 chain_insert_mode: str,
                 cpu_request: str,
                 default_endpoint_to_host_action: str,
                 flanneld_iptables_forward_rules: bool,
                 iptables_backend: str,
                 log_severity_sys: str,
                 mtu: int,
                 prometheus_go_metrics_enabled: bool,
                 prometheus_metrics_enabled: bool,
                 prometheus_metrics_port: int,
                 prometheus_process_metrics_enabled: bool,
                 typha_prometheus_metrics_enabled: bool,
                 typha_prometheus_metrics_port: int,
                 typha_replicas: int):
        pulumi.set(__self__, "chain_insert_mode", chain_insert_mode)
        pulumi.set(__self__, "cpu_request", cpu_request)
        pulumi.set(__self__, "default_endpoint_to_host_action", default_endpoint_to_host_action)
        pulumi.set(__self__, "flanneld_iptables_forward_rules", flanneld_iptables_forward_rules)
        pulumi.set(__self__, "iptables_backend", iptables_backend)
        pulumi.set(__self__, "log_severity_sys", log_severity_sys)
        pulumi.set(__self__, "mtu", mtu)
        pulumi.set(__self__, "prometheus_go_metrics_enabled", prometheus_go_metrics_enabled)
        pulumi.set(__self__, "prometheus_metrics_enabled", prometheus_metrics_enabled)
        pulumi.set(__self__, "prometheus_metrics_port", prometheus_metrics_port)
        pulumi.set(__self__, "prometheus_process_metrics_enabled", prometheus_process_metrics_enabled)
        pulumi.set(__self__, "typha_prometheus_metrics_enabled", typha_prometheus_metrics_enabled)
        pulumi.set(__self__, "typha_prometheus_metrics_port", typha_prometheus_metrics_port)
        pulumi.set(__self__, "typha_replicas", typha_replicas)

    @property
    @pulumi.getter(name="chainInsertMode")
    def chain_insert_mode(self) -> str:
        return pulumi.get(self, "chain_insert_mode")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> str:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter(name="defaultEndpointToHostAction")
    def default_endpoint_to_host_action(self) -> str:
        return pulumi.get(self, "default_endpoint_to_host_action")

    @property
    @pulumi.getter(name="flanneldIptablesForwardRules")
    def flanneld_iptables_forward_rules(self) -> bool:
        return pulumi.get(self, "flanneld_iptables_forward_rules")

    @property
    @pulumi.getter(name="iptablesBackend")
    def iptables_backend(self) -> str:
        return pulumi.get(self, "iptables_backend")

    @property
    @pulumi.getter(name="logSeveritySys")
    def log_severity_sys(self) -> str:
        return pulumi.get(self, "log_severity_sys")

    @property
    @pulumi.getter
    def mtu(self) -> int:
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter(name="prometheusGoMetricsEnabled")
    def prometheus_go_metrics_enabled(self) -> bool:
        return pulumi.get(self, "prometheus_go_metrics_enabled")

    @property
    @pulumi.getter(name="prometheusMetricsEnabled")
    def prometheus_metrics_enabled(self) -> bool:
        return pulumi.get(self, "prometheus_metrics_enabled")

    @property
    @pulumi.getter(name="prometheusMetricsPort")
    def prometheus_metrics_port(self) -> int:
        return pulumi.get(self, "prometheus_metrics_port")

    @property
    @pulumi.getter(name="prometheusProcessMetricsEnabled")
    def prometheus_process_metrics_enabled(self) -> bool:
        return pulumi.get(self, "prometheus_process_metrics_enabled")

    @property
    @pulumi.getter(name="typhaPrometheusMetricsEnabled")
    def typha_prometheus_metrics_enabled(self) -> bool:
        return pulumi.get(self, "typha_prometheus_metrics_enabled")

    @property
    @pulumi.getter(name="typhaPrometheusMetricsPort")
    def typha_prometheus_metrics_port(self) -> int:
        return pulumi.get(self, "typha_prometheus_metrics_port")

    @property
    @pulumi.getter(name="typhaReplicas")
    def typha_replicas(self) -> int:
        return pulumi.get(self, "typha_replicas")


@pulumi.output_type
class GetClusterNetworkingCiliaResult(dict):
    def __init__(__self__, *,
                 agent_pod_annotations: Mapping[str, str],
                 agent_prometheus_port: int,
                 auto_direct_node_routes: bool,
                 bpf_neigh_global_max: int,
                 bpf_policy_map_max: int,
                 bpfct_global_any_max: int,
                 bpfct_global_tcp_max: int,
                 bpflb_algorithm: str,
                 bpflb_maglev_table_size: str,
                 bpflb_map_max: int,
                 bpflb_sock_host_ns_only: bool,
                 bpfnat_global_max: int,
                 chaining_mode: str,
                 cluster_name: str,
                 cpu_request: str,
                 debug: bool,
                 disable_cnp_status_updates: bool,
                 disable_endpoint_crd: bool,
                 enable_bpf_masquerade: bool,
                 enable_encryption: bool,
                 enable_endpoint_health_checking: bool,
                 enable_host_reachable_services: bool,
                 enable_l7_proxy: bool,
                 enable_node_port: bool,
                 enable_policy: str,
                 enable_prometheus_metrics: bool,
                 enable_remote_node_identity: bool,
                 enable_service_topology: bool,
                 encryption_type: str,
                 etcd_managed: bool,
                 hubbles: Sequence['outputs.GetClusterNetworkingCiliaHubbleResult'],
                 identity_allocation_mode: str,
                 identity_change_grace_period: str,
                 install_iptables_rules: bool,
                 ipam: str,
                 masquerade: bool,
                 memory_request: str,
                 metrics: Sequence[str],
                 monitor_aggregation: str,
                 preallocate_bpf_maps: bool,
                 sidecar_istio_proxy_image: str,
                 to_fqdns_dns_reject_response_code: str,
                 to_fqdns_enable_poller: bool,
                 tunnel: str,
                 version: str):
        pulumi.set(__self__, "agent_pod_annotations", agent_pod_annotations)
        pulumi.set(__self__, "agent_prometheus_port", agent_prometheus_port)
        pulumi.set(__self__, "auto_direct_node_routes", auto_direct_node_routes)
        pulumi.set(__self__, "bpf_neigh_global_max", bpf_neigh_global_max)
        pulumi.set(__self__, "bpf_policy_map_max", bpf_policy_map_max)
        pulumi.set(__self__, "bpfct_global_any_max", bpfct_global_any_max)
        pulumi.set(__self__, "bpfct_global_tcp_max", bpfct_global_tcp_max)
        pulumi.set(__self__, "bpflb_algorithm", bpflb_algorithm)
        pulumi.set(__self__, "bpflb_maglev_table_size", bpflb_maglev_table_size)
        pulumi.set(__self__, "bpflb_map_max", bpflb_map_max)
        pulumi.set(__self__, "bpflb_sock_host_ns_only", bpflb_sock_host_ns_only)
        pulumi.set(__self__, "bpfnat_global_max", bpfnat_global_max)
        pulumi.set(__self__, "chaining_mode", chaining_mode)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "cpu_request", cpu_request)
        pulumi.set(__self__, "debug", debug)
        pulumi.set(__self__, "disable_cnp_status_updates", disable_cnp_status_updates)
        pulumi.set(__self__, "disable_endpoint_crd", disable_endpoint_crd)
        pulumi.set(__self__, "enable_bpf_masquerade", enable_bpf_masquerade)
        pulumi.set(__self__, "enable_encryption", enable_encryption)
        pulumi.set(__self__, "enable_endpoint_health_checking", enable_endpoint_health_checking)
        pulumi.set(__self__, "enable_host_reachable_services", enable_host_reachable_services)
        pulumi.set(__self__, "enable_l7_proxy", enable_l7_proxy)
        pulumi.set(__self__, "enable_node_port", enable_node_port)
        pulumi.set(__self__, "enable_policy", enable_policy)
        pulumi.set(__self__, "enable_prometheus_metrics", enable_prometheus_metrics)
        pulumi.set(__self__, "enable_remote_node_identity", enable_remote_node_identity)
        pulumi.set(__self__, "enable_service_topology", enable_service_topology)
        pulumi.set(__self__, "encryption_type", encryption_type)
        pulumi.set(__self__, "etcd_managed", etcd_managed)
        pulumi.set(__self__, "hubbles", hubbles)
        pulumi.set(__self__, "identity_allocation_mode", identity_allocation_mode)
        pulumi.set(__self__, "identity_change_grace_period", identity_change_grace_period)
        pulumi.set(__self__, "install_iptables_rules", install_iptables_rules)
        pulumi.set(__self__, "ipam", ipam)
        pulumi.set(__self__, "masquerade", masquerade)
        pulumi.set(__self__, "memory_request", memory_request)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "monitor_aggregation", monitor_aggregation)
        pulumi.set(__self__, "preallocate_bpf_maps", preallocate_bpf_maps)
        pulumi.set(__self__, "sidecar_istio_proxy_image", sidecar_istio_proxy_image)
        pulumi.set(__self__, "to_fqdns_dns_reject_response_code", to_fqdns_dns_reject_response_code)
        pulumi.set(__self__, "to_fqdns_enable_poller", to_fqdns_enable_poller)
        pulumi.set(__self__, "tunnel", tunnel)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="agentPodAnnotations")
    def agent_pod_annotations(self) -> Mapping[str, str]:
        return pulumi.get(self, "agent_pod_annotations")

    @property
    @pulumi.getter(name="agentPrometheusPort")
    def agent_prometheus_port(self) -> int:
        return pulumi.get(self, "agent_prometheus_port")

    @property
    @pulumi.getter(name="autoDirectNodeRoutes")
    def auto_direct_node_routes(self) -> bool:
        return pulumi.get(self, "auto_direct_node_routes")

    @property
    @pulumi.getter(name="bpfNeighGlobalMax")
    def bpf_neigh_global_max(self) -> int:
        return pulumi.get(self, "bpf_neigh_global_max")

    @property
    @pulumi.getter(name="bpfPolicyMapMax")
    def bpf_policy_map_max(self) -> int:
        return pulumi.get(self, "bpf_policy_map_max")

    @property
    @pulumi.getter(name="bpfctGlobalAnyMax")
    def bpfct_global_any_max(self) -> int:
        return pulumi.get(self, "bpfct_global_any_max")

    @property
    @pulumi.getter(name="bpfctGlobalTcpMax")
    def bpfct_global_tcp_max(self) -> int:
        return pulumi.get(self, "bpfct_global_tcp_max")

    @property
    @pulumi.getter(name="bpflbAlgorithm")
    def bpflb_algorithm(self) -> str:
        return pulumi.get(self, "bpflb_algorithm")

    @property
    @pulumi.getter(name="bpflbMaglevTableSize")
    def bpflb_maglev_table_size(self) -> str:
        return pulumi.get(self, "bpflb_maglev_table_size")

    @property
    @pulumi.getter(name="bpflbMapMax")
    def bpflb_map_max(self) -> int:
        return pulumi.get(self, "bpflb_map_max")

    @property
    @pulumi.getter(name="bpflbSockHostNsOnly")
    def bpflb_sock_host_ns_only(self) -> bool:
        return pulumi.get(self, "bpflb_sock_host_ns_only")

    @property
    @pulumi.getter(name="bpfnatGlobalMax")
    def bpfnat_global_max(self) -> int:
        return pulumi.get(self, "bpfnat_global_max")

    @property
    @pulumi.getter(name="chainingMode")
    def chaining_mode(self) -> str:
        return pulumi.get(self, "chaining_mode")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> str:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter
    def debug(self) -> bool:
        return pulumi.get(self, "debug")

    @property
    @pulumi.getter(name="disableCnpStatusUpdates")
    def disable_cnp_status_updates(self) -> bool:
        return pulumi.get(self, "disable_cnp_status_updates")

    @property
    @pulumi.getter(name="disableEndpointCrd")
    def disable_endpoint_crd(self) -> bool:
        return pulumi.get(self, "disable_endpoint_crd")

    @property
    @pulumi.getter(name="enableBpfMasquerade")
    def enable_bpf_masquerade(self) -> bool:
        return pulumi.get(self, "enable_bpf_masquerade")

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> bool:
        return pulumi.get(self, "enable_encryption")

    @property
    @pulumi.getter(name="enableEndpointHealthChecking")
    def enable_endpoint_health_checking(self) -> bool:
        return pulumi.get(self, "enable_endpoint_health_checking")

    @property
    @pulumi.getter(name="enableHostReachableServices")
    def enable_host_reachable_services(self) -> bool:
        return pulumi.get(self, "enable_host_reachable_services")

    @property
    @pulumi.getter(name="enableL7Proxy")
    def enable_l7_proxy(self) -> bool:
        return pulumi.get(self, "enable_l7_proxy")

    @property
    @pulumi.getter(name="enableNodePort")
    def enable_node_port(self) -> bool:
        return pulumi.get(self, "enable_node_port")

    @property
    @pulumi.getter(name="enablePolicy")
    def enable_policy(self) -> str:
        return pulumi.get(self, "enable_policy")

    @property
    @pulumi.getter(name="enablePrometheusMetrics")
    def enable_prometheus_metrics(self) -> bool:
        return pulumi.get(self, "enable_prometheus_metrics")

    @property
    @pulumi.getter(name="enableRemoteNodeIdentity")
    def enable_remote_node_identity(self) -> bool:
        return pulumi.get(self, "enable_remote_node_identity")

    @property
    @pulumi.getter(name="enableServiceTopology")
    def enable_service_topology(self) -> bool:
        return pulumi.get(self, "enable_service_topology")

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> str:
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter(name="etcdManaged")
    def etcd_managed(self) -> bool:
        return pulumi.get(self, "etcd_managed")

    @property
    @pulumi.getter
    def hubbles(self) -> Sequence['outputs.GetClusterNetworkingCiliaHubbleResult']:
        return pulumi.get(self, "hubbles")

    @property
    @pulumi.getter(name="identityAllocationMode")
    def identity_allocation_mode(self) -> str:
        return pulumi.get(self, "identity_allocation_mode")

    @property
    @pulumi.getter(name="identityChangeGracePeriod")
    def identity_change_grace_period(self) -> str:
        return pulumi.get(self, "identity_change_grace_period")

    @property
    @pulumi.getter(name="installIptablesRules")
    def install_iptables_rules(self) -> bool:
        return pulumi.get(self, "install_iptables_rules")

    @property
    @pulumi.getter
    def ipam(self) -> str:
        return pulumi.get(self, "ipam")

    @property
    @pulumi.getter
    def masquerade(self) -> bool:
        return pulumi.get(self, "masquerade")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> str:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter
    def metrics(self) -> Sequence[str]:
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter(name="monitorAggregation")
    def monitor_aggregation(self) -> str:
        return pulumi.get(self, "monitor_aggregation")

    @property
    @pulumi.getter(name="preallocateBpfMaps")
    def preallocate_bpf_maps(self) -> bool:
        return pulumi.get(self, "preallocate_bpf_maps")

    @property
    @pulumi.getter(name="sidecarIstioProxyImage")
    def sidecar_istio_proxy_image(self) -> str:
        return pulumi.get(self, "sidecar_istio_proxy_image")

    @property
    @pulumi.getter(name="toFqdnsDnsRejectResponseCode")
    def to_fqdns_dns_reject_response_code(self) -> str:
        return pulumi.get(self, "to_fqdns_dns_reject_response_code")

    @property
    @pulumi.getter(name="toFqdnsEnablePoller")
    def to_fqdns_enable_poller(self) -> bool:
        return pulumi.get(self, "to_fqdns_enable_poller")

    @property
    @pulumi.getter
    def tunnel(self) -> str:
        return pulumi.get(self, "tunnel")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterNetworkingCiliaHubbleResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 metrics: Sequence[str]):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "metrics", metrics)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def metrics(self) -> Sequence[str]:
        return pulumi.get(self, "metrics")


@pulumi.output_type
class GetClusterNetworkingClassicResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClusterNetworkingCniResult(dict):
    def __init__(__self__, *,
                 uses_secondary_ip: bool):
        pulumi.set(__self__, "uses_secondary_ip", uses_secondary_ip)

    @property
    @pulumi.getter(name="usesSecondaryIp")
    def uses_secondary_ip(self) -> bool:
        return pulumi.get(self, "uses_secondary_ip")


@pulumi.output_type
class GetClusterNetworkingExternalResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClusterNetworkingFlannelResult(dict):
    def __init__(__self__, *,
                 backend: str,
                 iptables_resync_seconds: int):
        pulumi.set(__self__, "backend", backend)
        pulumi.set(__self__, "iptables_resync_seconds", iptables_resync_seconds)

    @property
    @pulumi.getter
    def backend(self) -> str:
        return pulumi.get(self, "backend")

    @property
    @pulumi.getter(name="iptablesResyncSeconds")
    def iptables_resync_seconds(self) -> int:
        return pulumi.get(self, "iptables_resync_seconds")


@pulumi.output_type
class GetClusterNetworkingGceResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClusterNetworkingKopeioResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClusterNetworkingKubenetResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClusterNetworkingKuberouterResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetClusterNetworkingLyftVpcResult(dict):
    def __init__(__self__, *,
                 subnet_tags: Mapping[str, str]):
        pulumi.set(__self__, "subnet_tags", subnet_tags)

    @property
    @pulumi.getter(name="subnetTags")
    def subnet_tags(self) -> Mapping[str, str]:
        return pulumi.get(self, "subnet_tags")


@pulumi.output_type
class GetClusterNetworkingRomanaResult(dict):
    def __init__(__self__, *,
                 daemon_service_ip: str,
                 etcd_service_ip: str):
        pulumi.set(__self__, "daemon_service_ip", daemon_service_ip)
        pulumi.set(__self__, "etcd_service_ip", etcd_service_ip)

    @property
    @pulumi.getter(name="daemonServiceIp")
    def daemon_service_ip(self) -> str:
        return pulumi.get(self, "daemon_service_ip")

    @property
    @pulumi.getter(name="etcdServiceIp")
    def etcd_service_ip(self) -> str:
        return pulumi.get(self, "etcd_service_ip")


@pulumi.output_type
class GetClusterNetworkingWeafeResult(dict):
    def __init__(__self__, *,
                 conn_limit: int,
                 cpu_limit: str,
                 cpu_request: str,
                 memory_limit: str,
                 memory_request: str,
                 mtu: int,
                 net_extra_args: str,
                 no_masq_local: int,
                 npc_cpu_limit: str,
                 npc_cpu_request: str,
                 npc_extra_args: str,
                 npc_memory_limit: str,
                 npc_memory_request: str,
                 version: str):
        pulumi.set(__self__, "conn_limit", conn_limit)
        pulumi.set(__self__, "cpu_limit", cpu_limit)
        pulumi.set(__self__, "cpu_request", cpu_request)
        pulumi.set(__self__, "memory_limit", memory_limit)
        pulumi.set(__self__, "memory_request", memory_request)
        pulumi.set(__self__, "mtu", mtu)
        pulumi.set(__self__, "net_extra_args", net_extra_args)
        pulumi.set(__self__, "no_masq_local", no_masq_local)
        pulumi.set(__self__, "npc_cpu_limit", npc_cpu_limit)
        pulumi.set(__self__, "npc_cpu_request", npc_cpu_request)
        pulumi.set(__self__, "npc_extra_args", npc_extra_args)
        pulumi.set(__self__, "npc_memory_limit", npc_memory_limit)
        pulumi.set(__self__, "npc_memory_request", npc_memory_request)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="connLimit")
    def conn_limit(self) -> int:
        return pulumi.get(self, "conn_limit")

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> str:
        return pulumi.get(self, "cpu_limit")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> str:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> str:
        return pulumi.get(self, "memory_limit")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> str:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter
    def mtu(self) -> int:
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter(name="netExtraArgs")
    def net_extra_args(self) -> str:
        return pulumi.get(self, "net_extra_args")

    @property
    @pulumi.getter(name="noMasqLocal")
    def no_masq_local(self) -> int:
        return pulumi.get(self, "no_masq_local")

    @property
    @pulumi.getter(name="npcCpuLimit")
    def npc_cpu_limit(self) -> str:
        return pulumi.get(self, "npc_cpu_limit")

    @property
    @pulumi.getter(name="npcCpuRequest")
    def npc_cpu_request(self) -> str:
        return pulumi.get(self, "npc_cpu_request")

    @property
    @pulumi.getter(name="npcExtraArgs")
    def npc_extra_args(self) -> str:
        return pulumi.get(self, "npc_extra_args")

    @property
    @pulumi.getter(name="npcMemoryLimit")
    def npc_memory_limit(self) -> str:
        return pulumi.get(self, "npc_memory_limit")

    @property
    @pulumi.getter(name="npcMemoryRequest")
    def npc_memory_request(self) -> str:
        return pulumi.get(self, "npc_memory_request")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterNodeAuthorizationResult(dict):
    def __init__(__self__, *,
                 node_authorizers: Sequence['outputs.GetClusterNodeAuthorizationNodeAuthorizerResult']):
        pulumi.set(__self__, "node_authorizers", node_authorizers)

    @property
    @pulumi.getter(name="nodeAuthorizers")
    def node_authorizers(self) -> Sequence['outputs.GetClusterNodeAuthorizationNodeAuthorizerResult']:
        return pulumi.get(self, "node_authorizers")


@pulumi.output_type
class GetClusterNodeAuthorizationNodeAuthorizerResult(dict):
    def __init__(__self__, *,
                 authorizer: str,
                 features: Sequence[str],
                 image: str,
                 interval: str,
                 node_url: str,
                 port: int,
                 timeout: str,
                 token_ttl: str):
        pulumi.set(__self__, "authorizer", authorizer)
        pulumi.set(__self__, "features", features)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "node_url", node_url)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "token_ttl", token_ttl)

    @property
    @pulumi.getter
    def authorizer(self) -> str:
        return pulumi.get(self, "authorizer")

    @property
    @pulumi.getter
    def features(self) -> Sequence[str]:
        return pulumi.get(self, "features")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def interval(self) -> str:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="nodeUrl")
    def node_url(self) -> str:
        return pulumi.get(self, "node_url")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def timeout(self) -> str:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tokenTtl")
    def token_ttl(self) -> str:
        return pulumi.get(self, "token_ttl")


@pulumi.output_type
class GetClusterNodeProblemDetectorResult(dict):
    def __init__(__self__, *,
                 cpu_limit: str,
                 cpu_request: str,
                 enabled: bool,
                 image: str,
                 memory_limit: str,
                 memory_request: str):
        pulumi.set(__self__, "cpu_limit", cpu_limit)
        pulumi.set(__self__, "cpu_request", cpu_request)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "memory_limit", memory_limit)
        pulumi.set(__self__, "memory_request", memory_request)

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> str:
        return pulumi.get(self, "cpu_limit")

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> str:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> str:
        return pulumi.get(self, "memory_limit")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> str:
        return pulumi.get(self, "memory_request")


@pulumi.output_type
class GetClusterNodeTerminationHandlerResult(dict):
    def __init__(__self__, *,
                 cpu_request: str,
                 enable_prometheus_metrics: bool,
                 enable_rebalance_draining: bool,
                 enable_rebalance_monitoring: bool,
                 enable_scheduled_event_draining: bool,
                 enable_spot_interruption_draining: bool,
                 enable_sqs_termination_draining: bool,
                 enabled: bool,
                 exclude_from_load_balancers: bool,
                 managed_asg_tag: str,
                 memory_request: str,
                 version: str):
        pulumi.set(__self__, "cpu_request", cpu_request)
        pulumi.set(__self__, "enable_prometheus_metrics", enable_prometheus_metrics)
        pulumi.set(__self__, "enable_rebalance_draining", enable_rebalance_draining)
        pulumi.set(__self__, "enable_rebalance_monitoring", enable_rebalance_monitoring)
        pulumi.set(__self__, "enable_scheduled_event_draining", enable_scheduled_event_draining)
        pulumi.set(__self__, "enable_spot_interruption_draining", enable_spot_interruption_draining)
        pulumi.set(__self__, "enable_sqs_termination_draining", enable_sqs_termination_draining)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "exclude_from_load_balancers", exclude_from_load_balancers)
        pulumi.set(__self__, "managed_asg_tag", managed_asg_tag)
        pulumi.set(__self__, "memory_request", memory_request)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> str:
        return pulumi.get(self, "cpu_request")

    @property
    @pulumi.getter(name="enablePrometheusMetrics")
    def enable_prometheus_metrics(self) -> bool:
        return pulumi.get(self, "enable_prometheus_metrics")

    @property
    @pulumi.getter(name="enableRebalanceDraining")
    def enable_rebalance_draining(self) -> bool:
        return pulumi.get(self, "enable_rebalance_draining")

    @property
    @pulumi.getter(name="enableRebalanceMonitoring")
    def enable_rebalance_monitoring(self) -> bool:
        return pulumi.get(self, "enable_rebalance_monitoring")

    @property
    @pulumi.getter(name="enableScheduledEventDraining")
    def enable_scheduled_event_draining(self) -> bool:
        return pulumi.get(self, "enable_scheduled_event_draining")

    @property
    @pulumi.getter(name="enableSpotInterruptionDraining")
    def enable_spot_interruption_draining(self) -> bool:
        return pulumi.get(self, "enable_spot_interruption_draining")

    @property
    @pulumi.getter(name="enableSqsTerminationDraining")
    def enable_sqs_termination_draining(self) -> bool:
        return pulumi.get(self, "enable_sqs_termination_draining")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="excludeFromLoadBalancers")
    def exclude_from_load_balancers(self) -> bool:
        return pulumi.get(self, "exclude_from_load_balancers")

    @property
    @pulumi.getter(name="managedAsgTag")
    def managed_asg_tag(self) -> str:
        return pulumi.get(self, "managed_asg_tag")

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> str:
        return pulumi.get(self, "memory_request")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterNtpResult(dict):
    def __init__(__self__, *,
                 managed: bool):
        pulumi.set(__self__, "managed", managed)

    @property
    @pulumi.getter
    def managed(self) -> bool:
        return pulumi.get(self, "managed")


@pulumi.output_type
class GetClusterPodIdentityWebhookResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 replicas: int):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "replicas", replicas)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def replicas(self) -> int:
        return pulumi.get(self, "replicas")


@pulumi.output_type
class GetClusterRollingUpdateResult(dict):
    def __init__(__self__, *,
                 drain_and_terminate: bool,
                 max_surge: str,
                 max_unavailable: str):
        pulumi.set(__self__, "drain_and_terminate", drain_and_terminate)
        pulumi.set(__self__, "max_surge", max_surge)
        pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="drainAndTerminate")
    def drain_and_terminate(self) -> bool:
        return pulumi.get(self, "drain_and_terminate")

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> str:
        return pulumi.get(self, "max_surge")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> str:
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class GetClusterSecretResult(dict):
    def __init__(__self__, *,
                 cluster_ca_cert: str,
                 cluster_ca_key: str,
                 docker_config: str):
        pulumi.set(__self__, "cluster_ca_cert", cluster_ca_cert)
        pulumi.set(__self__, "cluster_ca_key", cluster_ca_key)
        pulumi.set(__self__, "docker_config", docker_config)

    @property
    @pulumi.getter(name="clusterCaCert")
    def cluster_ca_cert(self) -> str:
        return pulumi.get(self, "cluster_ca_cert")

    @property
    @pulumi.getter(name="clusterCaKey")
    def cluster_ca_key(self) -> str:
        return pulumi.get(self, "cluster_ca_key")

    @property
    @pulumi.getter(name="dockerConfig")
    def docker_config(self) -> str:
        return pulumi.get(self, "docker_config")


@pulumi.output_type
class GetClusterServiceAccountIssuerDiscoveryResult(dict):
    def __init__(__self__, *,
                 additional_audiences: Sequence[str],
                 discovery_store: str,
                 enable_aws_oidc_provider: bool):
        pulumi.set(__self__, "additional_audiences", additional_audiences)
        pulumi.set(__self__, "discovery_store", discovery_store)
        pulumi.set(__self__, "enable_aws_oidc_provider", enable_aws_oidc_provider)

    @property
    @pulumi.getter(name="additionalAudiences")
    def additional_audiences(self) -> Sequence[str]:
        return pulumi.get(self, "additional_audiences")

    @property
    @pulumi.getter(name="discoveryStore")
    def discovery_store(self) -> str:
        return pulumi.get(self, "discovery_store")

    @property
    @pulumi.getter(name="enableAwsOidcProvider")
    def enable_aws_oidc_provider(self) -> bool:
        return pulumi.get(self, "enable_aws_oidc_provider")


@pulumi.output_type
class GetClusterSnapshotControllerResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 install_default_class: bool):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "install_default_class", install_default_class)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="installDefaultClass")
    def install_default_class(self) -> bool:
        return pulumi.get(self, "install_default_class")


@pulumi.output_type
class GetClusterSubnetResult(dict):
    def __init__(__self__, *,
                 additional_routes: Sequence['outputs.GetClusterSubnetAdditionalRouteResult'],
                 cidr: str,
                 egress: str,
                 ipv6_cidr: str,
                 name: str,
                 provider_id: str,
                 public_ip: str,
                 region: str,
                 type: str,
                 zone: str):
        """
        :param str name: - String - Name defines the cluster name.
        """
        pulumi.set(__self__, "additional_routes", additional_routes)
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "egress", egress)
        pulumi.set(__self__, "ipv6_cidr", ipv6_cidr)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider_id", provider_id)
        pulumi.set(__self__, "public_ip", public_ip)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="additionalRoutes")
    def additional_routes(self) -> Sequence['outputs.GetClusterSubnetAdditionalRouteResult']:
        return pulumi.get(self, "additional_routes")

    @property
    @pulumi.getter
    def cidr(self) -> str:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def egress(self) -> str:
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter(name="ipv6Cidr")
    def ipv6_cidr(self) -> str:
        return pulumi.get(self, "ipv6_cidr")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> str:
        return pulumi.get(self, "provider_id")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> str:
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> str:
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetClusterSubnetAdditionalRouteResult(dict):
    def __init__(__self__, *,
                 cidr: str,
                 target: str):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")


@pulumi.output_type
class GetClusterTagSubnetsResult(dict):
    def __init__(__self__, *,
                 value: bool):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterTopologyResult(dict):
    def __init__(__self__, *,
                 bastions: Sequence['outputs.GetClusterTopologyBastionResult'],
                 dns: Sequence['outputs.GetClusterTopologyDnResult'],
                 masters: str,
                 nodes: str):
        pulumi.set(__self__, "bastions", bastions)
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "masters", masters)
        pulumi.set(__self__, "nodes", nodes)

    @property
    @pulumi.getter
    def bastions(self) -> Sequence['outputs.GetClusterTopologyBastionResult']:
        return pulumi.get(self, "bastions")

    @property
    @pulumi.getter
    def dns(self) -> Sequence['outputs.GetClusterTopologyDnResult']:
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def masters(self) -> str:
        return pulumi.get(self, "masters")

    @property
    @pulumi.getter
    def nodes(self) -> str:
        return pulumi.get(self, "nodes")


@pulumi.output_type
class GetClusterTopologyBastionResult(dict):
    def __init__(__self__, *,
                 bastion_public_name: str,
                 idle_timeout_seconds: int,
                 load_balancers: Sequence['outputs.GetClusterTopologyBastionLoadBalancerResult']):
        pulumi.set(__self__, "bastion_public_name", bastion_public_name)
        pulumi.set(__self__, "idle_timeout_seconds", idle_timeout_seconds)
        pulumi.set(__self__, "load_balancers", load_balancers)

    @property
    @pulumi.getter(name="bastionPublicName")
    def bastion_public_name(self) -> str:
        return pulumi.get(self, "bastion_public_name")

    @property
    @pulumi.getter(name="idleTimeoutSeconds")
    def idle_timeout_seconds(self) -> int:
        return pulumi.get(self, "idle_timeout_seconds")

    @property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> Sequence['outputs.GetClusterTopologyBastionLoadBalancerResult']:
        return pulumi.get(self, "load_balancers")


@pulumi.output_type
class GetClusterTopologyBastionLoadBalancerResult(dict):
    def __init__(__self__, *,
                 additional_security_groups: Sequence[str],
                 type: str):
        pulumi.set(__self__, "additional_security_groups", additional_security_groups)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="additionalSecurityGroups")
    def additional_security_groups(self) -> Sequence[str]:
        return pulumi.get(self, "additional_security_groups")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClusterTopologyDnResult(dict):
    def __init__(__self__, *,
                 type: str):
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClusterWarmPoolResult(dict):
    def __init__(__self__, *,
                 enable_lifecycle_hook: bool,
                 max_size: int,
                 min_size: int):
        pulumi.set(__self__, "enable_lifecycle_hook", enable_lifecycle_hook)
        pulumi.set(__self__, "max_size", max_size)
        pulumi.set(__self__, "min_size", min_size)

    @property
    @pulumi.getter(name="enableLifecycleHook")
    def enable_lifecycle_hook(self) -> bool:
        return pulumi.get(self, "enable_lifecycle_hook")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> int:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> int:
        return pulumi.get(self, "min_size")


@pulumi.output_type
class GetInstanceGroupAdditionalUserDataResult(dict):
    def __init__(__self__, *,
                 content: str,
                 name: str,
                 type: str):
        """
        :param str name: - String - Name defines the instance group name.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - String - Name defines the instance group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInstanceGroupContainerdResult(dict):
    def __init__(__self__, *,
                 address: str,
                 config_override: str,
                 log_level: str,
                 nvidia_gpus: Sequence['outputs.GetInstanceGroupContainerdNvidiaGpusResult'],
                 packages: Sequence['outputs.GetInstanceGroupContainerdPackageResult'],
                 registry_mirrors: Sequence['outputs.GetInstanceGroupContainerdRegistryMirrorResult'],
                 root: str,
                 runcs: Sequence['outputs.GetInstanceGroupContainerdRuncResult'],
                 skip_install: bool,
                 state: str,
                 version: str):
        """
        :param Sequence['GetInstanceGroupContainerdPackageArgs'] packages: - List(String) - Packages specifies additional packages to be installed.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "config_override", config_override)
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "nvidia_gpus", nvidia_gpus)
        pulumi.set(__self__, "packages", packages)
        pulumi.set(__self__, "registry_mirrors", registry_mirrors)
        pulumi.set(__self__, "root", root)
        pulumi.set(__self__, "runcs", runcs)
        pulumi.set(__self__, "skip_install", skip_install)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="configOverride")
    def config_override(self) -> str:
        return pulumi.get(self, "config_override")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> str:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="nvidiaGpus")
    def nvidia_gpus(self) -> Sequence['outputs.GetInstanceGroupContainerdNvidiaGpusResult']:
        return pulumi.get(self, "nvidia_gpus")

    @property
    @pulumi.getter
    def packages(self) -> Sequence['outputs.GetInstanceGroupContainerdPackageResult']:
        """
        - List(String) - Packages specifies additional packages to be installed.
        """
        return pulumi.get(self, "packages")

    @property
    @pulumi.getter(name="registryMirrors")
    def registry_mirrors(self) -> Sequence['outputs.GetInstanceGroupContainerdRegistryMirrorResult']:
        return pulumi.get(self, "registry_mirrors")

    @property
    @pulumi.getter
    def root(self) -> str:
        return pulumi.get(self, "root")

    @property
    @pulumi.getter
    def runcs(self) -> Sequence['outputs.GetInstanceGroupContainerdRuncResult']:
        return pulumi.get(self, "runcs")

    @property
    @pulumi.getter(name="skipInstall")
    def skip_install(self) -> bool:
        return pulumi.get(self, "skip_install")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetInstanceGroupContainerdNvidiaGpusResult(dict):
    def __init__(__self__, *,
                 driver_package: str,
                 enabled: bool):
        pulumi.set(__self__, "driver_package", driver_package)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="driverPackage")
    def driver_package(self) -> str:
        return pulumi.get(self, "driver_package")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetInstanceGroupContainerdPackageResult(dict):
    def __init__(__self__, *,
                 hash_amd64: str,
                 hash_arm64: str,
                 url_amd64: str,
                 url_arm64: str):
        pulumi.set(__self__, "hash_amd64", hash_amd64)
        pulumi.set(__self__, "hash_arm64", hash_arm64)
        pulumi.set(__self__, "url_amd64", url_amd64)
        pulumi.set(__self__, "url_arm64", url_arm64)

    @property
    @pulumi.getter(name="hashAmd64")
    def hash_amd64(self) -> str:
        return pulumi.get(self, "hash_amd64")

    @property
    @pulumi.getter(name="hashArm64")
    def hash_arm64(self) -> str:
        return pulumi.get(self, "hash_arm64")

    @property
    @pulumi.getter(name="urlAmd64")
    def url_amd64(self) -> str:
        return pulumi.get(self, "url_amd64")

    @property
    @pulumi.getter(name="urlArm64")
    def url_arm64(self) -> str:
        return pulumi.get(self, "url_arm64")


@pulumi.output_type
class GetInstanceGroupContainerdRegistryMirrorResult(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInstanceGroupContainerdRuncResult(dict):
    def __init__(__self__, *,
                 packages: Sequence['outputs.GetInstanceGroupContainerdRuncPackageResult'],
                 version: str):
        """
        :param Sequence['GetInstanceGroupContainerdRuncPackageArgs'] packages: - List(String) - Packages specifies additional packages to be installed.
        """
        pulumi.set(__self__, "packages", packages)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def packages(self) -> Sequence['outputs.GetInstanceGroupContainerdRuncPackageResult']:
        """
        - List(String) - Packages specifies additional packages to be installed.
        """
        return pulumi.get(self, "packages")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetInstanceGroupContainerdRuncPackageResult(dict):
    def __init__(__self__, *,
                 hash_amd64: str,
                 hash_arm64: str,
                 url_amd64: str,
                 url_arm64: str):
        pulumi.set(__self__, "hash_amd64", hash_amd64)
        pulumi.set(__self__, "hash_arm64", hash_arm64)
        pulumi.set(__self__, "url_amd64", url_amd64)
        pulumi.set(__self__, "url_arm64", url_arm64)

    @property
    @pulumi.getter(name="hashAmd64")
    def hash_amd64(self) -> str:
        return pulumi.get(self, "hash_amd64")

    @property
    @pulumi.getter(name="hashArm64")
    def hash_arm64(self) -> str:
        return pulumi.get(self, "hash_arm64")

    @property
    @pulumi.getter(name="urlAmd64")
    def url_amd64(self) -> str:
        return pulumi.get(self, "url_amd64")

    @property
    @pulumi.getter(name="urlArm64")
    def url_arm64(self) -> str:
        return pulumi.get(self, "url_arm64")


@pulumi.output_type
class GetInstanceGroupExternalLoadBalancerResult(dict):
    def __init__(__self__, *,
                 load_balancer_name: str,
                 target_group_arn: str):
        pulumi.set(__self__, "load_balancer_name", load_balancer_name)
        pulumi.set(__self__, "target_group_arn", target_group_arn)

    @property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> str:
        return pulumi.get(self, "load_balancer_name")

    @property
    @pulumi.getter(name="targetGroupArn")
    def target_group_arn(self) -> str:
        return pulumi.get(self, "target_group_arn")


@pulumi.output_type
class GetInstanceGroupFileAssetResult(dict):
    def __init__(__self__, *,
                 content: str,
                 is_base64: bool,
                 mode: str,
                 name: str,
                 path: str,
                 roles: Sequence[str]):
        """
        :param str name: - String - Name defines the instance group name.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "is_base64", is_base64)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="isBase64")
    def is_base64(self) -> bool:
        return pulumi.get(self, "is_base64")

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - String - Name defines the instance group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def roles(self) -> Sequence[str]:
        return pulumi.get(self, "roles")


@pulumi.output_type
class GetInstanceGroupGuestAcceleratorResult(dict):
    def __init__(__self__, *,
                 accelerator_count: int,
                 accelerator_type: str):
        pulumi.set(__self__, "accelerator_count", accelerator_count)
        pulumi.set(__self__, "accelerator_type", accelerator_type)

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> int:
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorType")
    def accelerator_type(self) -> str:
        return pulumi.get(self, "accelerator_type")


@pulumi.output_type
class GetInstanceGroupHookResult(dict):
    def __init__(__self__, *,
                 befores: Sequence[str],
                 enabled: bool,
                 exec_containers: Sequence['outputs.GetInstanceGroupHookExecContainerResult'],
                 manifest: str,
                 name: str,
                 requires: Sequence[str],
                 roles: Sequence[str],
                 use_raw_manifest: bool):
        """
        :param str name: - String - Name defines the instance group name.
        """
        pulumi.set(__self__, "befores", befores)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "exec_containers", exec_containers)
        pulumi.set(__self__, "manifest", manifest)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "requires", requires)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "use_raw_manifest", use_raw_manifest)

    @property
    @pulumi.getter
    def befores(self) -> Sequence[str]:
        return pulumi.get(self, "befores")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="execContainers")
    def exec_containers(self) -> Sequence['outputs.GetInstanceGroupHookExecContainerResult']:
        return pulumi.get(self, "exec_containers")

    @property
    @pulumi.getter
    def manifest(self) -> str:
        return pulumi.get(self, "manifest")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - String - Name defines the instance group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def requires(self) -> Sequence[str]:
        return pulumi.get(self, "requires")

    @property
    @pulumi.getter
    def roles(self) -> Sequence[str]:
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter(name="useRawManifest")
    def use_raw_manifest(self) -> bool:
        return pulumi.get(self, "use_raw_manifest")


@pulumi.output_type
class GetInstanceGroupHookExecContainerResult(dict):
    def __init__(__self__, *,
                 commands: Sequence[str],
                 environment: Mapping[str, str],
                 image: str):
        """
        :param str image: - String - Image is the instance (ami etc) we should use.
        """
        pulumi.set(__self__, "commands", commands)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def environment(self) -> Mapping[str, str]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def image(self) -> str:
        """
        - String - Image is the instance (ami etc) we should use.
        """
        return pulumi.get(self, "image")


@pulumi.output_type
class GetInstanceGroupIamResult(dict):
    def __init__(__self__, *,
                 profile: str):
        pulumi.set(__self__, "profile", profile)

    @property
    @pulumi.getter
    def profile(self) -> str:
        return pulumi.get(self, "profile")


@pulumi.output_type
class GetInstanceGroupInstanceMetadataResult(dict):
    def __init__(__self__, *,
                 http_put_response_hop_limit: int,
                 http_tokens: str):
        pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        pulumi.set(__self__, "http_tokens", http_tokens)

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> int:
        return pulumi.get(self, "http_put_response_hop_limit")

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> str:
        return pulumi.get(self, "http_tokens")


@pulumi.output_type
class GetInstanceGroupKubeletResult(dict):
    def __init__(__self__, *,
                 allow_privileged: bool,
                 allowed_unsafe_sysctls: Sequence[str],
                 api_servers: str,
                 authentication_token_webhook: bool,
                 authentication_token_webhook_cache_ttl: str,
                 authorization_mode: str,
                 babysit_daemons: bool,
                 bootstrap_kubeconfig: str,
                 cgroup_driver: str,
                 cgroup_root: str,
                 client_ca_file: str,
                 cloud_provider: str,
                 cluster_dns: str,
                 cluster_domain: str,
                 configure_cbr0: bool,
                 container_log_max_files: int,
                 container_log_max_size: str,
                 cpu_cfs_quota_period: str,
                 cpu_manager_policy: str,
                 docker_disable_shared_pid: bool,
                 enable_cadvisor_json_endpoints: bool,
                 enable_custom_metrics: bool,
                 enable_debugging_handlers: bool,
                 enforce_node_allocatable: str,
                 event_burst: int,
                 event_qps: int,
                 eviction_hard: str,
                 eviction_max_pod_grace_period: int,
                 eviction_minimum_reclaim: str,
                 eviction_pressure_transition_period: str,
                 eviction_soft: str,
                 eviction_soft_grace_period: str,
                 experimental_allowed_unsafe_sysctls: Sequence[str],
                 fail_swap_on: bool,
                 feature_gates: Mapping[str, str],
                 hairpin_mode: str,
                 hostname_override: str,
                 housekeeping_interval: str,
                 image_gc_high_threshold_percent: int,
                 image_gc_low_threshold_percent: int,
                 image_pull_progress_deadline: str,
                 kernel_memcg_notification: bool,
                 kube_reserved: Mapping[str, str],
                 kube_reserved_cgroup: str,
                 kubeconfig_path: str,
                 kubelet_cgroups: str,
                 log_format: str,
                 log_level: int,
                 max_pods: int,
                 network_plugin_mtu: int,
                 network_plugin_name: str,
                 node_labels: Mapping[str, str],
                 node_status_update_frequency: str,
                 non_masquerade_cidr: str,
                 nvidia_gp_us: int,
                 pod_cidr: str,
                 pod_infra_container_image: str,
                 pod_manifest_path: str,
                 pod_pids_limit: int,
                 protect_kernel_defaults: bool,
                 read_only_port: int,
                 reconcile_cidr: bool,
                 register_node: bool,
                 register_schedulable: bool,
                 registry_burst: int,
                 registry_pull_qps: int,
                 require_kubeconfig: bool,
                 resolver_config: str,
                 root_dir: str,
                 rotate_certificates: bool,
                 runtime_cgroups: str,
                 runtime_request_timeout: str,
                 seccomp_profile_root: str,
                 serialize_image_pulls: bool,
                 shutdown_grace_period: str,
                 shutdown_grace_period_critical_pods: str,
                 streaming_connection_idle_timeout: str,
                 system_cgroups: str,
                 system_reserved: Mapping[str, str],
                 system_reserved_cgroup: str,
                 taints: Sequence[str],
                 tls_cert_file: str,
                 tls_cipher_suites: Sequence[str],
                 tls_min_version: str,
                 tls_private_key_file: str,
                 topology_manager_policy: str,
                 volume_plugin_directory: str,
                 volume_stats_agg_period: str,
                 anonymous_auth: Optional['outputs.GetInstanceGroupKubeletAnonymousAuthResult'] = None,
                 cpu_cfs_quota: Optional['outputs.GetInstanceGroupKubeletCpuCfsQuotaResult'] = None):
        """
        :param Mapping[str, str] node_labels: - Map(String) - NodeLabels indicates the kubernetes labels for nodes in this instance group.
        :param Sequence[str] taints: - List(String) - Taints indicates the kubernetes taints for nodes in this instance group.
        """
        pulumi.set(__self__, "allow_privileged", allow_privileged)
        pulumi.set(__self__, "allowed_unsafe_sysctls", allowed_unsafe_sysctls)
        pulumi.set(__self__, "api_servers", api_servers)
        pulumi.set(__self__, "authentication_token_webhook", authentication_token_webhook)
        pulumi.set(__self__, "authentication_token_webhook_cache_ttl", authentication_token_webhook_cache_ttl)
        pulumi.set(__self__, "authorization_mode", authorization_mode)
        pulumi.set(__self__, "babysit_daemons", babysit_daemons)
        pulumi.set(__self__, "bootstrap_kubeconfig", bootstrap_kubeconfig)
        pulumi.set(__self__, "cgroup_driver", cgroup_driver)
        pulumi.set(__self__, "cgroup_root", cgroup_root)
        pulumi.set(__self__, "client_ca_file", client_ca_file)
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "cluster_dns", cluster_dns)
        pulumi.set(__self__, "cluster_domain", cluster_domain)
        pulumi.set(__self__, "configure_cbr0", configure_cbr0)
        pulumi.set(__self__, "container_log_max_files", container_log_max_files)
        pulumi.set(__self__, "container_log_max_size", container_log_max_size)
        pulumi.set(__self__, "cpu_cfs_quota_period", cpu_cfs_quota_period)
        pulumi.set(__self__, "cpu_manager_policy", cpu_manager_policy)
        pulumi.set(__self__, "docker_disable_shared_pid", docker_disable_shared_pid)
        pulumi.set(__self__, "enable_cadvisor_json_endpoints", enable_cadvisor_json_endpoints)
        pulumi.set(__self__, "enable_custom_metrics", enable_custom_metrics)
        pulumi.set(__self__, "enable_debugging_handlers", enable_debugging_handlers)
        pulumi.set(__self__, "enforce_node_allocatable", enforce_node_allocatable)
        pulumi.set(__self__, "event_burst", event_burst)
        pulumi.set(__self__, "event_qps", event_qps)
        pulumi.set(__self__, "eviction_hard", eviction_hard)
        pulumi.set(__self__, "eviction_max_pod_grace_period", eviction_max_pod_grace_period)
        pulumi.set(__self__, "eviction_minimum_reclaim", eviction_minimum_reclaim)
        pulumi.set(__self__, "eviction_pressure_transition_period", eviction_pressure_transition_period)
        pulumi.set(__self__, "eviction_soft", eviction_soft)
        pulumi.set(__self__, "eviction_soft_grace_period", eviction_soft_grace_period)
        pulumi.set(__self__, "experimental_allowed_unsafe_sysctls", experimental_allowed_unsafe_sysctls)
        pulumi.set(__self__, "fail_swap_on", fail_swap_on)
        pulumi.set(__self__, "feature_gates", feature_gates)
        pulumi.set(__self__, "hairpin_mode", hairpin_mode)
        pulumi.set(__self__, "hostname_override", hostname_override)
        pulumi.set(__self__, "housekeeping_interval", housekeeping_interval)
        pulumi.set(__self__, "image_gc_high_threshold_percent", image_gc_high_threshold_percent)
        pulumi.set(__self__, "image_gc_low_threshold_percent", image_gc_low_threshold_percent)
        pulumi.set(__self__, "image_pull_progress_deadline", image_pull_progress_deadline)
        pulumi.set(__self__, "kernel_memcg_notification", kernel_memcg_notification)
        pulumi.set(__self__, "kube_reserved", kube_reserved)
        pulumi.set(__self__, "kube_reserved_cgroup", kube_reserved_cgroup)
        pulumi.set(__self__, "kubeconfig_path", kubeconfig_path)
        pulumi.set(__self__, "kubelet_cgroups", kubelet_cgroups)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "max_pods", max_pods)
        pulumi.set(__self__, "network_plugin_mtu", network_plugin_mtu)
        pulumi.set(__self__, "network_plugin_name", network_plugin_name)
        pulumi.set(__self__, "node_labels", node_labels)
        pulumi.set(__self__, "node_status_update_frequency", node_status_update_frequency)
        pulumi.set(__self__, "non_masquerade_cidr", non_masquerade_cidr)
        pulumi.set(__self__, "nvidia_gp_us", nvidia_gp_us)
        pulumi.set(__self__, "pod_cidr", pod_cidr)
        pulumi.set(__self__, "pod_infra_container_image", pod_infra_container_image)
        pulumi.set(__self__, "pod_manifest_path", pod_manifest_path)
        pulumi.set(__self__, "pod_pids_limit", pod_pids_limit)
        pulumi.set(__self__, "protect_kernel_defaults", protect_kernel_defaults)
        pulumi.set(__self__, "read_only_port", read_only_port)
        pulumi.set(__self__, "reconcile_cidr", reconcile_cidr)
        pulumi.set(__self__, "register_node", register_node)
        pulumi.set(__self__, "register_schedulable", register_schedulable)
        pulumi.set(__self__, "registry_burst", registry_burst)
        pulumi.set(__self__, "registry_pull_qps", registry_pull_qps)
        pulumi.set(__self__, "require_kubeconfig", require_kubeconfig)
        pulumi.set(__self__, "resolver_config", resolver_config)
        pulumi.set(__self__, "root_dir", root_dir)
        pulumi.set(__self__, "rotate_certificates", rotate_certificates)
        pulumi.set(__self__, "runtime_cgroups", runtime_cgroups)
        pulumi.set(__self__, "runtime_request_timeout", runtime_request_timeout)
        pulumi.set(__self__, "seccomp_profile_root", seccomp_profile_root)
        pulumi.set(__self__, "serialize_image_pulls", serialize_image_pulls)
        pulumi.set(__self__, "shutdown_grace_period", shutdown_grace_period)
        pulumi.set(__self__, "shutdown_grace_period_critical_pods", shutdown_grace_period_critical_pods)
        pulumi.set(__self__, "streaming_connection_idle_timeout", streaming_connection_idle_timeout)
        pulumi.set(__self__, "system_cgroups", system_cgroups)
        pulumi.set(__self__, "system_reserved", system_reserved)
        pulumi.set(__self__, "system_reserved_cgroup", system_reserved_cgroup)
        pulumi.set(__self__, "taints", taints)
        pulumi.set(__self__, "tls_cert_file", tls_cert_file)
        pulumi.set(__self__, "tls_cipher_suites", tls_cipher_suites)
        pulumi.set(__self__, "tls_min_version", tls_min_version)
        pulumi.set(__self__, "tls_private_key_file", tls_private_key_file)
        pulumi.set(__self__, "topology_manager_policy", topology_manager_policy)
        pulumi.set(__self__, "volume_plugin_directory", volume_plugin_directory)
        pulumi.set(__self__, "volume_stats_agg_period", volume_stats_agg_period)
        if anonymous_auth is not None:
            pulumi.set(__self__, "anonymous_auth", anonymous_auth)
        if cpu_cfs_quota is not None:
            pulumi.set(__self__, "cpu_cfs_quota", cpu_cfs_quota)

    @property
    @pulumi.getter(name="allowPrivileged")
    def allow_privileged(self) -> bool:
        return pulumi.get(self, "allow_privileged")

    @property
    @pulumi.getter(name="allowedUnsafeSysctls")
    def allowed_unsafe_sysctls(self) -> Sequence[str]:
        return pulumi.get(self, "allowed_unsafe_sysctls")

    @property
    @pulumi.getter(name="apiServers")
    def api_servers(self) -> str:
        return pulumi.get(self, "api_servers")

    @property
    @pulumi.getter(name="authenticationTokenWebhook")
    def authentication_token_webhook(self) -> bool:
        return pulumi.get(self, "authentication_token_webhook")

    @property
    @pulumi.getter(name="authenticationTokenWebhookCacheTtl")
    def authentication_token_webhook_cache_ttl(self) -> str:
        return pulumi.get(self, "authentication_token_webhook_cache_ttl")

    @property
    @pulumi.getter(name="authorizationMode")
    def authorization_mode(self) -> str:
        return pulumi.get(self, "authorization_mode")

    @property
    @pulumi.getter(name="babysitDaemons")
    def babysit_daemons(self) -> bool:
        return pulumi.get(self, "babysit_daemons")

    @property
    @pulumi.getter(name="bootstrapKubeconfig")
    def bootstrap_kubeconfig(self) -> str:
        return pulumi.get(self, "bootstrap_kubeconfig")

    @property
    @pulumi.getter(name="cgroupDriver")
    def cgroup_driver(self) -> str:
        return pulumi.get(self, "cgroup_driver")

    @property
    @pulumi.getter(name="cgroupRoot")
    def cgroup_root(self) -> str:
        return pulumi.get(self, "cgroup_root")

    @property
    @pulumi.getter(name="clientCaFile")
    def client_ca_file(self) -> str:
        return pulumi.get(self, "client_ca_file")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="clusterDns")
    def cluster_dns(self) -> str:
        return pulumi.get(self, "cluster_dns")

    @property
    @pulumi.getter(name="clusterDomain")
    def cluster_domain(self) -> str:
        return pulumi.get(self, "cluster_domain")

    @property
    @pulumi.getter(name="configureCbr0")
    def configure_cbr0(self) -> bool:
        return pulumi.get(self, "configure_cbr0")

    @property
    @pulumi.getter(name="containerLogMaxFiles")
    def container_log_max_files(self) -> int:
        return pulumi.get(self, "container_log_max_files")

    @property
    @pulumi.getter(name="containerLogMaxSize")
    def container_log_max_size(self) -> str:
        return pulumi.get(self, "container_log_max_size")

    @property
    @pulumi.getter(name="cpuCfsQuotaPeriod")
    def cpu_cfs_quota_period(self) -> str:
        return pulumi.get(self, "cpu_cfs_quota_period")

    @property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> str:
        return pulumi.get(self, "cpu_manager_policy")

    @property
    @pulumi.getter(name="dockerDisableSharedPid")
    def docker_disable_shared_pid(self) -> bool:
        return pulumi.get(self, "docker_disable_shared_pid")

    @property
    @pulumi.getter(name="enableCadvisorJsonEndpoints")
    def enable_cadvisor_json_endpoints(self) -> bool:
        return pulumi.get(self, "enable_cadvisor_json_endpoints")

    @property
    @pulumi.getter(name="enableCustomMetrics")
    def enable_custom_metrics(self) -> bool:
        return pulumi.get(self, "enable_custom_metrics")

    @property
    @pulumi.getter(name="enableDebuggingHandlers")
    def enable_debugging_handlers(self) -> bool:
        return pulumi.get(self, "enable_debugging_handlers")

    @property
    @pulumi.getter(name="enforceNodeAllocatable")
    def enforce_node_allocatable(self) -> str:
        return pulumi.get(self, "enforce_node_allocatable")

    @property
    @pulumi.getter(name="eventBurst")
    def event_burst(self) -> int:
        return pulumi.get(self, "event_burst")

    @property
    @pulumi.getter(name="eventQps")
    def event_qps(self) -> int:
        return pulumi.get(self, "event_qps")

    @property
    @pulumi.getter(name="evictionHard")
    def eviction_hard(self) -> str:
        return pulumi.get(self, "eviction_hard")

    @property
    @pulumi.getter(name="evictionMaxPodGracePeriod")
    def eviction_max_pod_grace_period(self) -> int:
        return pulumi.get(self, "eviction_max_pod_grace_period")

    @property
    @pulumi.getter(name="evictionMinimumReclaim")
    def eviction_minimum_reclaim(self) -> str:
        return pulumi.get(self, "eviction_minimum_reclaim")

    @property
    @pulumi.getter(name="evictionPressureTransitionPeriod")
    def eviction_pressure_transition_period(self) -> str:
        return pulumi.get(self, "eviction_pressure_transition_period")

    @property
    @pulumi.getter(name="evictionSoft")
    def eviction_soft(self) -> str:
        return pulumi.get(self, "eviction_soft")

    @property
    @pulumi.getter(name="evictionSoftGracePeriod")
    def eviction_soft_grace_period(self) -> str:
        return pulumi.get(self, "eviction_soft_grace_period")

    @property
    @pulumi.getter(name="experimentalAllowedUnsafeSysctls")
    def experimental_allowed_unsafe_sysctls(self) -> Sequence[str]:
        return pulumi.get(self, "experimental_allowed_unsafe_sysctls")

    @property
    @pulumi.getter(name="failSwapOn")
    def fail_swap_on(self) -> bool:
        return pulumi.get(self, "fail_swap_on")

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Mapping[str, str]:
        return pulumi.get(self, "feature_gates")

    @property
    @pulumi.getter(name="hairpinMode")
    def hairpin_mode(self) -> str:
        return pulumi.get(self, "hairpin_mode")

    @property
    @pulumi.getter(name="hostnameOverride")
    def hostname_override(self) -> str:
        return pulumi.get(self, "hostname_override")

    @property
    @pulumi.getter(name="housekeepingInterval")
    def housekeeping_interval(self) -> str:
        return pulumi.get(self, "housekeeping_interval")

    @property
    @pulumi.getter(name="imageGcHighThresholdPercent")
    def image_gc_high_threshold_percent(self) -> int:
        return pulumi.get(self, "image_gc_high_threshold_percent")

    @property
    @pulumi.getter(name="imageGcLowThresholdPercent")
    def image_gc_low_threshold_percent(self) -> int:
        return pulumi.get(self, "image_gc_low_threshold_percent")

    @property
    @pulumi.getter(name="imagePullProgressDeadline")
    def image_pull_progress_deadline(self) -> str:
        return pulumi.get(self, "image_pull_progress_deadline")

    @property
    @pulumi.getter(name="kernelMemcgNotification")
    def kernel_memcg_notification(self) -> bool:
        return pulumi.get(self, "kernel_memcg_notification")

    @property
    @pulumi.getter(name="kubeReserved")
    def kube_reserved(self) -> Mapping[str, str]:
        return pulumi.get(self, "kube_reserved")

    @property
    @pulumi.getter(name="kubeReservedCgroup")
    def kube_reserved_cgroup(self) -> str:
        return pulumi.get(self, "kube_reserved_cgroup")

    @property
    @pulumi.getter(name="kubeconfigPath")
    def kubeconfig_path(self) -> str:
        return pulumi.get(self, "kubeconfig_path")

    @property
    @pulumi.getter(name="kubeletCgroups")
    def kubelet_cgroups(self) -> str:
        return pulumi.get(self, "kubelet_cgroups")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> str:
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> int:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> int:
        return pulumi.get(self, "max_pods")

    @property
    @pulumi.getter(name="networkPluginMtu")
    def network_plugin_mtu(self) -> int:
        return pulumi.get(self, "network_plugin_mtu")

    @property
    @pulumi.getter(name="networkPluginName")
    def network_plugin_name(self) -> str:
        return pulumi.get(self, "network_plugin_name")

    @property
    @pulumi.getter(name="nodeLabels")
    def node_labels(self) -> Mapping[str, str]:
        """
        - Map(String) - NodeLabels indicates the kubernetes labels for nodes in this instance group.
        """
        return pulumi.get(self, "node_labels")

    @property
    @pulumi.getter(name="nodeStatusUpdateFrequency")
    def node_status_update_frequency(self) -> str:
        return pulumi.get(self, "node_status_update_frequency")

    @property
    @pulumi.getter(name="nonMasqueradeCidr")
    def non_masquerade_cidr(self) -> str:
        return pulumi.get(self, "non_masquerade_cidr")

    @property
    @pulumi.getter(name="nvidiaGpUs")
    def nvidia_gp_us(self) -> int:
        return pulumi.get(self, "nvidia_gp_us")

    @property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> str:
        return pulumi.get(self, "pod_cidr")

    @property
    @pulumi.getter(name="podInfraContainerImage")
    def pod_infra_container_image(self) -> str:
        return pulumi.get(self, "pod_infra_container_image")

    @property
    @pulumi.getter(name="podManifestPath")
    def pod_manifest_path(self) -> str:
        return pulumi.get(self, "pod_manifest_path")

    @property
    @pulumi.getter(name="podPidsLimit")
    def pod_pids_limit(self) -> int:
        return pulumi.get(self, "pod_pids_limit")

    @property
    @pulumi.getter(name="protectKernelDefaults")
    def protect_kernel_defaults(self) -> bool:
        return pulumi.get(self, "protect_kernel_defaults")

    @property
    @pulumi.getter(name="readOnlyPort")
    def read_only_port(self) -> int:
        return pulumi.get(self, "read_only_port")

    @property
    @pulumi.getter(name="reconcileCidr")
    def reconcile_cidr(self) -> bool:
        return pulumi.get(self, "reconcile_cidr")

    @property
    @pulumi.getter(name="registerNode")
    def register_node(self) -> bool:
        return pulumi.get(self, "register_node")

    @property
    @pulumi.getter(name="registerSchedulable")
    def register_schedulable(self) -> bool:
        return pulumi.get(self, "register_schedulable")

    @property
    @pulumi.getter(name="registryBurst")
    def registry_burst(self) -> int:
        return pulumi.get(self, "registry_burst")

    @property
    @pulumi.getter(name="registryPullQps")
    def registry_pull_qps(self) -> int:
        return pulumi.get(self, "registry_pull_qps")

    @property
    @pulumi.getter(name="requireKubeconfig")
    def require_kubeconfig(self) -> bool:
        return pulumi.get(self, "require_kubeconfig")

    @property
    @pulumi.getter(name="resolverConfig")
    def resolver_config(self) -> str:
        return pulumi.get(self, "resolver_config")

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> str:
        return pulumi.get(self, "root_dir")

    @property
    @pulumi.getter(name="rotateCertificates")
    def rotate_certificates(self) -> bool:
        return pulumi.get(self, "rotate_certificates")

    @property
    @pulumi.getter(name="runtimeCgroups")
    def runtime_cgroups(self) -> str:
        return pulumi.get(self, "runtime_cgroups")

    @property
    @pulumi.getter(name="runtimeRequestTimeout")
    def runtime_request_timeout(self) -> str:
        return pulumi.get(self, "runtime_request_timeout")

    @property
    @pulumi.getter(name="seccompProfileRoot")
    def seccomp_profile_root(self) -> str:
        return pulumi.get(self, "seccomp_profile_root")

    @property
    @pulumi.getter(name="serializeImagePulls")
    def serialize_image_pulls(self) -> bool:
        return pulumi.get(self, "serialize_image_pulls")

    @property
    @pulumi.getter(name="shutdownGracePeriod")
    def shutdown_grace_period(self) -> str:
        return pulumi.get(self, "shutdown_grace_period")

    @property
    @pulumi.getter(name="shutdownGracePeriodCriticalPods")
    def shutdown_grace_period_critical_pods(self) -> str:
        return pulumi.get(self, "shutdown_grace_period_critical_pods")

    @property
    @pulumi.getter(name="streamingConnectionIdleTimeout")
    def streaming_connection_idle_timeout(self) -> str:
        return pulumi.get(self, "streaming_connection_idle_timeout")

    @property
    @pulumi.getter(name="systemCgroups")
    def system_cgroups(self) -> str:
        return pulumi.get(self, "system_cgroups")

    @property
    @pulumi.getter(name="systemReserved")
    def system_reserved(self) -> Mapping[str, str]:
        return pulumi.get(self, "system_reserved")

    @property
    @pulumi.getter(name="systemReservedCgroup")
    def system_reserved_cgroup(self) -> str:
        return pulumi.get(self, "system_reserved_cgroup")

    @property
    @pulumi.getter
    def taints(self) -> Sequence[str]:
        """
        - List(String) - Taints indicates the kubernetes taints for nodes in this instance group.
        """
        return pulumi.get(self, "taints")

    @property
    @pulumi.getter(name="tlsCertFile")
    def tls_cert_file(self) -> str:
        return pulumi.get(self, "tls_cert_file")

    @property
    @pulumi.getter(name="tlsCipherSuites")
    def tls_cipher_suites(self) -> Sequence[str]:
        return pulumi.get(self, "tls_cipher_suites")

    @property
    @pulumi.getter(name="tlsMinVersion")
    def tls_min_version(self) -> str:
        return pulumi.get(self, "tls_min_version")

    @property
    @pulumi.getter(name="tlsPrivateKeyFile")
    def tls_private_key_file(self) -> str:
        return pulumi.get(self, "tls_private_key_file")

    @property
    @pulumi.getter(name="topologyManagerPolicy")
    def topology_manager_policy(self) -> str:
        return pulumi.get(self, "topology_manager_policy")

    @property
    @pulumi.getter(name="volumePluginDirectory")
    def volume_plugin_directory(self) -> str:
        return pulumi.get(self, "volume_plugin_directory")

    @property
    @pulumi.getter(name="volumeStatsAggPeriod")
    def volume_stats_agg_period(self) -> str:
        return pulumi.get(self, "volume_stats_agg_period")

    @property
    @pulumi.getter(name="anonymousAuth")
    def anonymous_auth(self) -> Optional['outputs.GetInstanceGroupKubeletAnonymousAuthResult']:
        return pulumi.get(self, "anonymous_auth")

    @property
    @pulumi.getter(name="cpuCfsQuota")
    def cpu_cfs_quota(self) -> Optional['outputs.GetInstanceGroupKubeletCpuCfsQuotaResult']:
        return pulumi.get(self, "cpu_cfs_quota")


@pulumi.output_type
class GetInstanceGroupKubeletAnonymousAuthResult(dict):
    def __init__(__self__, *,
                 value: bool):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetInstanceGroupKubeletCpuCfsQuotaResult(dict):
    def __init__(__self__, *,
                 value: bool):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> bool:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetInstanceGroupMixedInstancesPolicyResult(dict):
    def __init__(__self__, *,
                 instance_requirements: Sequence['outputs.GetInstanceGroupMixedInstancesPolicyInstanceRequirementResult'],
                 instances: Sequence[str],
                 on_demand_allocation_strategy: str,
                 spot_allocation_strategy: str,
                 spot_instance_pools: int,
                 on_demand_above_base: Optional['outputs.GetInstanceGroupMixedInstancesPolicyOnDemandAboveBaseResult'] = None,
                 on_demand_base: Optional['outputs.GetInstanceGroupMixedInstancesPolicyOnDemandBaseResult'] = None):
        pulumi.set(__self__, "instance_requirements", instance_requirements)
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "on_demand_allocation_strategy", on_demand_allocation_strategy)
        pulumi.set(__self__, "spot_allocation_strategy", spot_allocation_strategy)
        pulumi.set(__self__, "spot_instance_pools", spot_instance_pools)
        if on_demand_above_base is not None:
            pulumi.set(__self__, "on_demand_above_base", on_demand_above_base)
        if on_demand_base is not None:
            pulumi.set(__self__, "on_demand_base", on_demand_base)

    @property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Sequence['outputs.GetInstanceGroupMixedInstancesPolicyInstanceRequirementResult']:
        return pulumi.get(self, "instance_requirements")

    @property
    @pulumi.getter
    def instances(self) -> Sequence[str]:
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter(name="onDemandAllocationStrategy")
    def on_demand_allocation_strategy(self) -> str:
        return pulumi.get(self, "on_demand_allocation_strategy")

    @property
    @pulumi.getter(name="spotAllocationStrategy")
    def spot_allocation_strategy(self) -> str:
        return pulumi.get(self, "spot_allocation_strategy")

    @property
    @pulumi.getter(name="spotInstancePools")
    def spot_instance_pools(self) -> int:
        return pulumi.get(self, "spot_instance_pools")

    @property
    @pulumi.getter(name="onDemandAboveBase")
    def on_demand_above_base(self) -> Optional['outputs.GetInstanceGroupMixedInstancesPolicyOnDemandAboveBaseResult']:
        return pulumi.get(self, "on_demand_above_base")

    @property
    @pulumi.getter(name="onDemandBase")
    def on_demand_base(self) -> Optional['outputs.GetInstanceGroupMixedInstancesPolicyOnDemandBaseResult']:
        return pulumi.get(self, "on_demand_base")


@pulumi.output_type
class GetInstanceGroupMixedInstancesPolicyInstanceRequirementResult(dict):
    def __init__(__self__, *,
                 cpus: Sequence['outputs.GetInstanceGroupMixedInstancesPolicyInstanceRequirementCpusResult'],
                 memories: Sequence['outputs.GetInstanceGroupMixedInstancesPolicyInstanceRequirementMemoryResult']):
        pulumi.set(__self__, "cpus", cpus)
        pulumi.set(__self__, "memories", memories)

    @property
    @pulumi.getter
    def cpus(self) -> Sequence['outputs.GetInstanceGroupMixedInstancesPolicyInstanceRequirementCpusResult']:
        return pulumi.get(self, "cpus")

    @property
    @pulumi.getter
    def memories(self) -> Sequence['outputs.GetInstanceGroupMixedInstancesPolicyInstanceRequirementMemoryResult']:
        return pulumi.get(self, "memories")


@pulumi.output_type
class GetInstanceGroupMixedInstancesPolicyInstanceRequirementCpusResult(dict):
    def __init__(__self__, *,
                 max: str,
                 min: str):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> str:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> str:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetInstanceGroupMixedInstancesPolicyInstanceRequirementMemoryResult(dict):
    def __init__(__self__, *,
                 max: str,
                 min: str):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> str:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> str:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetInstanceGroupMixedInstancesPolicyOnDemandAboveBaseResult(dict):
    def __init__(__self__, *,
                 value: int):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetInstanceGroupMixedInstancesPolicyOnDemandBaseResult(dict):
    def __init__(__self__, *,
                 value: int):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetInstanceGroupRollingUpdateResult(dict):
    def __init__(__self__, *,
                 drain_and_terminate: bool,
                 max_surge: str,
                 max_unavailable: str):
        pulumi.set(__self__, "drain_and_terminate", drain_and_terminate)
        pulumi.set(__self__, "max_surge", max_surge)
        pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="drainAndTerminate")
    def drain_and_terminate(self) -> bool:
        return pulumi.get(self, "drain_and_terminate")

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> str:
        return pulumi.get(self, "max_surge")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> str:
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class GetInstanceGroupVolumeResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: bool,
                 device: str,
                 encrypted: bool,
                 iops: int,
                 key: str,
                 size: int,
                 throughput: int,
                 type: str):
        pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "throughput", throughput)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> bool:
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def device(self) -> str:
        return pulumi.get(self, "device")

    @property
    @pulumi.getter
    def encrypted(self) -> bool:
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> int:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def throughput(self) -> int:
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInstanceGroupVolumeMountResult(dict):
    def __init__(__self__, *,
                 device: str,
                 filesystem: str,
                 format_options: Sequence[str],
                 mount_options: Sequence[str],
                 path: str):
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "filesystem", filesystem)
        pulumi.set(__self__, "format_options", format_options)
        pulumi.set(__self__, "mount_options", mount_options)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def device(self) -> str:
        return pulumi.get(self, "device")

    @property
    @pulumi.getter
    def filesystem(self) -> str:
        return pulumi.get(self, "filesystem")

    @property
    @pulumi.getter(name="formatOptions")
    def format_options(self) -> Sequence[str]:
        return pulumi.get(self, "format_options")

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Sequence[str]:
        return pulumi.get(self, "mount_options")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")


@pulumi.output_type
class GetInstanceGroupWarmPoolResult(dict):
    def __init__(__self__, *,
                 enable_lifecycle_hook: bool,
                 max_size: int,
                 min_size: int):
        """
        :param int max_size: - Int - MaxSize is the maximum size of the pool.
        :param int min_size: - Int - MinSize is the minimum size of the pool.
        """
        pulumi.set(__self__, "enable_lifecycle_hook", enable_lifecycle_hook)
        pulumi.set(__self__, "max_size", max_size)
        pulumi.set(__self__, "min_size", min_size)

    @property
    @pulumi.getter(name="enableLifecycleHook")
    def enable_lifecycle_hook(self) -> bool:
        return pulumi.get(self, "enable_lifecycle_hook")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> int:
        """
        - Int - MaxSize is the maximum size of the pool.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> int:
        """
        - Int - MinSize is the minimum size of the pool.
        """
        return pulumi.get(self, "min_size")


