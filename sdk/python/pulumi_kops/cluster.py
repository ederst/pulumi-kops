# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['ClusterArgs', 'Cluster']

@pulumi.input_type
class ClusterArgs:
    def __init__(__self__, *,
                 cloud_provider: pulumi.Input['ClusterCloudProviderArgs'],
                 etcd_clusters: pulumi.Input[Sequence[pulumi.Input['ClusterEtcdClusterArgs']]],
                 network_id: pulumi.Input[str],
                 networking: pulumi.Input['ClusterNetworkingArgs'],
                 subnets: pulumi.Input[Sequence[pulumi.Input['ClusterSubnetArgs']]],
                 topology: pulumi.Input['ClusterTopologyArgs'],
                 additional_network_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 additional_policies: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 additional_sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 addons: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddonArgs']]]] = None,
                 admin_ssh_key: Optional[pulumi.Input[str]] = None,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 api: Optional[pulumi.Input['ClusterApiArgs']] = None,
                 assets: Optional[pulumi.Input['ClusterAssetsArgs']] = None,
                 authentication: Optional[pulumi.Input['ClusterAuthenticationArgs']] = None,
                 authorization: Optional[pulumi.Input['ClusterAuthorizationArgs']] = None,
                 aws_load_balancer_controller: Optional[pulumi.Input['ClusterAwsLoadBalancerControllerArgs']] = None,
                 cert_manager: Optional[pulumi.Input['ClusterCertManagerArgs']] = None,
                 channel: Optional[pulumi.Input[str]] = None,
                 cloud_config: Optional[pulumi.Input['ClusterCloudConfigArgs']] = None,
                 cloud_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 cluster_autoscaler: Optional[pulumi.Input['ClusterClusterAutoscalerArgs']] = None,
                 cluster_dns_domain: Optional[pulumi.Input[str]] = None,
                 config_base: Optional[pulumi.Input[str]] = None,
                 config_store: Optional[pulumi.Input[str]] = None,
                 container_runtime: Optional[pulumi.Input[str]] = None,
                 containerd: Optional[pulumi.Input['ClusterContainerdArgs']] = None,
                 dns_zone: Optional[pulumi.Input[str]] = None,
                 docker: Optional[pulumi.Input['ClusterDockerArgs']] = None,
                 egress_proxy: Optional[pulumi.Input['ClusterEgressProxyArgs']] = None,
                 encryption_config: Optional[pulumi.Input[bool]] = None,
                 external_cloud_controller_manager: Optional[pulumi.Input['ClusterExternalCloudControllerManagerArgs']] = None,
                 external_dns: Optional[pulumi.Input['ClusterExternalDnsArgs']] = None,
                 external_policies: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterExternalPolicyArgs']]]] = None,
                 file_assets: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterFileAssetArgs']]]] = None,
                 hooks: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterHookArgs']]]] = None,
                 iam: Optional[pulumi.Input['ClusterIamArgs']] = None,
                 isolate_masters: Optional[pulumi.Input[bool]] = None,
                 karpenter: Optional[pulumi.Input['ClusterKarpenterArgs']] = None,
                 key_store: Optional[pulumi.Input[str]] = None,
                 kube_api_server: Optional[pulumi.Input['ClusterKubeApiServerArgs']] = None,
                 kube_controller_manager: Optional[pulumi.Input['ClusterKubeControllerManagerArgs']] = None,
                 kube_dns: Optional[pulumi.Input['ClusterKubeDnsArgs']] = None,
                 kube_proxy: Optional[pulumi.Input['ClusterKubeProxyArgs']] = None,
                 kube_scheduler: Optional[pulumi.Input['ClusterKubeSchedulerArgs']] = None,
                 kubelet: Optional[pulumi.Input['ClusterKubeletArgs']] = None,
                 kubernetes_api_accesses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kubernetes_version: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 master_internal_name: Optional[pulumi.Input[str]] = None,
                 master_kubelet: Optional[pulumi.Input['ClusterMasterKubeletArgs']] = None,
                 master_public_name: Optional[pulumi.Input[str]] = None,
                 metrics_server: Optional[pulumi.Input['ClusterMetricsServerArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 network_cidr: Optional[pulumi.Input[str]] = None,
                 node_authorization: Optional[pulumi.Input['ClusterNodeAuthorizationArgs']] = None,
                 node_port_accesses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 node_problem_detector: Optional[pulumi.Input['ClusterNodeProblemDetectorArgs']] = None,
                 node_termination_handler: Optional[pulumi.Input['ClusterNodeTerminationHandlerArgs']] = None,
                 non_masquerade_cidr: Optional[pulumi.Input[str]] = None,
                 ntp: Optional[pulumi.Input['ClusterNtpArgs']] = None,
                 pod_cidr: Optional[pulumi.Input[str]] = None,
                 pod_identity_webhook: Optional[pulumi.Input['ClusterPodIdentityWebhookArgs']] = None,
                 project: Optional[pulumi.Input[str]] = None,
                 rolling_update: Optional[pulumi.Input['ClusterRollingUpdateArgs']] = None,
                 secret_store: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input['ClusterSecretsArgs']] = None,
                 service_account_issuer_discovery: Optional[pulumi.Input['ClusterServiceAccountIssuerDiscoveryArgs']] = None,
                 service_cluster_ip_range: Optional[pulumi.Input[str]] = None,
                 snapshot_controller: Optional[pulumi.Input['ClusterSnapshotControllerArgs']] = None,
                 ssh_accesses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ssh_key_name: Optional[pulumi.Input[str]] = None,
                 sysctl_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tag_subnets: Optional[pulumi.Input['ClusterTagSubnetsArgs']] = None,
                 update_policy: Optional[pulumi.Input[str]] = None,
                 use_host_certificates: Optional[pulumi.Input[bool]] = None,
                 warm_pool: Optional[pulumi.Input['ClusterWarmPoolArgs']] = None):
        """
        The set of arguments for constructing a Cluster resource.
        :param pulumi.Input['ClusterCloudProviderArgs'] cloud_provider: - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterEtcdClusterArgs']]] etcd_clusters: - List(etcd_cluster_spec) - EtcdClusters stores the configuration for each cluster.
        :param pulumi.Input[str] network_id: - String - NetworkID is an identifier of a network, if we want to reuse/share an existing network (e.g. an AWS VPC).
        :param pulumi.Input['ClusterNetworkingArgs'] networking: - networking_spec - Networking configuration.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterSubnetArgs']]] subnets: - List(cluster_subnet_spec) - Configuration of subnets we are targeting.
        :param pulumi.Input['ClusterTopologyArgs'] topology: - topology_spec - Topology defines the type of network topology to use on the cluster - default public<br />This is heavily weighted towards AWS for the time being, but should also be agnostic enough<br />to port out to GCE later if needed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_network_cidrs: - List(String) - AdditionalNetworkCIDRs is a list of additional CIDR used for the AWS VPC<br />or otherwise allocated to k8s. This is a real CIDR, not the internal k8s network<br />On AWS, it maps to any additional CIDRs added to a VPC.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_policies: - Map(String) - Additional policies to add for roles.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_sans: - List(String) - AdditionalSANs adds additional Subject Alternate Names to apiserver cert that kops generates.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddonArgs']]] addons: - List(addon_spec) - Additional addons that should be installed on the cluster.
        :param pulumi.Input[str] admin_ssh_key: - (Sensitive) - String - AdminSshKey defines the cluster admin ssh key.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: - Map(String) - Annotations is an unstructured key value map stored with a resource that may be<br />set by external tools to store and retrieve arbitrary metadata. They are not<br />queryable and should be preserved when modifying objects.
        :param pulumi.Input['ClusterApiArgs'] api: - access_spec - API field controls how the API is exposed outside the cluster.
        :param pulumi.Input['ClusterAssetsArgs'] assets: - assets - Assets is alternative locations for files and containers; the API under construction, will remove this comment once this API is fully functional.
        :param pulumi.Input['ClusterAuthenticationArgs'] authentication: - authentication_spec - Authentication field controls how the cluster is configured for authentication.
        :param pulumi.Input['ClusterAuthorizationArgs'] authorization: - authorization_spec - Authorization field controls how the cluster is configured for authorization.
        :param pulumi.Input['ClusterAwsLoadBalancerControllerArgs'] aws_load_balancer_controller: - aws_load_balancer_controller_config - AWSLoadbalancerControllerConfig determines the AWS LB controller configuration.
        :param pulumi.Input['ClusterCertManagerArgs'] cert_manager: - cert_manager_config - CertManager determines the metrics server configuration.
        :param pulumi.Input[str] channel: - String - The Channel we are following.
        :param pulumi.Input['ClusterCloudConfigArgs'] cloud_config: - cloud_configuration
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] cloud_labels: - Map(String) - CloudLabels defines additional tags or labels on cloud provider resources.
        :param pulumi.Input['ClusterClusterAutoscalerArgs'] cluster_autoscaler: - cluster_autoscaler_config - ClusterAutoscaler defines the cluster autoscaler configuration.
        :param pulumi.Input[str] cluster_dns_domain: - String - ClusterDNSDomain is the suffix we use for internal DNS names (normally cluster.local).
        :param pulumi.Input[str] config_base: - (Computed) - String - ConfigBase is the path where we store configuration for the cluster<br />This might be different than the location where the cluster spec itself is stored,<br />both because this must be accessible to the cluster,<br />and because it might be on a different cloud or storage system (etcd vs S3).
        :param pulumi.Input[str] config_store: - String - ConfigStore is the VFS path to where the configuration (Cluster, InstanceGroups etc) is stored.
        :param pulumi.Input[str] container_runtime: - String - Container runtime to use for Kubernetes.
        :param pulumi.Input['ClusterContainerdArgs'] containerd: - containerd_config - Component configurations.
        :param pulumi.Input[str] dns_zone: - String - DNSZone is the DNS zone we should use when configuring DNS<br />This is because some clouds let us define a managed zone foo.bar, and then have<br />kubernetes.dev.foo.bar, without needing to define dev.foo.bar as a hosted zone.<br />DNSZone will probably be a suffix of the MasterPublicName and MasterInternalName<br />Note that DNSZone can either by the host name of the zone (containing dots),<br />or can be an identifier for the zone.
        :param pulumi.Input['ClusterDockerArgs'] docker: - docker_config
        :param pulumi.Input['ClusterEgressProxyArgs'] egress_proxy: - egress_proxy_spec - HTTPProxy defines connection information to support use of a private cluster behind an forward HTTP Proxy.
        :param pulumi.Input[bool] encryption_config: - Bool - EncryptionConfig controls if encryption is enabled.
        :param pulumi.Input['ClusterExternalCloudControllerManagerArgs'] external_cloud_controller_manager: - cloud_controller_manager_config
        :param pulumi.Input['ClusterExternalDnsArgs'] external_dns: - external_dns_config
        :param pulumi.Input[Sequence[pulumi.Input['ClusterExternalPolicyArgs']]] external_policies: - Map(List(String)) - ExternalPolicies allows the insertion of pre-existing managed policies on IG Roles.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterFileAssetArgs']]] file_assets: - List(file_asset_spec) - A collection of files assets for deployed cluster wide.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterHookArgs']]] hooks: - List(hook_spec) - Hooks for custom actions e.g. on first installation.
        :param pulumi.Input['ClusterIamArgs'] iam: - (Computed) - iam_spec - IAM field adds control over the IAM security policies applied to resources.
        :param pulumi.Input[bool] isolate_masters: - Bool - IsolateMasters determines whether we should lock down masters so that they are not on the pod network.<br />true is the kube-up behaviour, but it is very surprising: it means that daemonsets only work on the master<br />if they have hostNetwork=true.<br />false is now the default, and it will:<br /> * give the master a normal PodCIDR<br /> * run kube-proxy on the master<br /> * enable debugging handlers on the master, so kubectl logs works.
        :param pulumi.Input['ClusterKarpenterArgs'] karpenter: - karpenter_config - Karpenter defines the Karpenter configuration.
        :param pulumi.Input[str] key_store: - String - KeyStore is the VFS path to where SSL keys and certificates are stored.
        :param pulumi.Input['ClusterKubeApiServerArgs'] kube_api_server: - kube_api_server_config
        :param pulumi.Input['ClusterKubeControllerManagerArgs'] kube_controller_manager: - kube_controller_manager_config
        :param pulumi.Input['ClusterKubeDnsArgs'] kube_dns: - kube_dns_config
        :param pulumi.Input['ClusterKubeProxyArgs'] kube_proxy: - kube_proxy_config
        :param pulumi.Input['ClusterKubeSchedulerArgs'] kube_scheduler: - kube_scheduler_config
        :param pulumi.Input['ClusterKubeletArgs'] kubelet: - kubelet_config_spec - Kubelet is the kubelet configuration for nodes not belonging to the control plane.<br />It can be overridden by the kubelet configuration specified in the instance group.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] kubernetes_api_accesses: - List(String) - KubernetesAPIAccess is a list of the CIDRs that can access the Kubernetes API endpoint (master HTTPS).
        :param pulumi.Input[str] kubernetes_version: - String - The version of kubernetes to install (optional, and can be a "spec" like stable).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: - Map(String) - Map of string keys and values that can be used to organize and categorize<br />(scope and select) objects. May match selectors of replication controllers<br />and services.
        :param pulumi.Input[str] master_internal_name: - (Computed) - String - MasterInternalName is the internal DNS name for the master nodes.
        :param pulumi.Input['ClusterMasterKubeletArgs'] master_kubelet: - kubelet_config_spec - MasterKubelet is the kubelet configuration for nodes belonging to the control plane<br />It can be overridden by the kubelet configuration specified in the instance group.
        :param pulumi.Input[str] master_public_name: - (Computed) - String - MasterPublicName is the external DNS name for the master nodes.
        :param pulumi.Input['ClusterMetricsServerArgs'] metrics_server: - metrics_server_config - MetricsServer determines the metrics server configuration.
        :param pulumi.Input[str] name: - (Force new) - String - Name defines the cluster name.
        :param pulumi.Input[str] network_cidr: - (Computed) - String - NetworkCIDR is the CIDR used for the AWS VPC / DO/ GCE Network, or otherwise allocated to k8s<br />This is a real CIDR, not the internal k8s network<br />On AWS, it maps to the VPC CIDR.  It is not required on GCE.<br />On DO, it maps to the VPC CIDR.
        :param pulumi.Input['ClusterNodeAuthorizationArgs'] node_authorization: - node_authorization_spec - NodeAuthorization defined the custom node authorization configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] node_port_accesses: - List(String) - NodePortAccess is a list of the CIDRs that can access the node ports range (30000-32767).
        :param pulumi.Input['ClusterNodeProblemDetectorArgs'] node_problem_detector: - node_problem_detector_config - NodeProblemDetector determines the node problem detector configuration.
        :param pulumi.Input['ClusterNodeTerminationHandlerArgs'] node_termination_handler: - node_termination_handler_config - NodeTerminationHandler determines the node termination handler configuration.
        :param pulumi.Input[str] non_masquerade_cidr: - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
        :param pulumi.Input['ClusterNtpArgs'] ntp: - ntp_config
        :param pulumi.Input[str] pod_cidr: - String - PodCIDR is the CIDR from which we allocate IPs for pods.
        :param pulumi.Input['ClusterPodIdentityWebhookArgs'] pod_identity_webhook: - pod_identity_webhook_config - PodIdentityWebhook determines the EKS Pod Identity Webhook configuration.
        :param pulumi.Input[str] project: - String - Project is the cloud project we should use, required on GCE.
        :param pulumi.Input['ClusterRollingUpdateArgs'] rolling_update: - rolling_update - RollingUpdate defines the default rolling-update settings for instance groups.
        :param pulumi.Input[str] secret_store: - String - SecretStore is the VFS path to where secrets are stored.
        :param pulumi.Input['ClusterSecretsArgs'] secrets: - cluster_secrets - Secrets defines the cluster secret.
        :param pulumi.Input['ClusterServiceAccountIssuerDiscoveryArgs'] service_account_issuer_discovery: - service_account_issuer_discovery_config - ServiceAccountIssuerDiscovery configures the OIDC Issuer for ServiceAccounts.
        :param pulumi.Input[str] service_cluster_ip_range: - String - ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services.
        :param pulumi.Input['ClusterSnapshotControllerArgs'] snapshot_controller: - snapshot_controller_config - SnapshotController defines the CSI Snapshot Controller configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ssh_accesses: - List(String) - SSHAccess is a list of the CIDRs that can access SSH.
        :param pulumi.Input[str] ssh_key_name: - String - SSHKeyName specifies a preexisting SSH key to use.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sysctl_parameters: - List(String) - SysctlParameters will configure kernel parameters using sysctl(8). When<br />specified, each parameter must follow the form variable=value, the way<br />it would appear in sysctl.conf.
        :param pulumi.Input['ClusterTagSubnetsArgs'] tag_subnets: - Bool(Nullable) - TagSubnets controls if tags are added to subnets to enable use by load balancers (AWS only). Default: true.
        :param pulumi.Input[str] update_policy: - String - UpdatePolicy determines the policy for applying upgrades automatically.<br />Valid values:<br />  'automatic' (default): apply updates automatically (apply OS security upgrades, avoiding rebooting when possible)<br />  'external': do not apply updates automatically; they are applied manually or by an external system.
        :param pulumi.Input[bool] use_host_certificates: - Bool - UseHostCertificates will mount /etc/ssl/certs to inside needed containers.<br />This is needed if some APIs do have self-signed certs.
        :param pulumi.Input['ClusterWarmPoolArgs'] warm_pool: - warm_pool_spec - WarmPool defines the default warm pool settings for instance groups (AWS only).
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "etcd_clusters", etcd_clusters)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "networking", networking)
        pulumi.set(__self__, "subnets", subnets)
        pulumi.set(__self__, "topology", topology)
        if additional_network_cidrs is not None:
            pulumi.set(__self__, "additional_network_cidrs", additional_network_cidrs)
        if additional_policies is not None:
            pulumi.set(__self__, "additional_policies", additional_policies)
        if additional_sans is not None:
            pulumi.set(__self__, "additional_sans", additional_sans)
        if addons is not None:
            pulumi.set(__self__, "addons", addons)
        if admin_ssh_key is not None:
            pulumi.set(__self__, "admin_ssh_key", admin_ssh_key)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if api is not None:
            pulumi.set(__self__, "api", api)
        if assets is not None:
            pulumi.set(__self__, "assets", assets)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if aws_load_balancer_controller is not None:
            pulumi.set(__self__, "aws_load_balancer_controller", aws_load_balancer_controller)
        if cert_manager is not None:
            pulumi.set(__self__, "cert_manager", cert_manager)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if cloud_config is not None:
            pulumi.set(__self__, "cloud_config", cloud_config)
        if cloud_labels is not None:
            pulumi.set(__self__, "cloud_labels", cloud_labels)
        if cluster_autoscaler is not None:
            pulumi.set(__self__, "cluster_autoscaler", cluster_autoscaler)
        if cluster_dns_domain is not None:
            pulumi.set(__self__, "cluster_dns_domain", cluster_dns_domain)
        if config_base is not None:
            pulumi.set(__self__, "config_base", config_base)
        if config_store is not None:
            pulumi.set(__self__, "config_store", config_store)
        if container_runtime is not None:
            pulumi.set(__self__, "container_runtime", container_runtime)
        if containerd is not None:
            pulumi.set(__self__, "containerd", containerd)
        if dns_zone is not None:
            pulumi.set(__self__, "dns_zone", dns_zone)
        if docker is not None:
            pulumi.set(__self__, "docker", docker)
        if egress_proxy is not None:
            pulumi.set(__self__, "egress_proxy", egress_proxy)
        if encryption_config is not None:
            pulumi.set(__self__, "encryption_config", encryption_config)
        if external_cloud_controller_manager is not None:
            pulumi.set(__self__, "external_cloud_controller_manager", external_cloud_controller_manager)
        if external_dns is not None:
            pulumi.set(__self__, "external_dns", external_dns)
        if external_policies is not None:
            pulumi.set(__self__, "external_policies", external_policies)
        if file_assets is not None:
            pulumi.set(__self__, "file_assets", file_assets)
        if hooks is not None:
            pulumi.set(__self__, "hooks", hooks)
        if iam is not None:
            pulumi.set(__self__, "iam", iam)
        if isolate_masters is not None:
            pulumi.set(__self__, "isolate_masters", isolate_masters)
        if karpenter is not None:
            pulumi.set(__self__, "karpenter", karpenter)
        if key_store is not None:
            pulumi.set(__self__, "key_store", key_store)
        if kube_api_server is not None:
            pulumi.set(__self__, "kube_api_server", kube_api_server)
        if kube_controller_manager is not None:
            pulumi.set(__self__, "kube_controller_manager", kube_controller_manager)
        if kube_dns is not None:
            pulumi.set(__self__, "kube_dns", kube_dns)
        if kube_proxy is not None:
            pulumi.set(__self__, "kube_proxy", kube_proxy)
        if kube_scheduler is not None:
            pulumi.set(__self__, "kube_scheduler", kube_scheduler)
        if kubelet is not None:
            pulumi.set(__self__, "kubelet", kubelet)
        if kubernetes_api_accesses is not None:
            pulumi.set(__self__, "kubernetes_api_accesses", kubernetes_api_accesses)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if master_internal_name is not None:
            pulumi.set(__self__, "master_internal_name", master_internal_name)
        if master_kubelet is not None:
            pulumi.set(__self__, "master_kubelet", master_kubelet)
        if master_public_name is not None:
            pulumi.set(__self__, "master_public_name", master_public_name)
        if metrics_server is not None:
            pulumi.set(__self__, "metrics_server", metrics_server)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_cidr is not None:
            pulumi.set(__self__, "network_cidr", network_cidr)
        if node_authorization is not None:
            pulumi.set(__self__, "node_authorization", node_authorization)
        if node_port_accesses is not None:
            pulumi.set(__self__, "node_port_accesses", node_port_accesses)
        if node_problem_detector is not None:
            pulumi.set(__self__, "node_problem_detector", node_problem_detector)
        if node_termination_handler is not None:
            pulumi.set(__self__, "node_termination_handler", node_termination_handler)
        if non_masquerade_cidr is not None:
            pulumi.set(__self__, "non_masquerade_cidr", non_masquerade_cidr)
        if ntp is not None:
            pulumi.set(__self__, "ntp", ntp)
        if pod_cidr is not None:
            pulumi.set(__self__, "pod_cidr", pod_cidr)
        if pod_identity_webhook is not None:
            pulumi.set(__self__, "pod_identity_webhook", pod_identity_webhook)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if secret_store is not None:
            pulumi.set(__self__, "secret_store", secret_store)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if service_account_issuer_discovery is not None:
            pulumi.set(__self__, "service_account_issuer_discovery", service_account_issuer_discovery)
        if service_cluster_ip_range is not None:
            pulumi.set(__self__, "service_cluster_ip_range", service_cluster_ip_range)
        if snapshot_controller is not None:
            pulumi.set(__self__, "snapshot_controller", snapshot_controller)
        if ssh_accesses is not None:
            pulumi.set(__self__, "ssh_accesses", ssh_accesses)
        if ssh_key_name is not None:
            pulumi.set(__self__, "ssh_key_name", ssh_key_name)
        if sysctl_parameters is not None:
            pulumi.set(__self__, "sysctl_parameters", sysctl_parameters)
        if tag_subnets is not None:
            pulumi.set(__self__, "tag_subnets", tag_subnets)
        if update_policy is not None:
            pulumi.set(__self__, "update_policy", update_policy)
        if use_host_certificates is not None:
            pulumi.set(__self__, "use_host_certificates", use_host_certificates)
        if warm_pool is not None:
            pulumi.set(__self__, "warm_pool", warm_pool)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> pulumi.Input['ClusterCloudProviderArgs']:
        """
        - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: pulumi.Input['ClusterCloudProviderArgs']):
        pulumi.set(self, "cloud_provider", value)

    @property
    @pulumi.getter(name="etcdClusters")
    def etcd_clusters(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterEtcdClusterArgs']]]:
        """
        - List(etcd_cluster_spec) - EtcdClusters stores the configuration for each cluster.
        """
        return pulumi.get(self, "etcd_clusters")

    @etcd_clusters.setter
    def etcd_clusters(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterEtcdClusterArgs']]]):
        pulumi.set(self, "etcd_clusters", value)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> pulumi.Input[str]:
        """
        - String - NetworkID is an identifier of a network, if we want to reuse/share an existing network (e.g. an AWS VPC).
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_id", value)

    @property
    @pulumi.getter
    def networking(self) -> pulumi.Input['ClusterNetworkingArgs']:
        """
        - networking_spec - Networking configuration.
        """
        return pulumi.get(self, "networking")

    @networking.setter
    def networking(self, value: pulumi.Input['ClusterNetworkingArgs']):
        pulumi.set(self, "networking", value)

    @property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterSubnetArgs']]]:
        """
        - List(cluster_subnet_spec) - Configuration of subnets we are targeting.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterSubnetArgs']]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter
    def topology(self) -> pulumi.Input['ClusterTopologyArgs']:
        """
        - topology_spec - Topology defines the type of network topology to use on the cluster - default public<br />This is heavily weighted towards AWS for the time being, but should also be agnostic enough<br />to port out to GCE later if needed.
        """
        return pulumi.get(self, "topology")

    @topology.setter
    def topology(self, value: pulumi.Input['ClusterTopologyArgs']):
        pulumi.set(self, "topology", value)

    @property
    @pulumi.getter(name="additionalNetworkCidrs")
    def additional_network_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - List(String) - AdditionalNetworkCIDRs is a list of additional CIDR used for the AWS VPC<br />or otherwise allocated to k8s. This is a real CIDR, not the internal k8s network<br />On AWS, it maps to any additional CIDRs added to a VPC.
        """
        return pulumi.get(self, "additional_network_cidrs")

    @additional_network_cidrs.setter
    def additional_network_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "additional_network_cidrs", value)

    @property
    @pulumi.getter(name="additionalPolicies")
    def additional_policies(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        - Map(String) - Additional policies to add for roles.
        """
        return pulumi.get(self, "additional_policies")

    @additional_policies.setter
    def additional_policies(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "additional_policies", value)

    @property
    @pulumi.getter(name="additionalSans")
    def additional_sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - List(String) - AdditionalSANs adds additional Subject Alternate Names to apiserver cert that kops generates.
        """
        return pulumi.get(self, "additional_sans")

    @additional_sans.setter
    def additional_sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "additional_sans", value)

    @property
    @pulumi.getter
    def addons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddonArgs']]]]:
        """
        - List(addon_spec) - Additional addons that should be installed on the cluster.
        """
        return pulumi.get(self, "addons")

    @addons.setter
    def addons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddonArgs']]]]):
        pulumi.set(self, "addons", value)

    @property
    @pulumi.getter(name="adminSshKey")
    def admin_ssh_key(self) -> Optional[pulumi.Input[str]]:
        """
        - (Sensitive) - String - AdminSshKey defines the cluster admin ssh key.
        """
        return pulumi.get(self, "admin_ssh_key")

    @admin_ssh_key.setter
    def admin_ssh_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_ssh_key", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        - Map(String) - Annotations is an unstructured key value map stored with a resource that may be<br />set by external tools to store and retrieve arbitrary metadata. They are not<br />queryable and should be preserved when modifying objects.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def api(self) -> Optional[pulumi.Input['ClusterApiArgs']]:
        """
        - access_spec - API field controls how the API is exposed outside the cluster.
        """
        return pulumi.get(self, "api")

    @api.setter
    def api(self, value: Optional[pulumi.Input['ClusterApiArgs']]):
        pulumi.set(self, "api", value)

    @property
    @pulumi.getter
    def assets(self) -> Optional[pulumi.Input['ClusterAssetsArgs']]:
        """
        - assets - Assets is alternative locations for files and containers; the API under construction, will remove this comment once this API is fully functional.
        """
        return pulumi.get(self, "assets")

    @assets.setter
    def assets(self, value: Optional[pulumi.Input['ClusterAssetsArgs']]):
        pulumi.set(self, "assets", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ClusterAuthenticationArgs']]:
        """
        - authentication_spec - Authentication field controls how the cluster is configured for authentication.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ClusterAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['ClusterAuthorizationArgs']]:
        """
        - authorization_spec - Authorization field controls how the cluster is configured for authorization.
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['ClusterAuthorizationArgs']]):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter(name="awsLoadBalancerController")
    def aws_load_balancer_controller(self) -> Optional[pulumi.Input['ClusterAwsLoadBalancerControllerArgs']]:
        """
        - aws_load_balancer_controller_config - AWSLoadbalancerControllerConfig determines the AWS LB controller configuration.
        """
        return pulumi.get(self, "aws_load_balancer_controller")

    @aws_load_balancer_controller.setter
    def aws_load_balancer_controller(self, value: Optional[pulumi.Input['ClusterAwsLoadBalancerControllerArgs']]):
        pulumi.set(self, "aws_load_balancer_controller", value)

    @property
    @pulumi.getter(name="certManager")
    def cert_manager(self) -> Optional[pulumi.Input['ClusterCertManagerArgs']]:
        """
        - cert_manager_config - CertManager determines the metrics server configuration.
        """
        return pulumi.get(self, "cert_manager")

    @cert_manager.setter
    def cert_manager(self, value: Optional[pulumi.Input['ClusterCertManagerArgs']]):
        pulumi.set(self, "cert_manager", value)

    @property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[str]]:
        """
        - String - The Channel we are following.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter(name="cloudConfig")
    def cloud_config(self) -> Optional[pulumi.Input['ClusterCloudConfigArgs']]:
        """
        - cloud_configuration
        """
        return pulumi.get(self, "cloud_config")

    @cloud_config.setter
    def cloud_config(self, value: Optional[pulumi.Input['ClusterCloudConfigArgs']]):
        pulumi.set(self, "cloud_config", value)

    @property
    @pulumi.getter(name="cloudLabels")
    def cloud_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        - Map(String) - CloudLabels defines additional tags or labels on cloud provider resources.
        """
        return pulumi.get(self, "cloud_labels")

    @cloud_labels.setter
    def cloud_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "cloud_labels", value)

    @property
    @pulumi.getter(name="clusterAutoscaler")
    def cluster_autoscaler(self) -> Optional[pulumi.Input['ClusterClusterAutoscalerArgs']]:
        """
        - cluster_autoscaler_config - ClusterAutoscaler defines the cluster autoscaler configuration.
        """
        return pulumi.get(self, "cluster_autoscaler")

    @cluster_autoscaler.setter
    def cluster_autoscaler(self, value: Optional[pulumi.Input['ClusterClusterAutoscalerArgs']]):
        pulumi.set(self, "cluster_autoscaler", value)

    @property
    @pulumi.getter(name="clusterDnsDomain")
    def cluster_dns_domain(self) -> Optional[pulumi.Input[str]]:
        """
        - String - ClusterDNSDomain is the suffix we use for internal DNS names (normally cluster.local).
        """
        return pulumi.get(self, "cluster_dns_domain")

    @cluster_dns_domain.setter
    def cluster_dns_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_dns_domain", value)

    @property
    @pulumi.getter(name="configBase")
    def config_base(self) -> Optional[pulumi.Input[str]]:
        """
        - (Computed) - String - ConfigBase is the path where we store configuration for the cluster<br />This might be different than the location where the cluster spec itself is stored,<br />both because this must be accessible to the cluster,<br />and because it might be on a different cloud or storage system (etcd vs S3).
        """
        return pulumi.get(self, "config_base")

    @config_base.setter
    def config_base(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_base", value)

    @property
    @pulumi.getter(name="configStore")
    def config_store(self) -> Optional[pulumi.Input[str]]:
        """
        - String - ConfigStore is the VFS path to where the configuration (Cluster, InstanceGroups etc) is stored.
        """
        return pulumi.get(self, "config_store")

    @config_store.setter
    def config_store(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_store", value)

    @property
    @pulumi.getter(name="containerRuntime")
    def container_runtime(self) -> Optional[pulumi.Input[str]]:
        """
        - String - Container runtime to use for Kubernetes.
        """
        return pulumi.get(self, "container_runtime")

    @container_runtime.setter
    def container_runtime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_runtime", value)

    @property
    @pulumi.getter
    def containerd(self) -> Optional[pulumi.Input['ClusterContainerdArgs']]:
        """
        - containerd_config - Component configurations.
        """
        return pulumi.get(self, "containerd")

    @containerd.setter
    def containerd(self, value: Optional[pulumi.Input['ClusterContainerdArgs']]):
        pulumi.set(self, "containerd", value)

    @property
    @pulumi.getter(name="dnsZone")
    def dns_zone(self) -> Optional[pulumi.Input[str]]:
        """
        - String - DNSZone is the DNS zone we should use when configuring DNS<br />This is because some clouds let us define a managed zone foo.bar, and then have<br />kubernetes.dev.foo.bar, without needing to define dev.foo.bar as a hosted zone.<br />DNSZone will probably be a suffix of the MasterPublicName and MasterInternalName<br />Note that DNSZone can either by the host name of the zone (containing dots),<br />or can be an identifier for the zone.
        """
        return pulumi.get(self, "dns_zone")

    @dns_zone.setter
    def dns_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_zone", value)

    @property
    @pulumi.getter
    def docker(self) -> Optional[pulumi.Input['ClusterDockerArgs']]:
        """
        - docker_config
        """
        return pulumi.get(self, "docker")

    @docker.setter
    def docker(self, value: Optional[pulumi.Input['ClusterDockerArgs']]):
        pulumi.set(self, "docker", value)

    @property
    @pulumi.getter(name="egressProxy")
    def egress_proxy(self) -> Optional[pulumi.Input['ClusterEgressProxyArgs']]:
        """
        - egress_proxy_spec - HTTPProxy defines connection information to support use of a private cluster behind an forward HTTP Proxy.
        """
        return pulumi.get(self, "egress_proxy")

    @egress_proxy.setter
    def egress_proxy(self, value: Optional[pulumi.Input['ClusterEgressProxyArgs']]):
        pulumi.set(self, "egress_proxy", value)

    @property
    @pulumi.getter(name="encryptionConfig")
    def encryption_config(self) -> Optional[pulumi.Input[bool]]:
        """
        - Bool - EncryptionConfig controls if encryption is enabled.
        """
        return pulumi.get(self, "encryption_config")

    @encryption_config.setter
    def encryption_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encryption_config", value)

    @property
    @pulumi.getter(name="externalCloudControllerManager")
    def external_cloud_controller_manager(self) -> Optional[pulumi.Input['ClusterExternalCloudControllerManagerArgs']]:
        """
        - cloud_controller_manager_config
        """
        return pulumi.get(self, "external_cloud_controller_manager")

    @external_cloud_controller_manager.setter
    def external_cloud_controller_manager(self, value: Optional[pulumi.Input['ClusterExternalCloudControllerManagerArgs']]):
        pulumi.set(self, "external_cloud_controller_manager", value)

    @property
    @pulumi.getter(name="externalDns")
    def external_dns(self) -> Optional[pulumi.Input['ClusterExternalDnsArgs']]:
        """
        - external_dns_config
        """
        return pulumi.get(self, "external_dns")

    @external_dns.setter
    def external_dns(self, value: Optional[pulumi.Input['ClusterExternalDnsArgs']]):
        pulumi.set(self, "external_dns", value)

    @property
    @pulumi.getter(name="externalPolicies")
    def external_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterExternalPolicyArgs']]]]:
        """
        - Map(List(String)) - ExternalPolicies allows the insertion of pre-existing managed policies on IG Roles.
        """
        return pulumi.get(self, "external_policies")

    @external_policies.setter
    def external_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterExternalPolicyArgs']]]]):
        pulumi.set(self, "external_policies", value)

    @property
    @pulumi.getter(name="fileAssets")
    def file_assets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterFileAssetArgs']]]]:
        """
        - List(file_asset_spec) - A collection of files assets for deployed cluster wide.
        """
        return pulumi.get(self, "file_assets")

    @file_assets.setter
    def file_assets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterFileAssetArgs']]]]):
        pulumi.set(self, "file_assets", value)

    @property
    @pulumi.getter
    def hooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterHookArgs']]]]:
        """
        - List(hook_spec) - Hooks for custom actions e.g. on first installation.
        """
        return pulumi.get(self, "hooks")

    @hooks.setter
    def hooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterHookArgs']]]]):
        pulumi.set(self, "hooks", value)

    @property
    @pulumi.getter
    def iam(self) -> Optional[pulumi.Input['ClusterIamArgs']]:
        """
        - (Computed) - iam_spec - IAM field adds control over the IAM security policies applied to resources.
        """
        return pulumi.get(self, "iam")

    @iam.setter
    def iam(self, value: Optional[pulumi.Input['ClusterIamArgs']]):
        pulumi.set(self, "iam", value)

    @property
    @pulumi.getter(name="isolateMasters")
    def isolate_masters(self) -> Optional[pulumi.Input[bool]]:
        """
        - Bool - IsolateMasters determines whether we should lock down masters so that they are not on the pod network.<br />true is the kube-up behaviour, but it is very surprising: it means that daemonsets only work on the master<br />if they have hostNetwork=true.<br />false is now the default, and it will:<br /> * give the master a normal PodCIDR<br /> * run kube-proxy on the master<br /> * enable debugging handlers on the master, so kubectl logs works.
        """
        return pulumi.get(self, "isolate_masters")

    @isolate_masters.setter
    def isolate_masters(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "isolate_masters", value)

    @property
    @pulumi.getter
    def karpenter(self) -> Optional[pulumi.Input['ClusterKarpenterArgs']]:
        """
        - karpenter_config - Karpenter defines the Karpenter configuration.
        """
        return pulumi.get(self, "karpenter")

    @karpenter.setter
    def karpenter(self, value: Optional[pulumi.Input['ClusterKarpenterArgs']]):
        pulumi.set(self, "karpenter", value)

    @property
    @pulumi.getter(name="keyStore")
    def key_store(self) -> Optional[pulumi.Input[str]]:
        """
        - String - KeyStore is the VFS path to where SSL keys and certificates are stored.
        """
        return pulumi.get(self, "key_store")

    @key_store.setter
    def key_store(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_store", value)

    @property
    @pulumi.getter(name="kubeApiServer")
    def kube_api_server(self) -> Optional[pulumi.Input['ClusterKubeApiServerArgs']]:
        """
        - kube_api_server_config
        """
        return pulumi.get(self, "kube_api_server")

    @kube_api_server.setter
    def kube_api_server(self, value: Optional[pulumi.Input['ClusterKubeApiServerArgs']]):
        pulumi.set(self, "kube_api_server", value)

    @property
    @pulumi.getter(name="kubeControllerManager")
    def kube_controller_manager(self) -> Optional[pulumi.Input['ClusterKubeControllerManagerArgs']]:
        """
        - kube_controller_manager_config
        """
        return pulumi.get(self, "kube_controller_manager")

    @kube_controller_manager.setter
    def kube_controller_manager(self, value: Optional[pulumi.Input['ClusterKubeControllerManagerArgs']]):
        pulumi.set(self, "kube_controller_manager", value)

    @property
    @pulumi.getter(name="kubeDns")
    def kube_dns(self) -> Optional[pulumi.Input['ClusterKubeDnsArgs']]:
        """
        - kube_dns_config
        """
        return pulumi.get(self, "kube_dns")

    @kube_dns.setter
    def kube_dns(self, value: Optional[pulumi.Input['ClusterKubeDnsArgs']]):
        pulumi.set(self, "kube_dns", value)

    @property
    @pulumi.getter(name="kubeProxy")
    def kube_proxy(self) -> Optional[pulumi.Input['ClusterKubeProxyArgs']]:
        """
        - kube_proxy_config
        """
        return pulumi.get(self, "kube_proxy")

    @kube_proxy.setter
    def kube_proxy(self, value: Optional[pulumi.Input['ClusterKubeProxyArgs']]):
        pulumi.set(self, "kube_proxy", value)

    @property
    @pulumi.getter(name="kubeScheduler")
    def kube_scheduler(self) -> Optional[pulumi.Input['ClusterKubeSchedulerArgs']]:
        """
        - kube_scheduler_config
        """
        return pulumi.get(self, "kube_scheduler")

    @kube_scheduler.setter
    def kube_scheduler(self, value: Optional[pulumi.Input['ClusterKubeSchedulerArgs']]):
        pulumi.set(self, "kube_scheduler", value)

    @property
    @pulumi.getter
    def kubelet(self) -> Optional[pulumi.Input['ClusterKubeletArgs']]:
        """
        - kubelet_config_spec - Kubelet is the kubelet configuration for nodes not belonging to the control plane.<br />It can be overridden by the kubelet configuration specified in the instance group.
        """
        return pulumi.get(self, "kubelet")

    @kubelet.setter
    def kubelet(self, value: Optional[pulumi.Input['ClusterKubeletArgs']]):
        pulumi.set(self, "kubelet", value)

    @property
    @pulumi.getter(name="kubernetesApiAccesses")
    def kubernetes_api_accesses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - List(String) - KubernetesAPIAccess is a list of the CIDRs that can access the Kubernetes API endpoint (master HTTPS).
        """
        return pulumi.get(self, "kubernetes_api_accesses")

    @kubernetes_api_accesses.setter
    def kubernetes_api_accesses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "kubernetes_api_accesses", value)

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[pulumi.Input[str]]:
        """
        - String - The version of kubernetes to install (optional, and can be a "spec" like stable).
        """
        return pulumi.get(self, "kubernetes_version")

    @kubernetes_version.setter
    def kubernetes_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_version", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        - Map(String) - Map of string keys and values that can be used to organize and categorize<br />(scope and select) objects. May match selectors of replication controllers<br />and services.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="masterInternalName")
    def master_internal_name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Computed) - String - MasterInternalName is the internal DNS name for the master nodes.
        """
        return pulumi.get(self, "master_internal_name")

    @master_internal_name.setter
    def master_internal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "master_internal_name", value)

    @property
    @pulumi.getter(name="masterKubelet")
    def master_kubelet(self) -> Optional[pulumi.Input['ClusterMasterKubeletArgs']]:
        """
        - kubelet_config_spec - MasterKubelet is the kubelet configuration for nodes belonging to the control plane<br />It can be overridden by the kubelet configuration specified in the instance group.
        """
        return pulumi.get(self, "master_kubelet")

    @master_kubelet.setter
    def master_kubelet(self, value: Optional[pulumi.Input['ClusterMasterKubeletArgs']]):
        pulumi.set(self, "master_kubelet", value)

    @property
    @pulumi.getter(name="masterPublicName")
    def master_public_name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Computed) - String - MasterPublicName is the external DNS name for the master nodes.
        """
        return pulumi.get(self, "master_public_name")

    @master_public_name.setter
    def master_public_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "master_public_name", value)

    @property
    @pulumi.getter(name="metricsServer")
    def metrics_server(self) -> Optional[pulumi.Input['ClusterMetricsServerArgs']]:
        """
        - metrics_server_config - MetricsServer determines the metrics server configuration.
        """
        return pulumi.get(self, "metrics_server")

    @metrics_server.setter
    def metrics_server(self, value: Optional[pulumi.Input['ClusterMetricsServerArgs']]):
        pulumi.set(self, "metrics_server", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Force new) - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="networkCidr")
    def network_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        - (Computed) - String - NetworkCIDR is the CIDR used for the AWS VPC / DO/ GCE Network, or otherwise allocated to k8s<br />This is a real CIDR, not the internal k8s network<br />On AWS, it maps to the VPC CIDR.  It is not required on GCE.<br />On DO, it maps to the VPC CIDR.
        """
        return pulumi.get(self, "network_cidr")

    @network_cidr.setter
    def network_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_cidr", value)

    @property
    @pulumi.getter(name="nodeAuthorization")
    def node_authorization(self) -> Optional[pulumi.Input['ClusterNodeAuthorizationArgs']]:
        """
        - node_authorization_spec - NodeAuthorization defined the custom node authorization configuration.
        """
        return pulumi.get(self, "node_authorization")

    @node_authorization.setter
    def node_authorization(self, value: Optional[pulumi.Input['ClusterNodeAuthorizationArgs']]):
        pulumi.set(self, "node_authorization", value)

    @property
    @pulumi.getter(name="nodePortAccesses")
    def node_port_accesses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - List(String) - NodePortAccess is a list of the CIDRs that can access the node ports range (30000-32767).
        """
        return pulumi.get(self, "node_port_accesses")

    @node_port_accesses.setter
    def node_port_accesses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "node_port_accesses", value)

    @property
    @pulumi.getter(name="nodeProblemDetector")
    def node_problem_detector(self) -> Optional[pulumi.Input['ClusterNodeProblemDetectorArgs']]:
        """
        - node_problem_detector_config - NodeProblemDetector determines the node problem detector configuration.
        """
        return pulumi.get(self, "node_problem_detector")

    @node_problem_detector.setter
    def node_problem_detector(self, value: Optional[pulumi.Input['ClusterNodeProblemDetectorArgs']]):
        pulumi.set(self, "node_problem_detector", value)

    @property
    @pulumi.getter(name="nodeTerminationHandler")
    def node_termination_handler(self) -> Optional[pulumi.Input['ClusterNodeTerminationHandlerArgs']]:
        """
        - node_termination_handler_config - NodeTerminationHandler determines the node termination handler configuration.
        """
        return pulumi.get(self, "node_termination_handler")

    @node_termination_handler.setter
    def node_termination_handler(self, value: Optional[pulumi.Input['ClusterNodeTerminationHandlerArgs']]):
        pulumi.set(self, "node_termination_handler", value)

    @property
    @pulumi.getter(name="nonMasqueradeCidr")
    def non_masquerade_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
        """
        return pulumi.get(self, "non_masquerade_cidr")

    @non_masquerade_cidr.setter
    def non_masquerade_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "non_masquerade_cidr", value)

    @property
    @pulumi.getter
    def ntp(self) -> Optional[pulumi.Input['ClusterNtpArgs']]:
        """
        - ntp_config
        """
        return pulumi.get(self, "ntp")

    @ntp.setter
    def ntp(self, value: Optional[pulumi.Input['ClusterNtpArgs']]):
        pulumi.set(self, "ntp", value)

    @property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        - String - PodCIDR is the CIDR from which we allocate IPs for pods.
        """
        return pulumi.get(self, "pod_cidr")

    @pod_cidr.setter
    def pod_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pod_cidr", value)

    @property
    @pulumi.getter(name="podIdentityWebhook")
    def pod_identity_webhook(self) -> Optional[pulumi.Input['ClusterPodIdentityWebhookArgs']]:
        """
        - pod_identity_webhook_config - PodIdentityWebhook determines the EKS Pod Identity Webhook configuration.
        """
        return pulumi.get(self, "pod_identity_webhook")

    @pod_identity_webhook.setter
    def pod_identity_webhook(self, value: Optional[pulumi.Input['ClusterPodIdentityWebhookArgs']]):
        pulumi.set(self, "pod_identity_webhook", value)

    @property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[str]]:
        """
        - String - Project is the cloud project we should use, required on GCE.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project", value)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional[pulumi.Input['ClusterRollingUpdateArgs']]:
        """
        - rolling_update - RollingUpdate defines the default rolling-update settings for instance groups.
        """
        return pulumi.get(self, "rolling_update")

    @rolling_update.setter
    def rolling_update(self, value: Optional[pulumi.Input['ClusterRollingUpdateArgs']]):
        pulumi.set(self, "rolling_update", value)

    @property
    @pulumi.getter(name="secretStore")
    def secret_store(self) -> Optional[pulumi.Input[str]]:
        """
        - String - SecretStore is the VFS path to where secrets are stored.
        """
        return pulumi.get(self, "secret_store")

    @secret_store.setter
    def secret_store(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_store", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input['ClusterSecretsArgs']]:
        """
        - cluster_secrets - Secrets defines the cluster secret.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input['ClusterSecretsArgs']]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter(name="serviceAccountIssuerDiscovery")
    def service_account_issuer_discovery(self) -> Optional[pulumi.Input['ClusterServiceAccountIssuerDiscoveryArgs']]:
        """
        - service_account_issuer_discovery_config - ServiceAccountIssuerDiscovery configures the OIDC Issuer for ServiceAccounts.
        """
        return pulumi.get(self, "service_account_issuer_discovery")

    @service_account_issuer_discovery.setter
    def service_account_issuer_discovery(self, value: Optional[pulumi.Input['ClusterServiceAccountIssuerDiscoveryArgs']]):
        pulumi.set(self, "service_account_issuer_discovery", value)

    @property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> Optional[pulumi.Input[str]]:
        """
        - String - ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services.
        """
        return pulumi.get(self, "service_cluster_ip_range")

    @service_cluster_ip_range.setter
    def service_cluster_ip_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_cluster_ip_range", value)

    @property
    @pulumi.getter(name="snapshotController")
    def snapshot_controller(self) -> Optional[pulumi.Input['ClusterSnapshotControllerArgs']]:
        """
        - snapshot_controller_config - SnapshotController defines the CSI Snapshot Controller configuration.
        """
        return pulumi.get(self, "snapshot_controller")

    @snapshot_controller.setter
    def snapshot_controller(self, value: Optional[pulumi.Input['ClusterSnapshotControllerArgs']]):
        pulumi.set(self, "snapshot_controller", value)

    @property
    @pulumi.getter(name="sshAccesses")
    def ssh_accesses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - List(String) - SSHAccess is a list of the CIDRs that can access SSH.
        """
        return pulumi.get(self, "ssh_accesses")

    @ssh_accesses.setter
    def ssh_accesses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_accesses", value)

    @property
    @pulumi.getter(name="sshKeyName")
    def ssh_key_name(self) -> Optional[pulumi.Input[str]]:
        """
        - String - SSHKeyName specifies a preexisting SSH key to use.
        """
        return pulumi.get(self, "ssh_key_name")

    @ssh_key_name.setter
    def ssh_key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key_name", value)

    @property
    @pulumi.getter(name="sysctlParameters")
    def sysctl_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - List(String) - SysctlParameters will configure kernel parameters using sysctl(8). When<br />specified, each parameter must follow the form variable=value, the way<br />it would appear in sysctl.conf.
        """
        return pulumi.get(self, "sysctl_parameters")

    @sysctl_parameters.setter
    def sysctl_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "sysctl_parameters", value)

    @property
    @pulumi.getter(name="tagSubnets")
    def tag_subnets(self) -> Optional[pulumi.Input['ClusterTagSubnetsArgs']]:
        """
        - Bool(Nullable) - TagSubnets controls if tags are added to subnets to enable use by load balancers (AWS only). Default: true.
        """
        return pulumi.get(self, "tag_subnets")

    @tag_subnets.setter
    def tag_subnets(self, value: Optional[pulumi.Input['ClusterTagSubnetsArgs']]):
        pulumi.set(self, "tag_subnets", value)

    @property
    @pulumi.getter(name="updatePolicy")
    def update_policy(self) -> Optional[pulumi.Input[str]]:
        """
        - String - UpdatePolicy determines the policy for applying upgrades automatically.<br />Valid values:<br />  'automatic' (default): apply updates automatically (apply OS security upgrades, avoiding rebooting when possible)<br />  'external': do not apply updates automatically; they are applied manually or by an external system.
        """
        return pulumi.get(self, "update_policy")

    @update_policy.setter
    def update_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_policy", value)

    @property
    @pulumi.getter(name="useHostCertificates")
    def use_host_certificates(self) -> Optional[pulumi.Input[bool]]:
        """
        - Bool - UseHostCertificates will mount /etc/ssl/certs to inside needed containers.<br />This is needed if some APIs do have self-signed certs.
        """
        return pulumi.get(self, "use_host_certificates")

    @use_host_certificates.setter
    def use_host_certificates(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_host_certificates", value)

    @property
    @pulumi.getter(name="warmPool")
    def warm_pool(self) -> Optional[pulumi.Input['ClusterWarmPoolArgs']]:
        """
        - warm_pool_spec - WarmPool defines the default warm pool settings for instance groups (AWS only).
        """
        return pulumi.get(self, "warm_pool")

    @warm_pool.setter
    def warm_pool(self, value: Optional[pulumi.Input['ClusterWarmPoolArgs']]):
        pulumi.set(self, "warm_pool", value)


@pulumi.input_type
class _ClusterState:
    def __init__(__self__, *,
                 additional_network_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 additional_policies: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 additional_sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 addons: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddonArgs']]]] = None,
                 admin_ssh_key: Optional[pulumi.Input[str]] = None,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 api: Optional[pulumi.Input['ClusterApiArgs']] = None,
                 assets: Optional[pulumi.Input['ClusterAssetsArgs']] = None,
                 authentication: Optional[pulumi.Input['ClusterAuthenticationArgs']] = None,
                 authorization: Optional[pulumi.Input['ClusterAuthorizationArgs']] = None,
                 aws_load_balancer_controller: Optional[pulumi.Input['ClusterAwsLoadBalancerControllerArgs']] = None,
                 cert_manager: Optional[pulumi.Input['ClusterCertManagerArgs']] = None,
                 channel: Optional[pulumi.Input[str]] = None,
                 cloud_config: Optional[pulumi.Input['ClusterCloudConfigArgs']] = None,
                 cloud_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 cloud_provider: Optional[pulumi.Input['ClusterCloudProviderArgs']] = None,
                 cluster_autoscaler: Optional[pulumi.Input['ClusterClusterAutoscalerArgs']] = None,
                 cluster_dns_domain: Optional[pulumi.Input[str]] = None,
                 config_base: Optional[pulumi.Input[str]] = None,
                 config_store: Optional[pulumi.Input[str]] = None,
                 container_runtime: Optional[pulumi.Input[str]] = None,
                 containerd: Optional[pulumi.Input['ClusterContainerdArgs']] = None,
                 dns_zone: Optional[pulumi.Input[str]] = None,
                 docker: Optional[pulumi.Input['ClusterDockerArgs']] = None,
                 egress_proxy: Optional[pulumi.Input['ClusterEgressProxyArgs']] = None,
                 encryption_config: Optional[pulumi.Input[bool]] = None,
                 etcd_clusters: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterEtcdClusterArgs']]]] = None,
                 external_cloud_controller_manager: Optional[pulumi.Input['ClusterExternalCloudControllerManagerArgs']] = None,
                 external_dns: Optional[pulumi.Input['ClusterExternalDnsArgs']] = None,
                 external_policies: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterExternalPolicyArgs']]]] = None,
                 file_assets: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterFileAssetArgs']]]] = None,
                 hooks: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterHookArgs']]]] = None,
                 iam: Optional[pulumi.Input['ClusterIamArgs']] = None,
                 isolate_masters: Optional[pulumi.Input[bool]] = None,
                 karpenter: Optional[pulumi.Input['ClusterKarpenterArgs']] = None,
                 key_store: Optional[pulumi.Input[str]] = None,
                 kube_api_server: Optional[pulumi.Input['ClusterKubeApiServerArgs']] = None,
                 kube_controller_manager: Optional[pulumi.Input['ClusterKubeControllerManagerArgs']] = None,
                 kube_dns: Optional[pulumi.Input['ClusterKubeDnsArgs']] = None,
                 kube_proxy: Optional[pulumi.Input['ClusterKubeProxyArgs']] = None,
                 kube_scheduler: Optional[pulumi.Input['ClusterKubeSchedulerArgs']] = None,
                 kubelet: Optional[pulumi.Input['ClusterKubeletArgs']] = None,
                 kubernetes_api_accesses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kubernetes_version: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 master_internal_name: Optional[pulumi.Input[str]] = None,
                 master_kubelet: Optional[pulumi.Input['ClusterMasterKubeletArgs']] = None,
                 master_public_name: Optional[pulumi.Input[str]] = None,
                 metrics_server: Optional[pulumi.Input['ClusterMetricsServerArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 network_cidr: Optional[pulumi.Input[str]] = None,
                 network_id: Optional[pulumi.Input[str]] = None,
                 networking: Optional[pulumi.Input['ClusterNetworkingArgs']] = None,
                 node_authorization: Optional[pulumi.Input['ClusterNodeAuthorizationArgs']] = None,
                 node_port_accesses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 node_problem_detector: Optional[pulumi.Input['ClusterNodeProblemDetectorArgs']] = None,
                 node_termination_handler: Optional[pulumi.Input['ClusterNodeTerminationHandlerArgs']] = None,
                 non_masquerade_cidr: Optional[pulumi.Input[str]] = None,
                 ntp: Optional[pulumi.Input['ClusterNtpArgs']] = None,
                 pod_cidr: Optional[pulumi.Input[str]] = None,
                 pod_identity_webhook: Optional[pulumi.Input['ClusterPodIdentityWebhookArgs']] = None,
                 project: Optional[pulumi.Input[str]] = None,
                 revision: Optional[pulumi.Input[int]] = None,
                 rolling_update: Optional[pulumi.Input['ClusterRollingUpdateArgs']] = None,
                 secret_store: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input['ClusterSecretsArgs']] = None,
                 service_account_issuer_discovery: Optional[pulumi.Input['ClusterServiceAccountIssuerDiscoveryArgs']] = None,
                 service_cluster_ip_range: Optional[pulumi.Input[str]] = None,
                 snapshot_controller: Optional[pulumi.Input['ClusterSnapshotControllerArgs']] = None,
                 ssh_accesses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ssh_key_name: Optional[pulumi.Input[str]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSubnetArgs']]]] = None,
                 sysctl_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tag_subnets: Optional[pulumi.Input['ClusterTagSubnetsArgs']] = None,
                 topology: Optional[pulumi.Input['ClusterTopologyArgs']] = None,
                 update_policy: Optional[pulumi.Input[str]] = None,
                 use_host_certificates: Optional[pulumi.Input[bool]] = None,
                 warm_pool: Optional[pulumi.Input['ClusterWarmPoolArgs']] = None):
        """
        Input properties used for looking up and filtering Cluster resources.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_network_cidrs: - List(String) - AdditionalNetworkCIDRs is a list of additional CIDR used for the AWS VPC<br />or otherwise allocated to k8s. This is a real CIDR, not the internal k8s network<br />On AWS, it maps to any additional CIDRs added to a VPC.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_policies: - Map(String) - Additional policies to add for roles.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_sans: - List(String) - AdditionalSANs adds additional Subject Alternate Names to apiserver cert that kops generates.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddonArgs']]] addons: - List(addon_spec) - Additional addons that should be installed on the cluster.
        :param pulumi.Input[str] admin_ssh_key: - (Sensitive) - String - AdminSshKey defines the cluster admin ssh key.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: - Map(String) - Annotations is an unstructured key value map stored with a resource that may be<br />set by external tools to store and retrieve arbitrary metadata. They are not<br />queryable and should be preserved when modifying objects.
        :param pulumi.Input['ClusterApiArgs'] api: - access_spec - API field controls how the API is exposed outside the cluster.
        :param pulumi.Input['ClusterAssetsArgs'] assets: - assets - Assets is alternative locations for files and containers; the API under construction, will remove this comment once this API is fully functional.
        :param pulumi.Input['ClusterAuthenticationArgs'] authentication: - authentication_spec - Authentication field controls how the cluster is configured for authentication.
        :param pulumi.Input['ClusterAuthorizationArgs'] authorization: - authorization_spec - Authorization field controls how the cluster is configured for authorization.
        :param pulumi.Input['ClusterAwsLoadBalancerControllerArgs'] aws_load_balancer_controller: - aws_load_balancer_controller_config - AWSLoadbalancerControllerConfig determines the AWS LB controller configuration.
        :param pulumi.Input['ClusterCertManagerArgs'] cert_manager: - cert_manager_config - CertManager determines the metrics server configuration.
        :param pulumi.Input[str] channel: - String - The Channel we are following.
        :param pulumi.Input['ClusterCloudConfigArgs'] cloud_config: - cloud_configuration
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] cloud_labels: - Map(String) - CloudLabels defines additional tags or labels on cloud provider resources.
        :param pulumi.Input['ClusterCloudProviderArgs'] cloud_provider: - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        :param pulumi.Input['ClusterClusterAutoscalerArgs'] cluster_autoscaler: - cluster_autoscaler_config - ClusterAutoscaler defines the cluster autoscaler configuration.
        :param pulumi.Input[str] cluster_dns_domain: - String - ClusterDNSDomain is the suffix we use for internal DNS names (normally cluster.local).
        :param pulumi.Input[str] config_base: - (Computed) - String - ConfigBase is the path where we store configuration for the cluster<br />This might be different than the location where the cluster spec itself is stored,<br />both because this must be accessible to the cluster,<br />and because it might be on a different cloud or storage system (etcd vs S3).
        :param pulumi.Input[str] config_store: - String - ConfigStore is the VFS path to where the configuration (Cluster, InstanceGroups etc) is stored.
        :param pulumi.Input[str] container_runtime: - String - Container runtime to use for Kubernetes.
        :param pulumi.Input['ClusterContainerdArgs'] containerd: - containerd_config - Component configurations.
        :param pulumi.Input[str] dns_zone: - String - DNSZone is the DNS zone we should use when configuring DNS<br />This is because some clouds let us define a managed zone foo.bar, and then have<br />kubernetes.dev.foo.bar, without needing to define dev.foo.bar as a hosted zone.<br />DNSZone will probably be a suffix of the MasterPublicName and MasterInternalName<br />Note that DNSZone can either by the host name of the zone (containing dots),<br />or can be an identifier for the zone.
        :param pulumi.Input['ClusterDockerArgs'] docker: - docker_config
        :param pulumi.Input['ClusterEgressProxyArgs'] egress_proxy: - egress_proxy_spec - HTTPProxy defines connection information to support use of a private cluster behind an forward HTTP Proxy.
        :param pulumi.Input[bool] encryption_config: - Bool - EncryptionConfig controls if encryption is enabled.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterEtcdClusterArgs']]] etcd_clusters: - List(etcd_cluster_spec) - EtcdClusters stores the configuration for each cluster.
        :param pulumi.Input['ClusterExternalCloudControllerManagerArgs'] external_cloud_controller_manager: - cloud_controller_manager_config
        :param pulumi.Input['ClusterExternalDnsArgs'] external_dns: - external_dns_config
        :param pulumi.Input[Sequence[pulumi.Input['ClusterExternalPolicyArgs']]] external_policies: - Map(List(String)) - ExternalPolicies allows the insertion of pre-existing managed policies on IG Roles.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterFileAssetArgs']]] file_assets: - List(file_asset_spec) - A collection of files assets for deployed cluster wide.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterHookArgs']]] hooks: - List(hook_spec) - Hooks for custom actions e.g. on first installation.
        :param pulumi.Input['ClusterIamArgs'] iam: - (Computed) - iam_spec - IAM field adds control over the IAM security policies applied to resources.
        :param pulumi.Input[bool] isolate_masters: - Bool - IsolateMasters determines whether we should lock down masters so that they are not on the pod network.<br />true is the kube-up behaviour, but it is very surprising: it means that daemonsets only work on the master<br />if they have hostNetwork=true.<br />false is now the default, and it will:<br /> * give the master a normal PodCIDR<br /> * run kube-proxy on the master<br /> * enable debugging handlers on the master, so kubectl logs works.
        :param pulumi.Input['ClusterKarpenterArgs'] karpenter: - karpenter_config - Karpenter defines the Karpenter configuration.
        :param pulumi.Input[str] key_store: - String - KeyStore is the VFS path to where SSL keys and certificates are stored.
        :param pulumi.Input['ClusterKubeApiServerArgs'] kube_api_server: - kube_api_server_config
        :param pulumi.Input['ClusterKubeControllerManagerArgs'] kube_controller_manager: - kube_controller_manager_config
        :param pulumi.Input['ClusterKubeDnsArgs'] kube_dns: - kube_dns_config
        :param pulumi.Input['ClusterKubeProxyArgs'] kube_proxy: - kube_proxy_config
        :param pulumi.Input['ClusterKubeSchedulerArgs'] kube_scheduler: - kube_scheduler_config
        :param pulumi.Input['ClusterKubeletArgs'] kubelet: - kubelet_config_spec - Kubelet is the kubelet configuration for nodes not belonging to the control plane.<br />It can be overridden by the kubelet configuration specified in the instance group.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] kubernetes_api_accesses: - List(String) - KubernetesAPIAccess is a list of the CIDRs that can access the Kubernetes API endpoint (master HTTPS).
        :param pulumi.Input[str] kubernetes_version: - String - The version of kubernetes to install (optional, and can be a "spec" like stable).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: - Map(String) - Map of string keys and values that can be used to organize and categorize<br />(scope and select) objects. May match selectors of replication controllers<br />and services.
        :param pulumi.Input[str] master_internal_name: - (Computed) - String - MasterInternalName is the internal DNS name for the master nodes.
        :param pulumi.Input['ClusterMasterKubeletArgs'] master_kubelet: - kubelet_config_spec - MasterKubelet is the kubelet configuration for nodes belonging to the control plane<br />It can be overridden by the kubelet configuration specified in the instance group.
        :param pulumi.Input[str] master_public_name: - (Computed) - String - MasterPublicName is the external DNS name for the master nodes.
        :param pulumi.Input['ClusterMetricsServerArgs'] metrics_server: - metrics_server_config - MetricsServer determines the metrics server configuration.
        :param pulumi.Input[str] name: - (Force new) - String - Name defines the cluster name.
        :param pulumi.Input[str] network_cidr: - (Computed) - String - NetworkCIDR is the CIDR used for the AWS VPC / DO/ GCE Network, or otherwise allocated to k8s<br />This is a real CIDR, not the internal k8s network<br />On AWS, it maps to the VPC CIDR.  It is not required on GCE.<br />On DO, it maps to the VPC CIDR.
        :param pulumi.Input[str] network_id: - String - NetworkID is an identifier of a network, if we want to reuse/share an existing network (e.g. an AWS VPC).
        :param pulumi.Input['ClusterNetworkingArgs'] networking: - networking_spec - Networking configuration.
        :param pulumi.Input['ClusterNodeAuthorizationArgs'] node_authorization: - node_authorization_spec - NodeAuthorization defined the custom node authorization configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] node_port_accesses: - List(String) - NodePortAccess is a list of the CIDRs that can access the node ports range (30000-32767).
        :param pulumi.Input['ClusterNodeProblemDetectorArgs'] node_problem_detector: - node_problem_detector_config - NodeProblemDetector determines the node problem detector configuration.
        :param pulumi.Input['ClusterNodeTerminationHandlerArgs'] node_termination_handler: - node_termination_handler_config - NodeTerminationHandler determines the node termination handler configuration.
        :param pulumi.Input[str] non_masquerade_cidr: - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
        :param pulumi.Input['ClusterNtpArgs'] ntp: - ntp_config
        :param pulumi.Input[str] pod_cidr: - String - PodCIDR is the CIDR from which we allocate IPs for pods.
        :param pulumi.Input['ClusterPodIdentityWebhookArgs'] pod_identity_webhook: - pod_identity_webhook_config - PodIdentityWebhook determines the EKS Pod Identity Webhook configuration.
        :param pulumi.Input[str] project: - String - Project is the cloud project we should use, required on GCE.
        :param pulumi.Input[int] revision: - Int - Revision is incremented every time the resource changes, this is useful for triggering cluster updater.
        :param pulumi.Input['ClusterRollingUpdateArgs'] rolling_update: - rolling_update - RollingUpdate defines the default rolling-update settings for instance groups.
        :param pulumi.Input[str] secret_store: - String - SecretStore is the VFS path to where secrets are stored.
        :param pulumi.Input['ClusterSecretsArgs'] secrets: - cluster_secrets - Secrets defines the cluster secret.
        :param pulumi.Input['ClusterServiceAccountIssuerDiscoveryArgs'] service_account_issuer_discovery: - service_account_issuer_discovery_config - ServiceAccountIssuerDiscovery configures the OIDC Issuer for ServiceAccounts.
        :param pulumi.Input[str] service_cluster_ip_range: - String - ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services.
        :param pulumi.Input['ClusterSnapshotControllerArgs'] snapshot_controller: - snapshot_controller_config - SnapshotController defines the CSI Snapshot Controller configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ssh_accesses: - List(String) - SSHAccess is a list of the CIDRs that can access SSH.
        :param pulumi.Input[str] ssh_key_name: - String - SSHKeyName specifies a preexisting SSH key to use.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterSubnetArgs']]] subnets: - List(cluster_subnet_spec) - Configuration of subnets we are targeting.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sysctl_parameters: - List(String) - SysctlParameters will configure kernel parameters using sysctl(8). When<br />specified, each parameter must follow the form variable=value, the way<br />it would appear in sysctl.conf.
        :param pulumi.Input['ClusterTagSubnetsArgs'] tag_subnets: - Bool(Nullable) - TagSubnets controls if tags are added to subnets to enable use by load balancers (AWS only). Default: true.
        :param pulumi.Input['ClusterTopologyArgs'] topology: - topology_spec - Topology defines the type of network topology to use on the cluster - default public<br />This is heavily weighted towards AWS for the time being, but should also be agnostic enough<br />to port out to GCE later if needed.
        :param pulumi.Input[str] update_policy: - String - UpdatePolicy determines the policy for applying upgrades automatically.<br />Valid values:<br />  'automatic' (default): apply updates automatically (apply OS security upgrades, avoiding rebooting when possible)<br />  'external': do not apply updates automatically; they are applied manually or by an external system.
        :param pulumi.Input[bool] use_host_certificates: - Bool - UseHostCertificates will mount /etc/ssl/certs to inside needed containers.<br />This is needed if some APIs do have self-signed certs.
        :param pulumi.Input['ClusterWarmPoolArgs'] warm_pool: - warm_pool_spec - WarmPool defines the default warm pool settings for instance groups (AWS only).
        """
        if additional_network_cidrs is not None:
            pulumi.set(__self__, "additional_network_cidrs", additional_network_cidrs)
        if additional_policies is not None:
            pulumi.set(__self__, "additional_policies", additional_policies)
        if additional_sans is not None:
            pulumi.set(__self__, "additional_sans", additional_sans)
        if addons is not None:
            pulumi.set(__self__, "addons", addons)
        if admin_ssh_key is not None:
            pulumi.set(__self__, "admin_ssh_key", admin_ssh_key)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if api is not None:
            pulumi.set(__self__, "api", api)
        if assets is not None:
            pulumi.set(__self__, "assets", assets)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if aws_load_balancer_controller is not None:
            pulumi.set(__self__, "aws_load_balancer_controller", aws_load_balancer_controller)
        if cert_manager is not None:
            pulumi.set(__self__, "cert_manager", cert_manager)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if cloud_config is not None:
            pulumi.set(__self__, "cloud_config", cloud_config)
        if cloud_labels is not None:
            pulumi.set(__self__, "cloud_labels", cloud_labels)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if cluster_autoscaler is not None:
            pulumi.set(__self__, "cluster_autoscaler", cluster_autoscaler)
        if cluster_dns_domain is not None:
            pulumi.set(__self__, "cluster_dns_domain", cluster_dns_domain)
        if config_base is not None:
            pulumi.set(__self__, "config_base", config_base)
        if config_store is not None:
            pulumi.set(__self__, "config_store", config_store)
        if container_runtime is not None:
            pulumi.set(__self__, "container_runtime", container_runtime)
        if containerd is not None:
            pulumi.set(__self__, "containerd", containerd)
        if dns_zone is not None:
            pulumi.set(__self__, "dns_zone", dns_zone)
        if docker is not None:
            pulumi.set(__self__, "docker", docker)
        if egress_proxy is not None:
            pulumi.set(__self__, "egress_proxy", egress_proxy)
        if encryption_config is not None:
            pulumi.set(__self__, "encryption_config", encryption_config)
        if etcd_clusters is not None:
            pulumi.set(__self__, "etcd_clusters", etcd_clusters)
        if external_cloud_controller_manager is not None:
            pulumi.set(__self__, "external_cloud_controller_manager", external_cloud_controller_manager)
        if external_dns is not None:
            pulumi.set(__self__, "external_dns", external_dns)
        if external_policies is not None:
            pulumi.set(__self__, "external_policies", external_policies)
        if file_assets is not None:
            pulumi.set(__self__, "file_assets", file_assets)
        if hooks is not None:
            pulumi.set(__self__, "hooks", hooks)
        if iam is not None:
            pulumi.set(__self__, "iam", iam)
        if isolate_masters is not None:
            pulumi.set(__self__, "isolate_masters", isolate_masters)
        if karpenter is not None:
            pulumi.set(__self__, "karpenter", karpenter)
        if key_store is not None:
            pulumi.set(__self__, "key_store", key_store)
        if kube_api_server is not None:
            pulumi.set(__self__, "kube_api_server", kube_api_server)
        if kube_controller_manager is not None:
            pulumi.set(__self__, "kube_controller_manager", kube_controller_manager)
        if kube_dns is not None:
            pulumi.set(__self__, "kube_dns", kube_dns)
        if kube_proxy is not None:
            pulumi.set(__self__, "kube_proxy", kube_proxy)
        if kube_scheduler is not None:
            pulumi.set(__self__, "kube_scheduler", kube_scheduler)
        if kubelet is not None:
            pulumi.set(__self__, "kubelet", kubelet)
        if kubernetes_api_accesses is not None:
            pulumi.set(__self__, "kubernetes_api_accesses", kubernetes_api_accesses)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if master_internal_name is not None:
            pulumi.set(__self__, "master_internal_name", master_internal_name)
        if master_kubelet is not None:
            pulumi.set(__self__, "master_kubelet", master_kubelet)
        if master_public_name is not None:
            pulumi.set(__self__, "master_public_name", master_public_name)
        if metrics_server is not None:
            pulumi.set(__self__, "metrics_server", metrics_server)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_cidr is not None:
            pulumi.set(__self__, "network_cidr", network_cidr)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if networking is not None:
            pulumi.set(__self__, "networking", networking)
        if node_authorization is not None:
            pulumi.set(__self__, "node_authorization", node_authorization)
        if node_port_accesses is not None:
            pulumi.set(__self__, "node_port_accesses", node_port_accesses)
        if node_problem_detector is not None:
            pulumi.set(__self__, "node_problem_detector", node_problem_detector)
        if node_termination_handler is not None:
            pulumi.set(__self__, "node_termination_handler", node_termination_handler)
        if non_masquerade_cidr is not None:
            pulumi.set(__self__, "non_masquerade_cidr", non_masquerade_cidr)
        if ntp is not None:
            pulumi.set(__self__, "ntp", ntp)
        if pod_cidr is not None:
            pulumi.set(__self__, "pod_cidr", pod_cidr)
        if pod_identity_webhook is not None:
            pulumi.set(__self__, "pod_identity_webhook", pod_identity_webhook)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if secret_store is not None:
            pulumi.set(__self__, "secret_store", secret_store)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if service_account_issuer_discovery is not None:
            pulumi.set(__self__, "service_account_issuer_discovery", service_account_issuer_discovery)
        if service_cluster_ip_range is not None:
            pulumi.set(__self__, "service_cluster_ip_range", service_cluster_ip_range)
        if snapshot_controller is not None:
            pulumi.set(__self__, "snapshot_controller", snapshot_controller)
        if ssh_accesses is not None:
            pulumi.set(__self__, "ssh_accesses", ssh_accesses)
        if ssh_key_name is not None:
            pulumi.set(__self__, "ssh_key_name", ssh_key_name)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if sysctl_parameters is not None:
            pulumi.set(__self__, "sysctl_parameters", sysctl_parameters)
        if tag_subnets is not None:
            pulumi.set(__self__, "tag_subnets", tag_subnets)
        if topology is not None:
            pulumi.set(__self__, "topology", topology)
        if update_policy is not None:
            pulumi.set(__self__, "update_policy", update_policy)
        if use_host_certificates is not None:
            pulumi.set(__self__, "use_host_certificates", use_host_certificates)
        if warm_pool is not None:
            pulumi.set(__self__, "warm_pool", warm_pool)

    @property
    @pulumi.getter(name="additionalNetworkCidrs")
    def additional_network_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - List(String) - AdditionalNetworkCIDRs is a list of additional CIDR used for the AWS VPC<br />or otherwise allocated to k8s. This is a real CIDR, not the internal k8s network<br />On AWS, it maps to any additional CIDRs added to a VPC.
        """
        return pulumi.get(self, "additional_network_cidrs")

    @additional_network_cidrs.setter
    def additional_network_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "additional_network_cidrs", value)

    @property
    @pulumi.getter(name="additionalPolicies")
    def additional_policies(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        - Map(String) - Additional policies to add for roles.
        """
        return pulumi.get(self, "additional_policies")

    @additional_policies.setter
    def additional_policies(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "additional_policies", value)

    @property
    @pulumi.getter(name="additionalSans")
    def additional_sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - List(String) - AdditionalSANs adds additional Subject Alternate Names to apiserver cert that kops generates.
        """
        return pulumi.get(self, "additional_sans")

    @additional_sans.setter
    def additional_sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "additional_sans", value)

    @property
    @pulumi.getter
    def addons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddonArgs']]]]:
        """
        - List(addon_spec) - Additional addons that should be installed on the cluster.
        """
        return pulumi.get(self, "addons")

    @addons.setter
    def addons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddonArgs']]]]):
        pulumi.set(self, "addons", value)

    @property
    @pulumi.getter(name="adminSshKey")
    def admin_ssh_key(self) -> Optional[pulumi.Input[str]]:
        """
        - (Sensitive) - String - AdminSshKey defines the cluster admin ssh key.
        """
        return pulumi.get(self, "admin_ssh_key")

    @admin_ssh_key.setter
    def admin_ssh_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_ssh_key", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        - Map(String) - Annotations is an unstructured key value map stored with a resource that may be<br />set by external tools to store and retrieve arbitrary metadata. They are not<br />queryable and should be preserved when modifying objects.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def api(self) -> Optional[pulumi.Input['ClusterApiArgs']]:
        """
        - access_spec - API field controls how the API is exposed outside the cluster.
        """
        return pulumi.get(self, "api")

    @api.setter
    def api(self, value: Optional[pulumi.Input['ClusterApiArgs']]):
        pulumi.set(self, "api", value)

    @property
    @pulumi.getter
    def assets(self) -> Optional[pulumi.Input['ClusterAssetsArgs']]:
        """
        - assets - Assets is alternative locations for files and containers; the API under construction, will remove this comment once this API is fully functional.
        """
        return pulumi.get(self, "assets")

    @assets.setter
    def assets(self, value: Optional[pulumi.Input['ClusterAssetsArgs']]):
        pulumi.set(self, "assets", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ClusterAuthenticationArgs']]:
        """
        - authentication_spec - Authentication field controls how the cluster is configured for authentication.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ClusterAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['ClusterAuthorizationArgs']]:
        """
        - authorization_spec - Authorization field controls how the cluster is configured for authorization.
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['ClusterAuthorizationArgs']]):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter(name="awsLoadBalancerController")
    def aws_load_balancer_controller(self) -> Optional[pulumi.Input['ClusterAwsLoadBalancerControllerArgs']]:
        """
        - aws_load_balancer_controller_config - AWSLoadbalancerControllerConfig determines the AWS LB controller configuration.
        """
        return pulumi.get(self, "aws_load_balancer_controller")

    @aws_load_balancer_controller.setter
    def aws_load_balancer_controller(self, value: Optional[pulumi.Input['ClusterAwsLoadBalancerControllerArgs']]):
        pulumi.set(self, "aws_load_balancer_controller", value)

    @property
    @pulumi.getter(name="certManager")
    def cert_manager(self) -> Optional[pulumi.Input['ClusterCertManagerArgs']]:
        """
        - cert_manager_config - CertManager determines the metrics server configuration.
        """
        return pulumi.get(self, "cert_manager")

    @cert_manager.setter
    def cert_manager(self, value: Optional[pulumi.Input['ClusterCertManagerArgs']]):
        pulumi.set(self, "cert_manager", value)

    @property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[str]]:
        """
        - String - The Channel we are following.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter(name="cloudConfig")
    def cloud_config(self) -> Optional[pulumi.Input['ClusterCloudConfigArgs']]:
        """
        - cloud_configuration
        """
        return pulumi.get(self, "cloud_config")

    @cloud_config.setter
    def cloud_config(self, value: Optional[pulumi.Input['ClusterCloudConfigArgs']]):
        pulumi.set(self, "cloud_config", value)

    @property
    @pulumi.getter(name="cloudLabels")
    def cloud_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        - Map(String) - CloudLabels defines additional tags or labels on cloud provider resources.
        """
        return pulumi.get(self, "cloud_labels")

    @cloud_labels.setter
    def cloud_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "cloud_labels", value)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[pulumi.Input['ClusterCloudProviderArgs']]:
        """
        - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: Optional[pulumi.Input['ClusterCloudProviderArgs']]):
        pulumi.set(self, "cloud_provider", value)

    @property
    @pulumi.getter(name="clusterAutoscaler")
    def cluster_autoscaler(self) -> Optional[pulumi.Input['ClusterClusterAutoscalerArgs']]:
        """
        - cluster_autoscaler_config - ClusterAutoscaler defines the cluster autoscaler configuration.
        """
        return pulumi.get(self, "cluster_autoscaler")

    @cluster_autoscaler.setter
    def cluster_autoscaler(self, value: Optional[pulumi.Input['ClusterClusterAutoscalerArgs']]):
        pulumi.set(self, "cluster_autoscaler", value)

    @property
    @pulumi.getter(name="clusterDnsDomain")
    def cluster_dns_domain(self) -> Optional[pulumi.Input[str]]:
        """
        - String - ClusterDNSDomain is the suffix we use for internal DNS names (normally cluster.local).
        """
        return pulumi.get(self, "cluster_dns_domain")

    @cluster_dns_domain.setter
    def cluster_dns_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_dns_domain", value)

    @property
    @pulumi.getter(name="configBase")
    def config_base(self) -> Optional[pulumi.Input[str]]:
        """
        - (Computed) - String - ConfigBase is the path where we store configuration for the cluster<br />This might be different than the location where the cluster spec itself is stored,<br />both because this must be accessible to the cluster,<br />and because it might be on a different cloud or storage system (etcd vs S3).
        """
        return pulumi.get(self, "config_base")

    @config_base.setter
    def config_base(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_base", value)

    @property
    @pulumi.getter(name="configStore")
    def config_store(self) -> Optional[pulumi.Input[str]]:
        """
        - String - ConfigStore is the VFS path to where the configuration (Cluster, InstanceGroups etc) is stored.
        """
        return pulumi.get(self, "config_store")

    @config_store.setter
    def config_store(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_store", value)

    @property
    @pulumi.getter(name="containerRuntime")
    def container_runtime(self) -> Optional[pulumi.Input[str]]:
        """
        - String - Container runtime to use for Kubernetes.
        """
        return pulumi.get(self, "container_runtime")

    @container_runtime.setter
    def container_runtime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_runtime", value)

    @property
    @pulumi.getter
    def containerd(self) -> Optional[pulumi.Input['ClusterContainerdArgs']]:
        """
        - containerd_config - Component configurations.
        """
        return pulumi.get(self, "containerd")

    @containerd.setter
    def containerd(self, value: Optional[pulumi.Input['ClusterContainerdArgs']]):
        pulumi.set(self, "containerd", value)

    @property
    @pulumi.getter(name="dnsZone")
    def dns_zone(self) -> Optional[pulumi.Input[str]]:
        """
        - String - DNSZone is the DNS zone we should use when configuring DNS<br />This is because some clouds let us define a managed zone foo.bar, and then have<br />kubernetes.dev.foo.bar, without needing to define dev.foo.bar as a hosted zone.<br />DNSZone will probably be a suffix of the MasterPublicName and MasterInternalName<br />Note that DNSZone can either by the host name of the zone (containing dots),<br />or can be an identifier for the zone.
        """
        return pulumi.get(self, "dns_zone")

    @dns_zone.setter
    def dns_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_zone", value)

    @property
    @pulumi.getter
    def docker(self) -> Optional[pulumi.Input['ClusterDockerArgs']]:
        """
        - docker_config
        """
        return pulumi.get(self, "docker")

    @docker.setter
    def docker(self, value: Optional[pulumi.Input['ClusterDockerArgs']]):
        pulumi.set(self, "docker", value)

    @property
    @pulumi.getter(name="egressProxy")
    def egress_proxy(self) -> Optional[pulumi.Input['ClusterEgressProxyArgs']]:
        """
        - egress_proxy_spec - HTTPProxy defines connection information to support use of a private cluster behind an forward HTTP Proxy.
        """
        return pulumi.get(self, "egress_proxy")

    @egress_proxy.setter
    def egress_proxy(self, value: Optional[pulumi.Input['ClusterEgressProxyArgs']]):
        pulumi.set(self, "egress_proxy", value)

    @property
    @pulumi.getter(name="encryptionConfig")
    def encryption_config(self) -> Optional[pulumi.Input[bool]]:
        """
        - Bool - EncryptionConfig controls if encryption is enabled.
        """
        return pulumi.get(self, "encryption_config")

    @encryption_config.setter
    def encryption_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encryption_config", value)

    @property
    @pulumi.getter(name="etcdClusters")
    def etcd_clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterEtcdClusterArgs']]]]:
        """
        - List(etcd_cluster_spec) - EtcdClusters stores the configuration for each cluster.
        """
        return pulumi.get(self, "etcd_clusters")

    @etcd_clusters.setter
    def etcd_clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterEtcdClusterArgs']]]]):
        pulumi.set(self, "etcd_clusters", value)

    @property
    @pulumi.getter(name="externalCloudControllerManager")
    def external_cloud_controller_manager(self) -> Optional[pulumi.Input['ClusterExternalCloudControllerManagerArgs']]:
        """
        - cloud_controller_manager_config
        """
        return pulumi.get(self, "external_cloud_controller_manager")

    @external_cloud_controller_manager.setter
    def external_cloud_controller_manager(self, value: Optional[pulumi.Input['ClusterExternalCloudControllerManagerArgs']]):
        pulumi.set(self, "external_cloud_controller_manager", value)

    @property
    @pulumi.getter(name="externalDns")
    def external_dns(self) -> Optional[pulumi.Input['ClusterExternalDnsArgs']]:
        """
        - external_dns_config
        """
        return pulumi.get(self, "external_dns")

    @external_dns.setter
    def external_dns(self, value: Optional[pulumi.Input['ClusterExternalDnsArgs']]):
        pulumi.set(self, "external_dns", value)

    @property
    @pulumi.getter(name="externalPolicies")
    def external_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterExternalPolicyArgs']]]]:
        """
        - Map(List(String)) - ExternalPolicies allows the insertion of pre-existing managed policies on IG Roles.
        """
        return pulumi.get(self, "external_policies")

    @external_policies.setter
    def external_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterExternalPolicyArgs']]]]):
        pulumi.set(self, "external_policies", value)

    @property
    @pulumi.getter(name="fileAssets")
    def file_assets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterFileAssetArgs']]]]:
        """
        - List(file_asset_spec) - A collection of files assets for deployed cluster wide.
        """
        return pulumi.get(self, "file_assets")

    @file_assets.setter
    def file_assets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterFileAssetArgs']]]]):
        pulumi.set(self, "file_assets", value)

    @property
    @pulumi.getter
    def hooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterHookArgs']]]]:
        """
        - List(hook_spec) - Hooks for custom actions e.g. on first installation.
        """
        return pulumi.get(self, "hooks")

    @hooks.setter
    def hooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterHookArgs']]]]):
        pulumi.set(self, "hooks", value)

    @property
    @pulumi.getter
    def iam(self) -> Optional[pulumi.Input['ClusterIamArgs']]:
        """
        - (Computed) - iam_spec - IAM field adds control over the IAM security policies applied to resources.
        """
        return pulumi.get(self, "iam")

    @iam.setter
    def iam(self, value: Optional[pulumi.Input['ClusterIamArgs']]):
        pulumi.set(self, "iam", value)

    @property
    @pulumi.getter(name="isolateMasters")
    def isolate_masters(self) -> Optional[pulumi.Input[bool]]:
        """
        - Bool - IsolateMasters determines whether we should lock down masters so that they are not on the pod network.<br />true is the kube-up behaviour, but it is very surprising: it means that daemonsets only work on the master<br />if they have hostNetwork=true.<br />false is now the default, and it will:<br /> * give the master a normal PodCIDR<br /> * run kube-proxy on the master<br /> * enable debugging handlers on the master, so kubectl logs works.
        """
        return pulumi.get(self, "isolate_masters")

    @isolate_masters.setter
    def isolate_masters(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "isolate_masters", value)

    @property
    @pulumi.getter
    def karpenter(self) -> Optional[pulumi.Input['ClusterKarpenterArgs']]:
        """
        - karpenter_config - Karpenter defines the Karpenter configuration.
        """
        return pulumi.get(self, "karpenter")

    @karpenter.setter
    def karpenter(self, value: Optional[pulumi.Input['ClusterKarpenterArgs']]):
        pulumi.set(self, "karpenter", value)

    @property
    @pulumi.getter(name="keyStore")
    def key_store(self) -> Optional[pulumi.Input[str]]:
        """
        - String - KeyStore is the VFS path to where SSL keys and certificates are stored.
        """
        return pulumi.get(self, "key_store")

    @key_store.setter
    def key_store(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_store", value)

    @property
    @pulumi.getter(name="kubeApiServer")
    def kube_api_server(self) -> Optional[pulumi.Input['ClusterKubeApiServerArgs']]:
        """
        - kube_api_server_config
        """
        return pulumi.get(self, "kube_api_server")

    @kube_api_server.setter
    def kube_api_server(self, value: Optional[pulumi.Input['ClusterKubeApiServerArgs']]):
        pulumi.set(self, "kube_api_server", value)

    @property
    @pulumi.getter(name="kubeControllerManager")
    def kube_controller_manager(self) -> Optional[pulumi.Input['ClusterKubeControllerManagerArgs']]:
        """
        - kube_controller_manager_config
        """
        return pulumi.get(self, "kube_controller_manager")

    @kube_controller_manager.setter
    def kube_controller_manager(self, value: Optional[pulumi.Input['ClusterKubeControllerManagerArgs']]):
        pulumi.set(self, "kube_controller_manager", value)

    @property
    @pulumi.getter(name="kubeDns")
    def kube_dns(self) -> Optional[pulumi.Input['ClusterKubeDnsArgs']]:
        """
        - kube_dns_config
        """
        return pulumi.get(self, "kube_dns")

    @kube_dns.setter
    def kube_dns(self, value: Optional[pulumi.Input['ClusterKubeDnsArgs']]):
        pulumi.set(self, "kube_dns", value)

    @property
    @pulumi.getter(name="kubeProxy")
    def kube_proxy(self) -> Optional[pulumi.Input['ClusterKubeProxyArgs']]:
        """
        - kube_proxy_config
        """
        return pulumi.get(self, "kube_proxy")

    @kube_proxy.setter
    def kube_proxy(self, value: Optional[pulumi.Input['ClusterKubeProxyArgs']]):
        pulumi.set(self, "kube_proxy", value)

    @property
    @pulumi.getter(name="kubeScheduler")
    def kube_scheduler(self) -> Optional[pulumi.Input['ClusterKubeSchedulerArgs']]:
        """
        - kube_scheduler_config
        """
        return pulumi.get(self, "kube_scheduler")

    @kube_scheduler.setter
    def kube_scheduler(self, value: Optional[pulumi.Input['ClusterKubeSchedulerArgs']]):
        pulumi.set(self, "kube_scheduler", value)

    @property
    @pulumi.getter
    def kubelet(self) -> Optional[pulumi.Input['ClusterKubeletArgs']]:
        """
        - kubelet_config_spec - Kubelet is the kubelet configuration for nodes not belonging to the control plane.<br />It can be overridden by the kubelet configuration specified in the instance group.
        """
        return pulumi.get(self, "kubelet")

    @kubelet.setter
    def kubelet(self, value: Optional[pulumi.Input['ClusterKubeletArgs']]):
        pulumi.set(self, "kubelet", value)

    @property
    @pulumi.getter(name="kubernetesApiAccesses")
    def kubernetes_api_accesses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - List(String) - KubernetesAPIAccess is a list of the CIDRs that can access the Kubernetes API endpoint (master HTTPS).
        """
        return pulumi.get(self, "kubernetes_api_accesses")

    @kubernetes_api_accesses.setter
    def kubernetes_api_accesses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "kubernetes_api_accesses", value)

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[pulumi.Input[str]]:
        """
        - String - The version of kubernetes to install (optional, and can be a "spec" like stable).
        """
        return pulumi.get(self, "kubernetes_version")

    @kubernetes_version.setter
    def kubernetes_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_version", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        - Map(String) - Map of string keys and values that can be used to organize and categorize<br />(scope and select) objects. May match selectors of replication controllers<br />and services.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="masterInternalName")
    def master_internal_name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Computed) - String - MasterInternalName is the internal DNS name for the master nodes.
        """
        return pulumi.get(self, "master_internal_name")

    @master_internal_name.setter
    def master_internal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "master_internal_name", value)

    @property
    @pulumi.getter(name="masterKubelet")
    def master_kubelet(self) -> Optional[pulumi.Input['ClusterMasterKubeletArgs']]:
        """
        - kubelet_config_spec - MasterKubelet is the kubelet configuration for nodes belonging to the control plane<br />It can be overridden by the kubelet configuration specified in the instance group.
        """
        return pulumi.get(self, "master_kubelet")

    @master_kubelet.setter
    def master_kubelet(self, value: Optional[pulumi.Input['ClusterMasterKubeletArgs']]):
        pulumi.set(self, "master_kubelet", value)

    @property
    @pulumi.getter(name="masterPublicName")
    def master_public_name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Computed) - String - MasterPublicName is the external DNS name for the master nodes.
        """
        return pulumi.get(self, "master_public_name")

    @master_public_name.setter
    def master_public_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "master_public_name", value)

    @property
    @pulumi.getter(name="metricsServer")
    def metrics_server(self) -> Optional[pulumi.Input['ClusterMetricsServerArgs']]:
        """
        - metrics_server_config - MetricsServer determines the metrics server configuration.
        """
        return pulumi.get(self, "metrics_server")

    @metrics_server.setter
    def metrics_server(self, value: Optional[pulumi.Input['ClusterMetricsServerArgs']]):
        pulumi.set(self, "metrics_server", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Force new) - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="networkCidr")
    def network_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        - (Computed) - String - NetworkCIDR is the CIDR used for the AWS VPC / DO/ GCE Network, or otherwise allocated to k8s<br />This is a real CIDR, not the internal k8s network<br />On AWS, it maps to the VPC CIDR.  It is not required on GCE.<br />On DO, it maps to the VPC CIDR.
        """
        return pulumi.get(self, "network_cidr")

    @network_cidr.setter
    def network_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_cidr", value)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[str]]:
        """
        - String - NetworkID is an identifier of a network, if we want to reuse/share an existing network (e.g. an AWS VPC).
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_id", value)

    @property
    @pulumi.getter
    def networking(self) -> Optional[pulumi.Input['ClusterNetworkingArgs']]:
        """
        - networking_spec - Networking configuration.
        """
        return pulumi.get(self, "networking")

    @networking.setter
    def networking(self, value: Optional[pulumi.Input['ClusterNetworkingArgs']]):
        pulumi.set(self, "networking", value)

    @property
    @pulumi.getter(name="nodeAuthorization")
    def node_authorization(self) -> Optional[pulumi.Input['ClusterNodeAuthorizationArgs']]:
        """
        - node_authorization_spec - NodeAuthorization defined the custom node authorization configuration.
        """
        return pulumi.get(self, "node_authorization")

    @node_authorization.setter
    def node_authorization(self, value: Optional[pulumi.Input['ClusterNodeAuthorizationArgs']]):
        pulumi.set(self, "node_authorization", value)

    @property
    @pulumi.getter(name="nodePortAccesses")
    def node_port_accesses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - List(String) - NodePortAccess is a list of the CIDRs that can access the node ports range (30000-32767).
        """
        return pulumi.get(self, "node_port_accesses")

    @node_port_accesses.setter
    def node_port_accesses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "node_port_accesses", value)

    @property
    @pulumi.getter(name="nodeProblemDetector")
    def node_problem_detector(self) -> Optional[pulumi.Input['ClusterNodeProblemDetectorArgs']]:
        """
        - node_problem_detector_config - NodeProblemDetector determines the node problem detector configuration.
        """
        return pulumi.get(self, "node_problem_detector")

    @node_problem_detector.setter
    def node_problem_detector(self, value: Optional[pulumi.Input['ClusterNodeProblemDetectorArgs']]):
        pulumi.set(self, "node_problem_detector", value)

    @property
    @pulumi.getter(name="nodeTerminationHandler")
    def node_termination_handler(self) -> Optional[pulumi.Input['ClusterNodeTerminationHandlerArgs']]:
        """
        - node_termination_handler_config - NodeTerminationHandler determines the node termination handler configuration.
        """
        return pulumi.get(self, "node_termination_handler")

    @node_termination_handler.setter
    def node_termination_handler(self, value: Optional[pulumi.Input['ClusterNodeTerminationHandlerArgs']]):
        pulumi.set(self, "node_termination_handler", value)

    @property
    @pulumi.getter(name="nonMasqueradeCidr")
    def non_masquerade_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
        """
        return pulumi.get(self, "non_masquerade_cidr")

    @non_masquerade_cidr.setter
    def non_masquerade_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "non_masquerade_cidr", value)

    @property
    @pulumi.getter
    def ntp(self) -> Optional[pulumi.Input['ClusterNtpArgs']]:
        """
        - ntp_config
        """
        return pulumi.get(self, "ntp")

    @ntp.setter
    def ntp(self, value: Optional[pulumi.Input['ClusterNtpArgs']]):
        pulumi.set(self, "ntp", value)

    @property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        - String - PodCIDR is the CIDR from which we allocate IPs for pods.
        """
        return pulumi.get(self, "pod_cidr")

    @pod_cidr.setter
    def pod_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pod_cidr", value)

    @property
    @pulumi.getter(name="podIdentityWebhook")
    def pod_identity_webhook(self) -> Optional[pulumi.Input['ClusterPodIdentityWebhookArgs']]:
        """
        - pod_identity_webhook_config - PodIdentityWebhook determines the EKS Pod Identity Webhook configuration.
        """
        return pulumi.get(self, "pod_identity_webhook")

    @pod_identity_webhook.setter
    def pod_identity_webhook(self, value: Optional[pulumi.Input['ClusterPodIdentityWebhookArgs']]):
        pulumi.set(self, "pod_identity_webhook", value)

    @property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[str]]:
        """
        - String - Project is the cloud project we should use, required on GCE.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project", value)

    @property
    @pulumi.getter
    def revision(self) -> Optional[pulumi.Input[int]]:
        """
        - Int - Revision is incremented every time the resource changes, this is useful for triggering cluster updater.
        """
        return pulumi.get(self, "revision")

    @revision.setter
    def revision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "revision", value)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional[pulumi.Input['ClusterRollingUpdateArgs']]:
        """
        - rolling_update - RollingUpdate defines the default rolling-update settings for instance groups.
        """
        return pulumi.get(self, "rolling_update")

    @rolling_update.setter
    def rolling_update(self, value: Optional[pulumi.Input['ClusterRollingUpdateArgs']]):
        pulumi.set(self, "rolling_update", value)

    @property
    @pulumi.getter(name="secretStore")
    def secret_store(self) -> Optional[pulumi.Input[str]]:
        """
        - String - SecretStore is the VFS path to where secrets are stored.
        """
        return pulumi.get(self, "secret_store")

    @secret_store.setter
    def secret_store(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_store", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input['ClusterSecretsArgs']]:
        """
        - cluster_secrets - Secrets defines the cluster secret.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input['ClusterSecretsArgs']]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter(name="serviceAccountIssuerDiscovery")
    def service_account_issuer_discovery(self) -> Optional[pulumi.Input['ClusterServiceAccountIssuerDiscoveryArgs']]:
        """
        - service_account_issuer_discovery_config - ServiceAccountIssuerDiscovery configures the OIDC Issuer for ServiceAccounts.
        """
        return pulumi.get(self, "service_account_issuer_discovery")

    @service_account_issuer_discovery.setter
    def service_account_issuer_discovery(self, value: Optional[pulumi.Input['ClusterServiceAccountIssuerDiscoveryArgs']]):
        pulumi.set(self, "service_account_issuer_discovery", value)

    @property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> Optional[pulumi.Input[str]]:
        """
        - String - ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services.
        """
        return pulumi.get(self, "service_cluster_ip_range")

    @service_cluster_ip_range.setter
    def service_cluster_ip_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_cluster_ip_range", value)

    @property
    @pulumi.getter(name="snapshotController")
    def snapshot_controller(self) -> Optional[pulumi.Input['ClusterSnapshotControllerArgs']]:
        """
        - snapshot_controller_config - SnapshotController defines the CSI Snapshot Controller configuration.
        """
        return pulumi.get(self, "snapshot_controller")

    @snapshot_controller.setter
    def snapshot_controller(self, value: Optional[pulumi.Input['ClusterSnapshotControllerArgs']]):
        pulumi.set(self, "snapshot_controller", value)

    @property
    @pulumi.getter(name="sshAccesses")
    def ssh_accesses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - List(String) - SSHAccess is a list of the CIDRs that can access SSH.
        """
        return pulumi.get(self, "ssh_accesses")

    @ssh_accesses.setter
    def ssh_accesses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_accesses", value)

    @property
    @pulumi.getter(name="sshKeyName")
    def ssh_key_name(self) -> Optional[pulumi.Input[str]]:
        """
        - String - SSHKeyName specifies a preexisting SSH key to use.
        """
        return pulumi.get(self, "ssh_key_name")

    @ssh_key_name.setter
    def ssh_key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key_name", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSubnetArgs']]]]:
        """
        - List(cluster_subnet_spec) - Configuration of subnets we are targeting.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSubnetArgs']]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter(name="sysctlParameters")
    def sysctl_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - List(String) - SysctlParameters will configure kernel parameters using sysctl(8). When<br />specified, each parameter must follow the form variable=value, the way<br />it would appear in sysctl.conf.
        """
        return pulumi.get(self, "sysctl_parameters")

    @sysctl_parameters.setter
    def sysctl_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "sysctl_parameters", value)

    @property
    @pulumi.getter(name="tagSubnets")
    def tag_subnets(self) -> Optional[pulumi.Input['ClusterTagSubnetsArgs']]:
        """
        - Bool(Nullable) - TagSubnets controls if tags are added to subnets to enable use by load balancers (AWS only). Default: true.
        """
        return pulumi.get(self, "tag_subnets")

    @tag_subnets.setter
    def tag_subnets(self, value: Optional[pulumi.Input['ClusterTagSubnetsArgs']]):
        pulumi.set(self, "tag_subnets", value)

    @property
    @pulumi.getter
    def topology(self) -> Optional[pulumi.Input['ClusterTopologyArgs']]:
        """
        - topology_spec - Topology defines the type of network topology to use on the cluster - default public<br />This is heavily weighted towards AWS for the time being, but should also be agnostic enough<br />to port out to GCE later if needed.
        """
        return pulumi.get(self, "topology")

    @topology.setter
    def topology(self, value: Optional[pulumi.Input['ClusterTopologyArgs']]):
        pulumi.set(self, "topology", value)

    @property
    @pulumi.getter(name="updatePolicy")
    def update_policy(self) -> Optional[pulumi.Input[str]]:
        """
        - String - UpdatePolicy determines the policy for applying upgrades automatically.<br />Valid values:<br />  'automatic' (default): apply updates automatically (apply OS security upgrades, avoiding rebooting when possible)<br />  'external': do not apply updates automatically; they are applied manually or by an external system.
        """
        return pulumi.get(self, "update_policy")

    @update_policy.setter
    def update_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_policy", value)

    @property
    @pulumi.getter(name="useHostCertificates")
    def use_host_certificates(self) -> Optional[pulumi.Input[bool]]:
        """
        - Bool - UseHostCertificates will mount /etc/ssl/certs to inside needed containers.<br />This is needed if some APIs do have self-signed certs.
        """
        return pulumi.get(self, "use_host_certificates")

    @use_host_certificates.setter
    def use_host_certificates(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_host_certificates", value)

    @property
    @pulumi.getter(name="warmPool")
    def warm_pool(self) -> Optional[pulumi.Input['ClusterWarmPoolArgs']]:
        """
        - warm_pool_spec - WarmPool defines the default warm pool settings for instance groups (AWS only).
        """
        return pulumi.get(self, "warm_pool")

    @warm_pool.setter
    def warm_pool(self, value: Optional[pulumi.Input['ClusterWarmPoolArgs']]):
        pulumi.set(self, "warm_pool", value)


class Cluster(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 additional_network_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 additional_policies: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 additional_sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 addons: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterAddonArgs']]]]] = None,
                 admin_ssh_key: Optional[pulumi.Input[str]] = None,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 api: Optional[pulumi.Input[pulumi.InputType['ClusterApiArgs']]] = None,
                 assets: Optional[pulumi.Input[pulumi.InputType['ClusterAssetsArgs']]] = None,
                 authentication: Optional[pulumi.Input[pulumi.InputType['ClusterAuthenticationArgs']]] = None,
                 authorization: Optional[pulumi.Input[pulumi.InputType['ClusterAuthorizationArgs']]] = None,
                 aws_load_balancer_controller: Optional[pulumi.Input[pulumi.InputType['ClusterAwsLoadBalancerControllerArgs']]] = None,
                 cert_manager: Optional[pulumi.Input[pulumi.InputType['ClusterCertManagerArgs']]] = None,
                 channel: Optional[pulumi.Input[str]] = None,
                 cloud_config: Optional[pulumi.Input[pulumi.InputType['ClusterCloudConfigArgs']]] = None,
                 cloud_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 cloud_provider: Optional[pulumi.Input[pulumi.InputType['ClusterCloudProviderArgs']]] = None,
                 cluster_autoscaler: Optional[pulumi.Input[pulumi.InputType['ClusterClusterAutoscalerArgs']]] = None,
                 cluster_dns_domain: Optional[pulumi.Input[str]] = None,
                 config_base: Optional[pulumi.Input[str]] = None,
                 config_store: Optional[pulumi.Input[str]] = None,
                 container_runtime: Optional[pulumi.Input[str]] = None,
                 containerd: Optional[pulumi.Input[pulumi.InputType['ClusterContainerdArgs']]] = None,
                 dns_zone: Optional[pulumi.Input[str]] = None,
                 docker: Optional[pulumi.Input[pulumi.InputType['ClusterDockerArgs']]] = None,
                 egress_proxy: Optional[pulumi.Input[pulumi.InputType['ClusterEgressProxyArgs']]] = None,
                 encryption_config: Optional[pulumi.Input[bool]] = None,
                 etcd_clusters: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterEtcdClusterArgs']]]]] = None,
                 external_cloud_controller_manager: Optional[pulumi.Input[pulumi.InputType['ClusterExternalCloudControllerManagerArgs']]] = None,
                 external_dns: Optional[pulumi.Input[pulumi.InputType['ClusterExternalDnsArgs']]] = None,
                 external_policies: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterExternalPolicyArgs']]]]] = None,
                 file_assets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterFileAssetArgs']]]]] = None,
                 hooks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterHookArgs']]]]] = None,
                 iam: Optional[pulumi.Input[pulumi.InputType['ClusterIamArgs']]] = None,
                 isolate_masters: Optional[pulumi.Input[bool]] = None,
                 karpenter: Optional[pulumi.Input[pulumi.InputType['ClusterKarpenterArgs']]] = None,
                 key_store: Optional[pulumi.Input[str]] = None,
                 kube_api_server: Optional[pulumi.Input[pulumi.InputType['ClusterKubeApiServerArgs']]] = None,
                 kube_controller_manager: Optional[pulumi.Input[pulumi.InputType['ClusterKubeControllerManagerArgs']]] = None,
                 kube_dns: Optional[pulumi.Input[pulumi.InputType['ClusterKubeDnsArgs']]] = None,
                 kube_proxy: Optional[pulumi.Input[pulumi.InputType['ClusterKubeProxyArgs']]] = None,
                 kube_scheduler: Optional[pulumi.Input[pulumi.InputType['ClusterKubeSchedulerArgs']]] = None,
                 kubelet: Optional[pulumi.Input[pulumi.InputType['ClusterKubeletArgs']]] = None,
                 kubernetes_api_accesses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kubernetes_version: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 master_internal_name: Optional[pulumi.Input[str]] = None,
                 master_kubelet: Optional[pulumi.Input[pulumi.InputType['ClusterMasterKubeletArgs']]] = None,
                 master_public_name: Optional[pulumi.Input[str]] = None,
                 metrics_server: Optional[pulumi.Input[pulumi.InputType['ClusterMetricsServerArgs']]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 network_cidr: Optional[pulumi.Input[str]] = None,
                 network_id: Optional[pulumi.Input[str]] = None,
                 networking: Optional[pulumi.Input[pulumi.InputType['ClusterNetworkingArgs']]] = None,
                 node_authorization: Optional[pulumi.Input[pulumi.InputType['ClusterNodeAuthorizationArgs']]] = None,
                 node_port_accesses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 node_problem_detector: Optional[pulumi.Input[pulumi.InputType['ClusterNodeProblemDetectorArgs']]] = None,
                 node_termination_handler: Optional[pulumi.Input[pulumi.InputType['ClusterNodeTerminationHandlerArgs']]] = None,
                 non_masquerade_cidr: Optional[pulumi.Input[str]] = None,
                 ntp: Optional[pulumi.Input[pulumi.InputType['ClusterNtpArgs']]] = None,
                 pod_cidr: Optional[pulumi.Input[str]] = None,
                 pod_identity_webhook: Optional[pulumi.Input[pulumi.InputType['ClusterPodIdentityWebhookArgs']]] = None,
                 project: Optional[pulumi.Input[str]] = None,
                 rolling_update: Optional[pulumi.Input[pulumi.InputType['ClusterRollingUpdateArgs']]] = None,
                 secret_store: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[pulumi.InputType['ClusterSecretsArgs']]] = None,
                 service_account_issuer_discovery: Optional[pulumi.Input[pulumi.InputType['ClusterServiceAccountIssuerDiscoveryArgs']]] = None,
                 service_cluster_ip_range: Optional[pulumi.Input[str]] = None,
                 snapshot_controller: Optional[pulumi.Input[pulumi.InputType['ClusterSnapshotControllerArgs']]] = None,
                 ssh_accesses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ssh_key_name: Optional[pulumi.Input[str]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterSubnetArgs']]]]] = None,
                 sysctl_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tag_subnets: Optional[pulumi.Input[pulumi.InputType['ClusterTagSubnetsArgs']]] = None,
                 topology: Optional[pulumi.Input[pulumi.InputType['ClusterTopologyArgs']]] = None,
                 update_policy: Optional[pulumi.Input[str]] = None,
                 use_host_certificates: Optional[pulumi.Input[bool]] = None,
                 warm_pool: Optional[pulumi.Input[pulumi.InputType['ClusterWarmPoolArgs']]] = None,
                 __props__=None):
        """
        ## Import

        You can import an existing cluster by creating a `kops_cluster` configuration

        ```sh
         $ pulumi import kops:index/cluster:Cluster and running the `terraform import` command
        ```

         1. Create a terraform configuration:

         hcl

         provider "kops" {

         state_store = "s3://cluster.example.com"

         }

         resource "kops_cluster" "cluster" {

         name

        = "cluster.example.com"

         // ....

         }

        ```sh
         $ pulumi import kops:index/cluster:Cluster

        Run `terraform import`
        ```

        ```sh
         $ pulumi import kops:index/cluster:Cluster kops_cluster.cluster cluster.example.com
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_network_cidrs: - List(String) - AdditionalNetworkCIDRs is a list of additional CIDR used for the AWS VPC<br />or otherwise allocated to k8s. This is a real CIDR, not the internal k8s network<br />On AWS, it maps to any additional CIDRs added to a VPC.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_policies: - Map(String) - Additional policies to add for roles.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_sans: - List(String) - AdditionalSANs adds additional Subject Alternate Names to apiserver cert that kops generates.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterAddonArgs']]]] addons: - List(addon_spec) - Additional addons that should be installed on the cluster.
        :param pulumi.Input[str] admin_ssh_key: - (Sensitive) - String - AdminSshKey defines the cluster admin ssh key.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: - Map(String) - Annotations is an unstructured key value map stored with a resource that may be<br />set by external tools to store and retrieve arbitrary metadata. They are not<br />queryable and should be preserved when modifying objects.
        :param pulumi.Input[pulumi.InputType['ClusterApiArgs']] api: - access_spec - API field controls how the API is exposed outside the cluster.
        :param pulumi.Input[pulumi.InputType['ClusterAssetsArgs']] assets: - assets - Assets is alternative locations for files and containers; the API under construction, will remove this comment once this API is fully functional.
        :param pulumi.Input[pulumi.InputType['ClusterAuthenticationArgs']] authentication: - authentication_spec - Authentication field controls how the cluster is configured for authentication.
        :param pulumi.Input[pulumi.InputType['ClusterAuthorizationArgs']] authorization: - authorization_spec - Authorization field controls how the cluster is configured for authorization.
        :param pulumi.Input[pulumi.InputType['ClusterAwsLoadBalancerControllerArgs']] aws_load_balancer_controller: - aws_load_balancer_controller_config - AWSLoadbalancerControllerConfig determines the AWS LB controller configuration.
        :param pulumi.Input[pulumi.InputType['ClusterCertManagerArgs']] cert_manager: - cert_manager_config - CertManager determines the metrics server configuration.
        :param pulumi.Input[str] channel: - String - The Channel we are following.
        :param pulumi.Input[pulumi.InputType['ClusterCloudConfigArgs']] cloud_config: - cloud_configuration
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] cloud_labels: - Map(String) - CloudLabels defines additional tags or labels on cloud provider resources.
        :param pulumi.Input[pulumi.InputType['ClusterCloudProviderArgs']] cloud_provider: - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        :param pulumi.Input[pulumi.InputType['ClusterClusterAutoscalerArgs']] cluster_autoscaler: - cluster_autoscaler_config - ClusterAutoscaler defines the cluster autoscaler configuration.
        :param pulumi.Input[str] cluster_dns_domain: - String - ClusterDNSDomain is the suffix we use for internal DNS names (normally cluster.local).
        :param pulumi.Input[str] config_base: - (Computed) - String - ConfigBase is the path where we store configuration for the cluster<br />This might be different than the location where the cluster spec itself is stored,<br />both because this must be accessible to the cluster,<br />and because it might be on a different cloud or storage system (etcd vs S3).
        :param pulumi.Input[str] config_store: - String - ConfigStore is the VFS path to where the configuration (Cluster, InstanceGroups etc) is stored.
        :param pulumi.Input[str] container_runtime: - String - Container runtime to use for Kubernetes.
        :param pulumi.Input[pulumi.InputType['ClusterContainerdArgs']] containerd: - containerd_config - Component configurations.
        :param pulumi.Input[str] dns_zone: - String - DNSZone is the DNS zone we should use when configuring DNS<br />This is because some clouds let us define a managed zone foo.bar, and then have<br />kubernetes.dev.foo.bar, without needing to define dev.foo.bar as a hosted zone.<br />DNSZone will probably be a suffix of the MasterPublicName and MasterInternalName<br />Note that DNSZone can either by the host name of the zone (containing dots),<br />or can be an identifier for the zone.
        :param pulumi.Input[pulumi.InputType['ClusterDockerArgs']] docker: - docker_config
        :param pulumi.Input[pulumi.InputType['ClusterEgressProxyArgs']] egress_proxy: - egress_proxy_spec - HTTPProxy defines connection information to support use of a private cluster behind an forward HTTP Proxy.
        :param pulumi.Input[bool] encryption_config: - Bool - EncryptionConfig controls if encryption is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterEtcdClusterArgs']]]] etcd_clusters: - List(etcd_cluster_spec) - EtcdClusters stores the configuration for each cluster.
        :param pulumi.Input[pulumi.InputType['ClusterExternalCloudControllerManagerArgs']] external_cloud_controller_manager: - cloud_controller_manager_config
        :param pulumi.Input[pulumi.InputType['ClusterExternalDnsArgs']] external_dns: - external_dns_config
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterExternalPolicyArgs']]]] external_policies: - Map(List(String)) - ExternalPolicies allows the insertion of pre-existing managed policies on IG Roles.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterFileAssetArgs']]]] file_assets: - List(file_asset_spec) - A collection of files assets for deployed cluster wide.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterHookArgs']]]] hooks: - List(hook_spec) - Hooks for custom actions e.g. on first installation.
        :param pulumi.Input[pulumi.InputType['ClusterIamArgs']] iam: - (Computed) - iam_spec - IAM field adds control over the IAM security policies applied to resources.
        :param pulumi.Input[bool] isolate_masters: - Bool - IsolateMasters determines whether we should lock down masters so that they are not on the pod network.<br />true is the kube-up behaviour, but it is very surprising: it means that daemonsets only work on the master<br />if they have hostNetwork=true.<br />false is now the default, and it will:<br /> * give the master a normal PodCIDR<br /> * run kube-proxy on the master<br /> * enable debugging handlers on the master, so kubectl logs works.
        :param pulumi.Input[pulumi.InputType['ClusterKarpenterArgs']] karpenter: - karpenter_config - Karpenter defines the Karpenter configuration.
        :param pulumi.Input[str] key_store: - String - KeyStore is the VFS path to where SSL keys and certificates are stored.
        :param pulumi.Input[pulumi.InputType['ClusterKubeApiServerArgs']] kube_api_server: - kube_api_server_config
        :param pulumi.Input[pulumi.InputType['ClusterKubeControllerManagerArgs']] kube_controller_manager: - kube_controller_manager_config
        :param pulumi.Input[pulumi.InputType['ClusterKubeDnsArgs']] kube_dns: - kube_dns_config
        :param pulumi.Input[pulumi.InputType['ClusterKubeProxyArgs']] kube_proxy: - kube_proxy_config
        :param pulumi.Input[pulumi.InputType['ClusterKubeSchedulerArgs']] kube_scheduler: - kube_scheduler_config
        :param pulumi.Input[pulumi.InputType['ClusterKubeletArgs']] kubelet: - kubelet_config_spec - Kubelet is the kubelet configuration for nodes not belonging to the control plane.<br />It can be overridden by the kubelet configuration specified in the instance group.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] kubernetes_api_accesses: - List(String) - KubernetesAPIAccess is a list of the CIDRs that can access the Kubernetes API endpoint (master HTTPS).
        :param pulumi.Input[str] kubernetes_version: - String - The version of kubernetes to install (optional, and can be a "spec" like stable).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: - Map(String) - Map of string keys and values that can be used to organize and categorize<br />(scope and select) objects. May match selectors of replication controllers<br />and services.
        :param pulumi.Input[str] master_internal_name: - (Computed) - String - MasterInternalName is the internal DNS name for the master nodes.
        :param pulumi.Input[pulumi.InputType['ClusterMasterKubeletArgs']] master_kubelet: - kubelet_config_spec - MasterKubelet is the kubelet configuration for nodes belonging to the control plane<br />It can be overridden by the kubelet configuration specified in the instance group.
        :param pulumi.Input[str] master_public_name: - (Computed) - String - MasterPublicName is the external DNS name for the master nodes.
        :param pulumi.Input[pulumi.InputType['ClusterMetricsServerArgs']] metrics_server: - metrics_server_config - MetricsServer determines the metrics server configuration.
        :param pulumi.Input[str] name: - (Force new) - String - Name defines the cluster name.
        :param pulumi.Input[str] network_cidr: - (Computed) - String - NetworkCIDR is the CIDR used for the AWS VPC / DO/ GCE Network, or otherwise allocated to k8s<br />This is a real CIDR, not the internal k8s network<br />On AWS, it maps to the VPC CIDR.  It is not required on GCE.<br />On DO, it maps to the VPC CIDR.
        :param pulumi.Input[str] network_id: - String - NetworkID is an identifier of a network, if we want to reuse/share an existing network (e.g. an AWS VPC).
        :param pulumi.Input[pulumi.InputType['ClusterNetworkingArgs']] networking: - networking_spec - Networking configuration.
        :param pulumi.Input[pulumi.InputType['ClusterNodeAuthorizationArgs']] node_authorization: - node_authorization_spec - NodeAuthorization defined the custom node authorization configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] node_port_accesses: - List(String) - NodePortAccess is a list of the CIDRs that can access the node ports range (30000-32767).
        :param pulumi.Input[pulumi.InputType['ClusterNodeProblemDetectorArgs']] node_problem_detector: - node_problem_detector_config - NodeProblemDetector determines the node problem detector configuration.
        :param pulumi.Input[pulumi.InputType['ClusterNodeTerminationHandlerArgs']] node_termination_handler: - node_termination_handler_config - NodeTerminationHandler determines the node termination handler configuration.
        :param pulumi.Input[str] non_masquerade_cidr: - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
        :param pulumi.Input[pulumi.InputType['ClusterNtpArgs']] ntp: - ntp_config
        :param pulumi.Input[str] pod_cidr: - String - PodCIDR is the CIDR from which we allocate IPs for pods.
        :param pulumi.Input[pulumi.InputType['ClusterPodIdentityWebhookArgs']] pod_identity_webhook: - pod_identity_webhook_config - PodIdentityWebhook determines the EKS Pod Identity Webhook configuration.
        :param pulumi.Input[str] project: - String - Project is the cloud project we should use, required on GCE.
        :param pulumi.Input[pulumi.InputType['ClusterRollingUpdateArgs']] rolling_update: - rolling_update - RollingUpdate defines the default rolling-update settings for instance groups.
        :param pulumi.Input[str] secret_store: - String - SecretStore is the VFS path to where secrets are stored.
        :param pulumi.Input[pulumi.InputType['ClusterSecretsArgs']] secrets: - cluster_secrets - Secrets defines the cluster secret.
        :param pulumi.Input[pulumi.InputType['ClusterServiceAccountIssuerDiscoveryArgs']] service_account_issuer_discovery: - service_account_issuer_discovery_config - ServiceAccountIssuerDiscovery configures the OIDC Issuer for ServiceAccounts.
        :param pulumi.Input[str] service_cluster_ip_range: - String - ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services.
        :param pulumi.Input[pulumi.InputType['ClusterSnapshotControllerArgs']] snapshot_controller: - snapshot_controller_config - SnapshotController defines the CSI Snapshot Controller configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ssh_accesses: - List(String) - SSHAccess is a list of the CIDRs that can access SSH.
        :param pulumi.Input[str] ssh_key_name: - String - SSHKeyName specifies a preexisting SSH key to use.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterSubnetArgs']]]] subnets: - List(cluster_subnet_spec) - Configuration of subnets we are targeting.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sysctl_parameters: - List(String) - SysctlParameters will configure kernel parameters using sysctl(8). When<br />specified, each parameter must follow the form variable=value, the way<br />it would appear in sysctl.conf.
        :param pulumi.Input[pulumi.InputType['ClusterTagSubnetsArgs']] tag_subnets: - Bool(Nullable) - TagSubnets controls if tags are added to subnets to enable use by load balancers (AWS only). Default: true.
        :param pulumi.Input[pulumi.InputType['ClusterTopologyArgs']] topology: - topology_spec - Topology defines the type of network topology to use on the cluster - default public<br />This is heavily weighted towards AWS for the time being, but should also be agnostic enough<br />to port out to GCE later if needed.
        :param pulumi.Input[str] update_policy: - String - UpdatePolicy determines the policy for applying upgrades automatically.<br />Valid values:<br />  'automatic' (default): apply updates automatically (apply OS security upgrades, avoiding rebooting when possible)<br />  'external': do not apply updates automatically; they are applied manually or by an external system.
        :param pulumi.Input[bool] use_host_certificates: - Bool - UseHostCertificates will mount /etc/ssl/certs to inside needed containers.<br />This is needed if some APIs do have self-signed certs.
        :param pulumi.Input[pulumi.InputType['ClusterWarmPoolArgs']] warm_pool: - warm_pool_spec - WarmPool defines the default warm pool settings for instance groups (AWS only).
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: ClusterArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        ## Import

        You can import an existing cluster by creating a `kops_cluster` configuration

        ```sh
         $ pulumi import kops:index/cluster:Cluster and running the `terraform import` command
        ```

         1. Create a terraform configuration:

         hcl

         provider "kops" {

         state_store = "s3://cluster.example.com"

         }

         resource "kops_cluster" "cluster" {

         name

        = "cluster.example.com"

         // ....

         }

        ```sh
         $ pulumi import kops:index/cluster:Cluster

        Run `terraform import`
        ```

        ```sh
         $ pulumi import kops:index/cluster:Cluster kops_cluster.cluster cluster.example.com
        ```

        :param str resource_name: The name of the resource.
        :param ClusterArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ClusterArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 additional_network_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 additional_policies: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 additional_sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 addons: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterAddonArgs']]]]] = None,
                 admin_ssh_key: Optional[pulumi.Input[str]] = None,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 api: Optional[pulumi.Input[pulumi.InputType['ClusterApiArgs']]] = None,
                 assets: Optional[pulumi.Input[pulumi.InputType['ClusterAssetsArgs']]] = None,
                 authentication: Optional[pulumi.Input[pulumi.InputType['ClusterAuthenticationArgs']]] = None,
                 authorization: Optional[pulumi.Input[pulumi.InputType['ClusterAuthorizationArgs']]] = None,
                 aws_load_balancer_controller: Optional[pulumi.Input[pulumi.InputType['ClusterAwsLoadBalancerControllerArgs']]] = None,
                 cert_manager: Optional[pulumi.Input[pulumi.InputType['ClusterCertManagerArgs']]] = None,
                 channel: Optional[pulumi.Input[str]] = None,
                 cloud_config: Optional[pulumi.Input[pulumi.InputType['ClusterCloudConfigArgs']]] = None,
                 cloud_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 cloud_provider: Optional[pulumi.Input[pulumi.InputType['ClusterCloudProviderArgs']]] = None,
                 cluster_autoscaler: Optional[pulumi.Input[pulumi.InputType['ClusterClusterAutoscalerArgs']]] = None,
                 cluster_dns_domain: Optional[pulumi.Input[str]] = None,
                 config_base: Optional[pulumi.Input[str]] = None,
                 config_store: Optional[pulumi.Input[str]] = None,
                 container_runtime: Optional[pulumi.Input[str]] = None,
                 containerd: Optional[pulumi.Input[pulumi.InputType['ClusterContainerdArgs']]] = None,
                 dns_zone: Optional[pulumi.Input[str]] = None,
                 docker: Optional[pulumi.Input[pulumi.InputType['ClusterDockerArgs']]] = None,
                 egress_proxy: Optional[pulumi.Input[pulumi.InputType['ClusterEgressProxyArgs']]] = None,
                 encryption_config: Optional[pulumi.Input[bool]] = None,
                 etcd_clusters: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterEtcdClusterArgs']]]]] = None,
                 external_cloud_controller_manager: Optional[pulumi.Input[pulumi.InputType['ClusterExternalCloudControllerManagerArgs']]] = None,
                 external_dns: Optional[pulumi.Input[pulumi.InputType['ClusterExternalDnsArgs']]] = None,
                 external_policies: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterExternalPolicyArgs']]]]] = None,
                 file_assets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterFileAssetArgs']]]]] = None,
                 hooks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterHookArgs']]]]] = None,
                 iam: Optional[pulumi.Input[pulumi.InputType['ClusterIamArgs']]] = None,
                 isolate_masters: Optional[pulumi.Input[bool]] = None,
                 karpenter: Optional[pulumi.Input[pulumi.InputType['ClusterKarpenterArgs']]] = None,
                 key_store: Optional[pulumi.Input[str]] = None,
                 kube_api_server: Optional[pulumi.Input[pulumi.InputType['ClusterKubeApiServerArgs']]] = None,
                 kube_controller_manager: Optional[pulumi.Input[pulumi.InputType['ClusterKubeControllerManagerArgs']]] = None,
                 kube_dns: Optional[pulumi.Input[pulumi.InputType['ClusterKubeDnsArgs']]] = None,
                 kube_proxy: Optional[pulumi.Input[pulumi.InputType['ClusterKubeProxyArgs']]] = None,
                 kube_scheduler: Optional[pulumi.Input[pulumi.InputType['ClusterKubeSchedulerArgs']]] = None,
                 kubelet: Optional[pulumi.Input[pulumi.InputType['ClusterKubeletArgs']]] = None,
                 kubernetes_api_accesses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kubernetes_version: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 master_internal_name: Optional[pulumi.Input[str]] = None,
                 master_kubelet: Optional[pulumi.Input[pulumi.InputType['ClusterMasterKubeletArgs']]] = None,
                 master_public_name: Optional[pulumi.Input[str]] = None,
                 metrics_server: Optional[pulumi.Input[pulumi.InputType['ClusterMetricsServerArgs']]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 network_cidr: Optional[pulumi.Input[str]] = None,
                 network_id: Optional[pulumi.Input[str]] = None,
                 networking: Optional[pulumi.Input[pulumi.InputType['ClusterNetworkingArgs']]] = None,
                 node_authorization: Optional[pulumi.Input[pulumi.InputType['ClusterNodeAuthorizationArgs']]] = None,
                 node_port_accesses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 node_problem_detector: Optional[pulumi.Input[pulumi.InputType['ClusterNodeProblemDetectorArgs']]] = None,
                 node_termination_handler: Optional[pulumi.Input[pulumi.InputType['ClusterNodeTerminationHandlerArgs']]] = None,
                 non_masquerade_cidr: Optional[pulumi.Input[str]] = None,
                 ntp: Optional[pulumi.Input[pulumi.InputType['ClusterNtpArgs']]] = None,
                 pod_cidr: Optional[pulumi.Input[str]] = None,
                 pod_identity_webhook: Optional[pulumi.Input[pulumi.InputType['ClusterPodIdentityWebhookArgs']]] = None,
                 project: Optional[pulumi.Input[str]] = None,
                 rolling_update: Optional[pulumi.Input[pulumi.InputType['ClusterRollingUpdateArgs']]] = None,
                 secret_store: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[pulumi.InputType['ClusterSecretsArgs']]] = None,
                 service_account_issuer_discovery: Optional[pulumi.Input[pulumi.InputType['ClusterServiceAccountIssuerDiscoveryArgs']]] = None,
                 service_cluster_ip_range: Optional[pulumi.Input[str]] = None,
                 snapshot_controller: Optional[pulumi.Input[pulumi.InputType['ClusterSnapshotControllerArgs']]] = None,
                 ssh_accesses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ssh_key_name: Optional[pulumi.Input[str]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterSubnetArgs']]]]] = None,
                 sysctl_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tag_subnets: Optional[pulumi.Input[pulumi.InputType['ClusterTagSubnetsArgs']]] = None,
                 topology: Optional[pulumi.Input[pulumi.InputType['ClusterTopologyArgs']]] = None,
                 update_policy: Optional[pulumi.Input[str]] = None,
                 use_host_certificates: Optional[pulumi.Input[bool]] = None,
                 warm_pool: Optional[pulumi.Input[pulumi.InputType['ClusterWarmPoolArgs']]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ClusterArgs.__new__(ClusterArgs)

            __props__.__dict__["additional_network_cidrs"] = additional_network_cidrs
            __props__.__dict__["additional_policies"] = additional_policies
            __props__.__dict__["additional_sans"] = additional_sans
            __props__.__dict__["addons"] = addons
            __props__.__dict__["admin_ssh_key"] = admin_ssh_key
            __props__.__dict__["annotations"] = annotations
            __props__.__dict__["api"] = api
            __props__.__dict__["assets"] = assets
            __props__.__dict__["authentication"] = authentication
            __props__.__dict__["authorization"] = authorization
            __props__.__dict__["aws_load_balancer_controller"] = aws_load_balancer_controller
            __props__.__dict__["cert_manager"] = cert_manager
            __props__.__dict__["channel"] = channel
            __props__.__dict__["cloud_config"] = cloud_config
            __props__.__dict__["cloud_labels"] = cloud_labels
            if cloud_provider is None and not opts.urn:
                raise TypeError("Missing required property 'cloud_provider'")
            __props__.__dict__["cloud_provider"] = cloud_provider
            __props__.__dict__["cluster_autoscaler"] = cluster_autoscaler
            __props__.__dict__["cluster_dns_domain"] = cluster_dns_domain
            __props__.__dict__["config_base"] = config_base
            __props__.__dict__["config_store"] = config_store
            __props__.__dict__["container_runtime"] = container_runtime
            __props__.__dict__["containerd"] = containerd
            __props__.__dict__["dns_zone"] = dns_zone
            __props__.__dict__["docker"] = docker
            __props__.__dict__["egress_proxy"] = egress_proxy
            __props__.__dict__["encryption_config"] = encryption_config
            if etcd_clusters is None and not opts.urn:
                raise TypeError("Missing required property 'etcd_clusters'")
            __props__.__dict__["etcd_clusters"] = etcd_clusters
            __props__.__dict__["external_cloud_controller_manager"] = external_cloud_controller_manager
            __props__.__dict__["external_dns"] = external_dns
            __props__.__dict__["external_policies"] = external_policies
            __props__.__dict__["file_assets"] = file_assets
            __props__.__dict__["hooks"] = hooks
            __props__.__dict__["iam"] = iam
            __props__.__dict__["isolate_masters"] = isolate_masters
            __props__.__dict__["karpenter"] = karpenter
            __props__.__dict__["key_store"] = key_store
            __props__.__dict__["kube_api_server"] = kube_api_server
            __props__.__dict__["kube_controller_manager"] = kube_controller_manager
            __props__.__dict__["kube_dns"] = kube_dns
            __props__.__dict__["kube_proxy"] = kube_proxy
            __props__.__dict__["kube_scheduler"] = kube_scheduler
            __props__.__dict__["kubelet"] = kubelet
            __props__.__dict__["kubernetes_api_accesses"] = kubernetes_api_accesses
            __props__.__dict__["kubernetes_version"] = kubernetes_version
            __props__.__dict__["labels"] = labels
            __props__.__dict__["master_internal_name"] = master_internal_name
            __props__.__dict__["master_kubelet"] = master_kubelet
            __props__.__dict__["master_public_name"] = master_public_name
            __props__.__dict__["metrics_server"] = metrics_server
            __props__.__dict__["name"] = name
            __props__.__dict__["network_cidr"] = network_cidr
            if network_id is None and not opts.urn:
                raise TypeError("Missing required property 'network_id'")
            __props__.__dict__["network_id"] = network_id
            if networking is None and not opts.urn:
                raise TypeError("Missing required property 'networking'")
            __props__.__dict__["networking"] = networking
            __props__.__dict__["node_authorization"] = node_authorization
            __props__.__dict__["node_port_accesses"] = node_port_accesses
            __props__.__dict__["node_problem_detector"] = node_problem_detector
            __props__.__dict__["node_termination_handler"] = node_termination_handler
            __props__.__dict__["non_masquerade_cidr"] = non_masquerade_cidr
            __props__.__dict__["ntp"] = ntp
            __props__.__dict__["pod_cidr"] = pod_cidr
            __props__.__dict__["pod_identity_webhook"] = pod_identity_webhook
            __props__.__dict__["project"] = project
            __props__.__dict__["rolling_update"] = rolling_update
            __props__.__dict__["secret_store"] = secret_store
            __props__.__dict__["secrets"] = secrets
            __props__.__dict__["service_account_issuer_discovery"] = service_account_issuer_discovery
            __props__.__dict__["service_cluster_ip_range"] = service_cluster_ip_range
            __props__.__dict__["snapshot_controller"] = snapshot_controller
            __props__.__dict__["ssh_accesses"] = ssh_accesses
            __props__.__dict__["ssh_key_name"] = ssh_key_name
            if subnets is None and not opts.urn:
                raise TypeError("Missing required property 'subnets'")
            __props__.__dict__["subnets"] = subnets
            __props__.__dict__["sysctl_parameters"] = sysctl_parameters
            __props__.__dict__["tag_subnets"] = tag_subnets
            if topology is None and not opts.urn:
                raise TypeError("Missing required property 'topology'")
            __props__.__dict__["topology"] = topology
            __props__.__dict__["update_policy"] = update_policy
            __props__.__dict__["use_host_certificates"] = use_host_certificates
            __props__.__dict__["warm_pool"] = warm_pool
            __props__.__dict__["revision"] = None
        super(Cluster, __self__).__init__(
            'kops:index/cluster:Cluster',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            additional_network_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            additional_policies: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
            additional_sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            addons: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterAddonArgs']]]]] = None,
            admin_ssh_key: Optional[pulumi.Input[str]] = None,
            annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
            api: Optional[pulumi.Input[pulumi.InputType['ClusterApiArgs']]] = None,
            assets: Optional[pulumi.Input[pulumi.InputType['ClusterAssetsArgs']]] = None,
            authentication: Optional[pulumi.Input[pulumi.InputType['ClusterAuthenticationArgs']]] = None,
            authorization: Optional[pulumi.Input[pulumi.InputType['ClusterAuthorizationArgs']]] = None,
            aws_load_balancer_controller: Optional[pulumi.Input[pulumi.InputType['ClusterAwsLoadBalancerControllerArgs']]] = None,
            cert_manager: Optional[pulumi.Input[pulumi.InputType['ClusterCertManagerArgs']]] = None,
            channel: Optional[pulumi.Input[str]] = None,
            cloud_config: Optional[pulumi.Input[pulumi.InputType['ClusterCloudConfigArgs']]] = None,
            cloud_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
            cloud_provider: Optional[pulumi.Input[pulumi.InputType['ClusterCloudProviderArgs']]] = None,
            cluster_autoscaler: Optional[pulumi.Input[pulumi.InputType['ClusterClusterAutoscalerArgs']]] = None,
            cluster_dns_domain: Optional[pulumi.Input[str]] = None,
            config_base: Optional[pulumi.Input[str]] = None,
            config_store: Optional[pulumi.Input[str]] = None,
            container_runtime: Optional[pulumi.Input[str]] = None,
            containerd: Optional[pulumi.Input[pulumi.InputType['ClusterContainerdArgs']]] = None,
            dns_zone: Optional[pulumi.Input[str]] = None,
            docker: Optional[pulumi.Input[pulumi.InputType['ClusterDockerArgs']]] = None,
            egress_proxy: Optional[pulumi.Input[pulumi.InputType['ClusterEgressProxyArgs']]] = None,
            encryption_config: Optional[pulumi.Input[bool]] = None,
            etcd_clusters: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterEtcdClusterArgs']]]]] = None,
            external_cloud_controller_manager: Optional[pulumi.Input[pulumi.InputType['ClusterExternalCloudControllerManagerArgs']]] = None,
            external_dns: Optional[pulumi.Input[pulumi.InputType['ClusterExternalDnsArgs']]] = None,
            external_policies: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterExternalPolicyArgs']]]]] = None,
            file_assets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterFileAssetArgs']]]]] = None,
            hooks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterHookArgs']]]]] = None,
            iam: Optional[pulumi.Input[pulumi.InputType['ClusterIamArgs']]] = None,
            isolate_masters: Optional[pulumi.Input[bool]] = None,
            karpenter: Optional[pulumi.Input[pulumi.InputType['ClusterKarpenterArgs']]] = None,
            key_store: Optional[pulumi.Input[str]] = None,
            kube_api_server: Optional[pulumi.Input[pulumi.InputType['ClusterKubeApiServerArgs']]] = None,
            kube_controller_manager: Optional[pulumi.Input[pulumi.InputType['ClusterKubeControllerManagerArgs']]] = None,
            kube_dns: Optional[pulumi.Input[pulumi.InputType['ClusterKubeDnsArgs']]] = None,
            kube_proxy: Optional[pulumi.Input[pulumi.InputType['ClusterKubeProxyArgs']]] = None,
            kube_scheduler: Optional[pulumi.Input[pulumi.InputType['ClusterKubeSchedulerArgs']]] = None,
            kubelet: Optional[pulumi.Input[pulumi.InputType['ClusterKubeletArgs']]] = None,
            kubernetes_api_accesses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            kubernetes_version: Optional[pulumi.Input[str]] = None,
            labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
            master_internal_name: Optional[pulumi.Input[str]] = None,
            master_kubelet: Optional[pulumi.Input[pulumi.InputType['ClusterMasterKubeletArgs']]] = None,
            master_public_name: Optional[pulumi.Input[str]] = None,
            metrics_server: Optional[pulumi.Input[pulumi.InputType['ClusterMetricsServerArgs']]] = None,
            name: Optional[pulumi.Input[str]] = None,
            network_cidr: Optional[pulumi.Input[str]] = None,
            network_id: Optional[pulumi.Input[str]] = None,
            networking: Optional[pulumi.Input[pulumi.InputType['ClusterNetworkingArgs']]] = None,
            node_authorization: Optional[pulumi.Input[pulumi.InputType['ClusterNodeAuthorizationArgs']]] = None,
            node_port_accesses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            node_problem_detector: Optional[pulumi.Input[pulumi.InputType['ClusterNodeProblemDetectorArgs']]] = None,
            node_termination_handler: Optional[pulumi.Input[pulumi.InputType['ClusterNodeTerminationHandlerArgs']]] = None,
            non_masquerade_cidr: Optional[pulumi.Input[str]] = None,
            ntp: Optional[pulumi.Input[pulumi.InputType['ClusterNtpArgs']]] = None,
            pod_cidr: Optional[pulumi.Input[str]] = None,
            pod_identity_webhook: Optional[pulumi.Input[pulumi.InputType['ClusterPodIdentityWebhookArgs']]] = None,
            project: Optional[pulumi.Input[str]] = None,
            revision: Optional[pulumi.Input[int]] = None,
            rolling_update: Optional[pulumi.Input[pulumi.InputType['ClusterRollingUpdateArgs']]] = None,
            secret_store: Optional[pulumi.Input[str]] = None,
            secrets: Optional[pulumi.Input[pulumi.InputType['ClusterSecretsArgs']]] = None,
            service_account_issuer_discovery: Optional[pulumi.Input[pulumi.InputType['ClusterServiceAccountIssuerDiscoveryArgs']]] = None,
            service_cluster_ip_range: Optional[pulumi.Input[str]] = None,
            snapshot_controller: Optional[pulumi.Input[pulumi.InputType['ClusterSnapshotControllerArgs']]] = None,
            ssh_accesses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            ssh_key_name: Optional[pulumi.Input[str]] = None,
            subnets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterSubnetArgs']]]]] = None,
            sysctl_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            tag_subnets: Optional[pulumi.Input[pulumi.InputType['ClusterTagSubnetsArgs']]] = None,
            topology: Optional[pulumi.Input[pulumi.InputType['ClusterTopologyArgs']]] = None,
            update_policy: Optional[pulumi.Input[str]] = None,
            use_host_certificates: Optional[pulumi.Input[bool]] = None,
            warm_pool: Optional[pulumi.Input[pulumi.InputType['ClusterWarmPoolArgs']]] = None) -> 'Cluster':
        """
        Get an existing Cluster resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_network_cidrs: - List(String) - AdditionalNetworkCIDRs is a list of additional CIDR used for the AWS VPC<br />or otherwise allocated to k8s. This is a real CIDR, not the internal k8s network<br />On AWS, it maps to any additional CIDRs added to a VPC.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] additional_policies: - Map(String) - Additional policies to add for roles.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_sans: - List(String) - AdditionalSANs adds additional Subject Alternate Names to apiserver cert that kops generates.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterAddonArgs']]]] addons: - List(addon_spec) - Additional addons that should be installed on the cluster.
        :param pulumi.Input[str] admin_ssh_key: - (Sensitive) - String - AdminSshKey defines the cluster admin ssh key.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: - Map(String) - Annotations is an unstructured key value map stored with a resource that may be<br />set by external tools to store and retrieve arbitrary metadata. They are not<br />queryable and should be preserved when modifying objects.
        :param pulumi.Input[pulumi.InputType['ClusterApiArgs']] api: - access_spec - API field controls how the API is exposed outside the cluster.
        :param pulumi.Input[pulumi.InputType['ClusterAssetsArgs']] assets: - assets - Assets is alternative locations for files and containers; the API under construction, will remove this comment once this API is fully functional.
        :param pulumi.Input[pulumi.InputType['ClusterAuthenticationArgs']] authentication: - authentication_spec - Authentication field controls how the cluster is configured for authentication.
        :param pulumi.Input[pulumi.InputType['ClusterAuthorizationArgs']] authorization: - authorization_spec - Authorization field controls how the cluster is configured for authorization.
        :param pulumi.Input[pulumi.InputType['ClusterAwsLoadBalancerControllerArgs']] aws_load_balancer_controller: - aws_load_balancer_controller_config - AWSLoadbalancerControllerConfig determines the AWS LB controller configuration.
        :param pulumi.Input[pulumi.InputType['ClusterCertManagerArgs']] cert_manager: - cert_manager_config - CertManager determines the metrics server configuration.
        :param pulumi.Input[str] channel: - String - The Channel we are following.
        :param pulumi.Input[pulumi.InputType['ClusterCloudConfigArgs']] cloud_config: - cloud_configuration
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] cloud_labels: - Map(String) - CloudLabels defines additional tags or labels on cloud provider resources.
        :param pulumi.Input[pulumi.InputType['ClusterCloudProviderArgs']] cloud_provider: - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        :param pulumi.Input[pulumi.InputType['ClusterClusterAutoscalerArgs']] cluster_autoscaler: - cluster_autoscaler_config - ClusterAutoscaler defines the cluster autoscaler configuration.
        :param pulumi.Input[str] cluster_dns_domain: - String - ClusterDNSDomain is the suffix we use for internal DNS names (normally cluster.local).
        :param pulumi.Input[str] config_base: - (Computed) - String - ConfigBase is the path where we store configuration for the cluster<br />This might be different than the location where the cluster spec itself is stored,<br />both because this must be accessible to the cluster,<br />and because it might be on a different cloud or storage system (etcd vs S3).
        :param pulumi.Input[str] config_store: - String - ConfigStore is the VFS path to where the configuration (Cluster, InstanceGroups etc) is stored.
        :param pulumi.Input[str] container_runtime: - String - Container runtime to use for Kubernetes.
        :param pulumi.Input[pulumi.InputType['ClusterContainerdArgs']] containerd: - containerd_config - Component configurations.
        :param pulumi.Input[str] dns_zone: - String - DNSZone is the DNS zone we should use when configuring DNS<br />This is because some clouds let us define a managed zone foo.bar, and then have<br />kubernetes.dev.foo.bar, without needing to define dev.foo.bar as a hosted zone.<br />DNSZone will probably be a suffix of the MasterPublicName and MasterInternalName<br />Note that DNSZone can either by the host name of the zone (containing dots),<br />or can be an identifier for the zone.
        :param pulumi.Input[pulumi.InputType['ClusterDockerArgs']] docker: - docker_config
        :param pulumi.Input[pulumi.InputType['ClusterEgressProxyArgs']] egress_proxy: - egress_proxy_spec - HTTPProxy defines connection information to support use of a private cluster behind an forward HTTP Proxy.
        :param pulumi.Input[bool] encryption_config: - Bool - EncryptionConfig controls if encryption is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterEtcdClusterArgs']]]] etcd_clusters: - List(etcd_cluster_spec) - EtcdClusters stores the configuration for each cluster.
        :param pulumi.Input[pulumi.InputType['ClusterExternalCloudControllerManagerArgs']] external_cloud_controller_manager: - cloud_controller_manager_config
        :param pulumi.Input[pulumi.InputType['ClusterExternalDnsArgs']] external_dns: - external_dns_config
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterExternalPolicyArgs']]]] external_policies: - Map(List(String)) - ExternalPolicies allows the insertion of pre-existing managed policies on IG Roles.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterFileAssetArgs']]]] file_assets: - List(file_asset_spec) - A collection of files assets for deployed cluster wide.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterHookArgs']]]] hooks: - List(hook_spec) - Hooks for custom actions e.g. on first installation.
        :param pulumi.Input[pulumi.InputType['ClusterIamArgs']] iam: - (Computed) - iam_spec - IAM field adds control over the IAM security policies applied to resources.
        :param pulumi.Input[bool] isolate_masters: - Bool - IsolateMasters determines whether we should lock down masters so that they are not on the pod network.<br />true is the kube-up behaviour, but it is very surprising: it means that daemonsets only work on the master<br />if they have hostNetwork=true.<br />false is now the default, and it will:<br /> * give the master a normal PodCIDR<br /> * run kube-proxy on the master<br /> * enable debugging handlers on the master, so kubectl logs works.
        :param pulumi.Input[pulumi.InputType['ClusterKarpenterArgs']] karpenter: - karpenter_config - Karpenter defines the Karpenter configuration.
        :param pulumi.Input[str] key_store: - String - KeyStore is the VFS path to where SSL keys and certificates are stored.
        :param pulumi.Input[pulumi.InputType['ClusterKubeApiServerArgs']] kube_api_server: - kube_api_server_config
        :param pulumi.Input[pulumi.InputType['ClusterKubeControllerManagerArgs']] kube_controller_manager: - kube_controller_manager_config
        :param pulumi.Input[pulumi.InputType['ClusterKubeDnsArgs']] kube_dns: - kube_dns_config
        :param pulumi.Input[pulumi.InputType['ClusterKubeProxyArgs']] kube_proxy: - kube_proxy_config
        :param pulumi.Input[pulumi.InputType['ClusterKubeSchedulerArgs']] kube_scheduler: - kube_scheduler_config
        :param pulumi.Input[pulumi.InputType['ClusterKubeletArgs']] kubelet: - kubelet_config_spec - Kubelet is the kubelet configuration for nodes not belonging to the control plane.<br />It can be overridden by the kubelet configuration specified in the instance group.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] kubernetes_api_accesses: - List(String) - KubernetesAPIAccess is a list of the CIDRs that can access the Kubernetes API endpoint (master HTTPS).
        :param pulumi.Input[str] kubernetes_version: - String - The version of kubernetes to install (optional, and can be a "spec" like stable).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: - Map(String) - Map of string keys and values that can be used to organize and categorize<br />(scope and select) objects. May match selectors of replication controllers<br />and services.
        :param pulumi.Input[str] master_internal_name: - (Computed) - String - MasterInternalName is the internal DNS name for the master nodes.
        :param pulumi.Input[pulumi.InputType['ClusterMasterKubeletArgs']] master_kubelet: - kubelet_config_spec - MasterKubelet is the kubelet configuration for nodes belonging to the control plane<br />It can be overridden by the kubelet configuration specified in the instance group.
        :param pulumi.Input[str] master_public_name: - (Computed) - String - MasterPublicName is the external DNS name for the master nodes.
        :param pulumi.Input[pulumi.InputType['ClusterMetricsServerArgs']] metrics_server: - metrics_server_config - MetricsServer determines the metrics server configuration.
        :param pulumi.Input[str] name: - (Force new) - String - Name defines the cluster name.
        :param pulumi.Input[str] network_cidr: - (Computed) - String - NetworkCIDR is the CIDR used for the AWS VPC / DO/ GCE Network, or otherwise allocated to k8s<br />This is a real CIDR, not the internal k8s network<br />On AWS, it maps to the VPC CIDR.  It is not required on GCE.<br />On DO, it maps to the VPC CIDR.
        :param pulumi.Input[str] network_id: - String - NetworkID is an identifier of a network, if we want to reuse/share an existing network (e.g. an AWS VPC).
        :param pulumi.Input[pulumi.InputType['ClusterNetworkingArgs']] networking: - networking_spec - Networking configuration.
        :param pulumi.Input[pulumi.InputType['ClusterNodeAuthorizationArgs']] node_authorization: - node_authorization_spec - NodeAuthorization defined the custom node authorization configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] node_port_accesses: - List(String) - NodePortAccess is a list of the CIDRs that can access the node ports range (30000-32767).
        :param pulumi.Input[pulumi.InputType['ClusterNodeProblemDetectorArgs']] node_problem_detector: - node_problem_detector_config - NodeProblemDetector determines the node problem detector configuration.
        :param pulumi.Input[pulumi.InputType['ClusterNodeTerminationHandlerArgs']] node_termination_handler: - node_termination_handler_config - NodeTerminationHandler determines the node termination handler configuration.
        :param pulumi.Input[str] non_masquerade_cidr: - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
        :param pulumi.Input[pulumi.InputType['ClusterNtpArgs']] ntp: - ntp_config
        :param pulumi.Input[str] pod_cidr: - String - PodCIDR is the CIDR from which we allocate IPs for pods.
        :param pulumi.Input[pulumi.InputType['ClusterPodIdentityWebhookArgs']] pod_identity_webhook: - pod_identity_webhook_config - PodIdentityWebhook determines the EKS Pod Identity Webhook configuration.
        :param pulumi.Input[str] project: - String - Project is the cloud project we should use, required on GCE.
        :param pulumi.Input[int] revision: - Int - Revision is incremented every time the resource changes, this is useful for triggering cluster updater.
        :param pulumi.Input[pulumi.InputType['ClusterRollingUpdateArgs']] rolling_update: - rolling_update - RollingUpdate defines the default rolling-update settings for instance groups.
        :param pulumi.Input[str] secret_store: - String - SecretStore is the VFS path to where secrets are stored.
        :param pulumi.Input[pulumi.InputType['ClusterSecretsArgs']] secrets: - cluster_secrets - Secrets defines the cluster secret.
        :param pulumi.Input[pulumi.InputType['ClusterServiceAccountIssuerDiscoveryArgs']] service_account_issuer_discovery: - service_account_issuer_discovery_config - ServiceAccountIssuerDiscovery configures the OIDC Issuer for ServiceAccounts.
        :param pulumi.Input[str] service_cluster_ip_range: - String - ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services.
        :param pulumi.Input[pulumi.InputType['ClusterSnapshotControllerArgs']] snapshot_controller: - snapshot_controller_config - SnapshotController defines the CSI Snapshot Controller configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ssh_accesses: - List(String) - SSHAccess is a list of the CIDRs that can access SSH.
        :param pulumi.Input[str] ssh_key_name: - String - SSHKeyName specifies a preexisting SSH key to use.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ClusterSubnetArgs']]]] subnets: - List(cluster_subnet_spec) - Configuration of subnets we are targeting.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sysctl_parameters: - List(String) - SysctlParameters will configure kernel parameters using sysctl(8). When<br />specified, each parameter must follow the form variable=value, the way<br />it would appear in sysctl.conf.
        :param pulumi.Input[pulumi.InputType['ClusterTagSubnetsArgs']] tag_subnets: - Bool(Nullable) - TagSubnets controls if tags are added to subnets to enable use by load balancers (AWS only). Default: true.
        :param pulumi.Input[pulumi.InputType['ClusterTopologyArgs']] topology: - topology_spec - Topology defines the type of network topology to use on the cluster - default public<br />This is heavily weighted towards AWS for the time being, but should also be agnostic enough<br />to port out to GCE later if needed.
        :param pulumi.Input[str] update_policy: - String - UpdatePolicy determines the policy for applying upgrades automatically.<br />Valid values:<br />  'automatic' (default): apply updates automatically (apply OS security upgrades, avoiding rebooting when possible)<br />  'external': do not apply updates automatically; they are applied manually or by an external system.
        :param pulumi.Input[bool] use_host_certificates: - Bool - UseHostCertificates will mount /etc/ssl/certs to inside needed containers.<br />This is needed if some APIs do have self-signed certs.
        :param pulumi.Input[pulumi.InputType['ClusterWarmPoolArgs']] warm_pool: - warm_pool_spec - WarmPool defines the default warm pool settings for instance groups (AWS only).
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _ClusterState.__new__(_ClusterState)

        __props__.__dict__["additional_network_cidrs"] = additional_network_cidrs
        __props__.__dict__["additional_policies"] = additional_policies
        __props__.__dict__["additional_sans"] = additional_sans
        __props__.__dict__["addons"] = addons
        __props__.__dict__["admin_ssh_key"] = admin_ssh_key
        __props__.__dict__["annotations"] = annotations
        __props__.__dict__["api"] = api
        __props__.__dict__["assets"] = assets
        __props__.__dict__["authentication"] = authentication
        __props__.__dict__["authorization"] = authorization
        __props__.__dict__["aws_load_balancer_controller"] = aws_load_balancer_controller
        __props__.__dict__["cert_manager"] = cert_manager
        __props__.__dict__["channel"] = channel
        __props__.__dict__["cloud_config"] = cloud_config
        __props__.__dict__["cloud_labels"] = cloud_labels
        __props__.__dict__["cloud_provider"] = cloud_provider
        __props__.__dict__["cluster_autoscaler"] = cluster_autoscaler
        __props__.__dict__["cluster_dns_domain"] = cluster_dns_domain
        __props__.__dict__["config_base"] = config_base
        __props__.__dict__["config_store"] = config_store
        __props__.__dict__["container_runtime"] = container_runtime
        __props__.__dict__["containerd"] = containerd
        __props__.__dict__["dns_zone"] = dns_zone
        __props__.__dict__["docker"] = docker
        __props__.__dict__["egress_proxy"] = egress_proxy
        __props__.__dict__["encryption_config"] = encryption_config
        __props__.__dict__["etcd_clusters"] = etcd_clusters
        __props__.__dict__["external_cloud_controller_manager"] = external_cloud_controller_manager
        __props__.__dict__["external_dns"] = external_dns
        __props__.__dict__["external_policies"] = external_policies
        __props__.__dict__["file_assets"] = file_assets
        __props__.__dict__["hooks"] = hooks
        __props__.__dict__["iam"] = iam
        __props__.__dict__["isolate_masters"] = isolate_masters
        __props__.__dict__["karpenter"] = karpenter
        __props__.__dict__["key_store"] = key_store
        __props__.__dict__["kube_api_server"] = kube_api_server
        __props__.__dict__["kube_controller_manager"] = kube_controller_manager
        __props__.__dict__["kube_dns"] = kube_dns
        __props__.__dict__["kube_proxy"] = kube_proxy
        __props__.__dict__["kube_scheduler"] = kube_scheduler
        __props__.__dict__["kubelet"] = kubelet
        __props__.__dict__["kubernetes_api_accesses"] = kubernetes_api_accesses
        __props__.__dict__["kubernetes_version"] = kubernetes_version
        __props__.__dict__["labels"] = labels
        __props__.__dict__["master_internal_name"] = master_internal_name
        __props__.__dict__["master_kubelet"] = master_kubelet
        __props__.__dict__["master_public_name"] = master_public_name
        __props__.__dict__["metrics_server"] = metrics_server
        __props__.__dict__["name"] = name
        __props__.__dict__["network_cidr"] = network_cidr
        __props__.__dict__["network_id"] = network_id
        __props__.__dict__["networking"] = networking
        __props__.__dict__["node_authorization"] = node_authorization
        __props__.__dict__["node_port_accesses"] = node_port_accesses
        __props__.__dict__["node_problem_detector"] = node_problem_detector
        __props__.__dict__["node_termination_handler"] = node_termination_handler
        __props__.__dict__["non_masquerade_cidr"] = non_masquerade_cidr
        __props__.__dict__["ntp"] = ntp
        __props__.__dict__["pod_cidr"] = pod_cidr
        __props__.__dict__["pod_identity_webhook"] = pod_identity_webhook
        __props__.__dict__["project"] = project
        __props__.__dict__["revision"] = revision
        __props__.__dict__["rolling_update"] = rolling_update
        __props__.__dict__["secret_store"] = secret_store
        __props__.__dict__["secrets"] = secrets
        __props__.__dict__["service_account_issuer_discovery"] = service_account_issuer_discovery
        __props__.__dict__["service_cluster_ip_range"] = service_cluster_ip_range
        __props__.__dict__["snapshot_controller"] = snapshot_controller
        __props__.__dict__["ssh_accesses"] = ssh_accesses
        __props__.__dict__["ssh_key_name"] = ssh_key_name
        __props__.__dict__["subnets"] = subnets
        __props__.__dict__["sysctl_parameters"] = sysctl_parameters
        __props__.__dict__["tag_subnets"] = tag_subnets
        __props__.__dict__["topology"] = topology
        __props__.__dict__["update_policy"] = update_policy
        __props__.__dict__["use_host_certificates"] = use_host_certificates
        __props__.__dict__["warm_pool"] = warm_pool
        return Cluster(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="additionalNetworkCidrs")
    def additional_network_cidrs(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        - List(String) - AdditionalNetworkCIDRs is a list of additional CIDR used for the AWS VPC<br />or otherwise allocated to k8s. This is a real CIDR, not the internal k8s network<br />On AWS, it maps to any additional CIDRs added to a VPC.
        """
        return pulumi.get(self, "additional_network_cidrs")

    @property
    @pulumi.getter(name="additionalPolicies")
    def additional_policies(self) -> pulumi.Output[Optional[Mapping[str, str]]]:
        """
        - Map(String) - Additional policies to add for roles.
        """
        return pulumi.get(self, "additional_policies")

    @property
    @pulumi.getter(name="additionalSans")
    def additional_sans(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        - List(String) - AdditionalSANs adds additional Subject Alternate Names to apiserver cert that kops generates.
        """
        return pulumi.get(self, "additional_sans")

    @property
    @pulumi.getter
    def addons(self) -> pulumi.Output[Optional[Sequence['outputs.ClusterAddon']]]:
        """
        - List(addon_spec) - Additional addons that should be installed on the cluster.
        """
        return pulumi.get(self, "addons")

    @property
    @pulumi.getter(name="adminSshKey")
    def admin_ssh_key(self) -> pulumi.Output[Optional[str]]:
        """
        - (Sensitive) - String - AdminSshKey defines the cluster admin ssh key.
        """
        return pulumi.get(self, "admin_ssh_key")

    @property
    @pulumi.getter
    def annotations(self) -> pulumi.Output[Optional[Mapping[str, str]]]:
        """
        - Map(String) - Annotations is an unstructured key value map stored with a resource that may be<br />set by external tools to store and retrieve arbitrary metadata. They are not<br />queryable and should be preserved when modifying objects.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def api(self) -> pulumi.Output[Optional['outputs.ClusterApi']]:
        """
        - access_spec - API field controls how the API is exposed outside the cluster.
        """
        return pulumi.get(self, "api")

    @property
    @pulumi.getter
    def assets(self) -> pulumi.Output[Optional['outputs.ClusterAssets']]:
        """
        - assets - Assets is alternative locations for files and containers; the API under construction, will remove this comment once this API is fully functional.
        """
        return pulumi.get(self, "assets")

    @property
    @pulumi.getter
    def authentication(self) -> pulumi.Output[Optional['outputs.ClusterAuthentication']]:
        """
        - authentication_spec - Authentication field controls how the cluster is configured for authentication.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def authorization(self) -> pulumi.Output[Optional['outputs.ClusterAuthorization']]:
        """
        - authorization_spec - Authorization field controls how the cluster is configured for authorization.
        """
        return pulumi.get(self, "authorization")

    @property
    @pulumi.getter(name="awsLoadBalancerController")
    def aws_load_balancer_controller(self) -> pulumi.Output[Optional['outputs.ClusterAwsLoadBalancerController']]:
        """
        - aws_load_balancer_controller_config - AWSLoadbalancerControllerConfig determines the AWS LB controller configuration.
        """
        return pulumi.get(self, "aws_load_balancer_controller")

    @property
    @pulumi.getter(name="certManager")
    def cert_manager(self) -> pulumi.Output[Optional['outputs.ClusterCertManager']]:
        """
        - cert_manager_config - CertManager determines the metrics server configuration.
        """
        return pulumi.get(self, "cert_manager")

    @property
    @pulumi.getter
    def channel(self) -> pulumi.Output[Optional[str]]:
        """
        - String - The Channel we are following.
        """
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter(name="cloudConfig")
    def cloud_config(self) -> pulumi.Output[Optional['outputs.ClusterCloudConfig']]:
        """
        - cloud_configuration
        """
        return pulumi.get(self, "cloud_config")

    @property
    @pulumi.getter(name="cloudLabels")
    def cloud_labels(self) -> pulumi.Output[Optional[Mapping[str, str]]]:
        """
        - Map(String) - CloudLabels defines additional tags or labels on cloud provider resources.
        """
        return pulumi.get(self, "cloud_labels")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> pulumi.Output['outputs.ClusterCloudProvider']:
        """
        - cloud_provider_spec - CloudProvider configures the cloud provider to use.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="clusterAutoscaler")
    def cluster_autoscaler(self) -> pulumi.Output[Optional['outputs.ClusterClusterAutoscaler']]:
        """
        - cluster_autoscaler_config - ClusterAutoscaler defines the cluster autoscaler configuration.
        """
        return pulumi.get(self, "cluster_autoscaler")

    @property
    @pulumi.getter(name="clusterDnsDomain")
    def cluster_dns_domain(self) -> pulumi.Output[Optional[str]]:
        """
        - String - ClusterDNSDomain is the suffix we use for internal DNS names (normally cluster.local).
        """
        return pulumi.get(self, "cluster_dns_domain")

    @property
    @pulumi.getter(name="configBase")
    def config_base(self) -> pulumi.Output[str]:
        """
        - (Computed) - String - ConfigBase is the path where we store configuration for the cluster<br />This might be different than the location where the cluster spec itself is stored,<br />both because this must be accessible to the cluster,<br />and because it might be on a different cloud or storage system (etcd vs S3).
        """
        return pulumi.get(self, "config_base")

    @property
    @pulumi.getter(name="configStore")
    def config_store(self) -> pulumi.Output[Optional[str]]:
        """
        - String - ConfigStore is the VFS path to where the configuration (Cluster, InstanceGroups etc) is stored.
        """
        return pulumi.get(self, "config_store")

    @property
    @pulumi.getter(name="containerRuntime")
    def container_runtime(self) -> pulumi.Output[Optional[str]]:
        """
        - String - Container runtime to use for Kubernetes.
        """
        return pulumi.get(self, "container_runtime")

    @property
    @pulumi.getter
    def containerd(self) -> pulumi.Output[Optional['outputs.ClusterContainerd']]:
        """
        - containerd_config - Component configurations.
        """
        return pulumi.get(self, "containerd")

    @property
    @pulumi.getter(name="dnsZone")
    def dns_zone(self) -> pulumi.Output[Optional[str]]:
        """
        - String - DNSZone is the DNS zone we should use when configuring DNS<br />This is because some clouds let us define a managed zone foo.bar, and then have<br />kubernetes.dev.foo.bar, without needing to define dev.foo.bar as a hosted zone.<br />DNSZone will probably be a suffix of the MasterPublicName and MasterInternalName<br />Note that DNSZone can either by the host name of the zone (containing dots),<br />or can be an identifier for the zone.
        """
        return pulumi.get(self, "dns_zone")

    @property
    @pulumi.getter
    def docker(self) -> pulumi.Output[Optional['outputs.ClusterDocker']]:
        """
        - docker_config
        """
        return pulumi.get(self, "docker")

    @property
    @pulumi.getter(name="egressProxy")
    def egress_proxy(self) -> pulumi.Output[Optional['outputs.ClusterEgressProxy']]:
        """
        - egress_proxy_spec - HTTPProxy defines connection information to support use of a private cluster behind an forward HTTP Proxy.
        """
        return pulumi.get(self, "egress_proxy")

    @property
    @pulumi.getter(name="encryptionConfig")
    def encryption_config(self) -> pulumi.Output[Optional[bool]]:
        """
        - Bool - EncryptionConfig controls if encryption is enabled.
        """
        return pulumi.get(self, "encryption_config")

    @property
    @pulumi.getter(name="etcdClusters")
    def etcd_clusters(self) -> pulumi.Output[Sequence['outputs.ClusterEtcdCluster']]:
        """
        - List(etcd_cluster_spec) - EtcdClusters stores the configuration for each cluster.
        """
        return pulumi.get(self, "etcd_clusters")

    @property
    @pulumi.getter(name="externalCloudControllerManager")
    def external_cloud_controller_manager(self) -> pulumi.Output[Optional['outputs.ClusterExternalCloudControllerManager']]:
        """
        - cloud_controller_manager_config
        """
        return pulumi.get(self, "external_cloud_controller_manager")

    @property
    @pulumi.getter(name="externalDns")
    def external_dns(self) -> pulumi.Output[Optional['outputs.ClusterExternalDns']]:
        """
        - external_dns_config
        """
        return pulumi.get(self, "external_dns")

    @property
    @pulumi.getter(name="externalPolicies")
    def external_policies(self) -> pulumi.Output[Optional[Sequence['outputs.ClusterExternalPolicy']]]:
        """
        - Map(List(String)) - ExternalPolicies allows the insertion of pre-existing managed policies on IG Roles.
        """
        return pulumi.get(self, "external_policies")

    @property
    @pulumi.getter(name="fileAssets")
    def file_assets(self) -> pulumi.Output[Optional[Sequence['outputs.ClusterFileAsset']]]:
        """
        - List(file_asset_spec) - A collection of files assets for deployed cluster wide.
        """
        return pulumi.get(self, "file_assets")

    @property
    @pulumi.getter
    def hooks(self) -> pulumi.Output[Optional[Sequence['outputs.ClusterHook']]]:
        """
        - List(hook_spec) - Hooks for custom actions e.g. on first installation.
        """
        return pulumi.get(self, "hooks")

    @property
    @pulumi.getter
    def iam(self) -> pulumi.Output['outputs.ClusterIam']:
        """
        - (Computed) - iam_spec - IAM field adds control over the IAM security policies applied to resources.
        """
        return pulumi.get(self, "iam")

    @property
    @pulumi.getter(name="isolateMasters")
    def isolate_masters(self) -> pulumi.Output[Optional[bool]]:
        """
        - Bool - IsolateMasters determines whether we should lock down masters so that they are not on the pod network.<br />true is the kube-up behaviour, but it is very surprising: it means that daemonsets only work on the master<br />if they have hostNetwork=true.<br />false is now the default, and it will:<br /> * give the master a normal PodCIDR<br /> * run kube-proxy on the master<br /> * enable debugging handlers on the master, so kubectl logs works.
        """
        return pulumi.get(self, "isolate_masters")

    @property
    @pulumi.getter
    def karpenter(self) -> pulumi.Output[Optional['outputs.ClusterKarpenter']]:
        """
        - karpenter_config - Karpenter defines the Karpenter configuration.
        """
        return pulumi.get(self, "karpenter")

    @property
    @pulumi.getter(name="keyStore")
    def key_store(self) -> pulumi.Output[Optional[str]]:
        """
        - String - KeyStore is the VFS path to where SSL keys and certificates are stored.
        """
        return pulumi.get(self, "key_store")

    @property
    @pulumi.getter(name="kubeApiServer")
    def kube_api_server(self) -> pulumi.Output[Optional['outputs.ClusterKubeApiServer']]:
        """
        - kube_api_server_config
        """
        return pulumi.get(self, "kube_api_server")

    @property
    @pulumi.getter(name="kubeControllerManager")
    def kube_controller_manager(self) -> pulumi.Output[Optional['outputs.ClusterKubeControllerManager']]:
        """
        - kube_controller_manager_config
        """
        return pulumi.get(self, "kube_controller_manager")

    @property
    @pulumi.getter(name="kubeDns")
    def kube_dns(self) -> pulumi.Output[Optional['outputs.ClusterKubeDns']]:
        """
        - kube_dns_config
        """
        return pulumi.get(self, "kube_dns")

    @property
    @pulumi.getter(name="kubeProxy")
    def kube_proxy(self) -> pulumi.Output[Optional['outputs.ClusterKubeProxy']]:
        """
        - kube_proxy_config
        """
        return pulumi.get(self, "kube_proxy")

    @property
    @pulumi.getter(name="kubeScheduler")
    def kube_scheduler(self) -> pulumi.Output[Optional['outputs.ClusterKubeScheduler']]:
        """
        - kube_scheduler_config
        """
        return pulumi.get(self, "kube_scheduler")

    @property
    @pulumi.getter
    def kubelet(self) -> pulumi.Output[Optional['outputs.ClusterKubelet']]:
        """
        - kubelet_config_spec - Kubelet is the kubelet configuration for nodes not belonging to the control plane.<br />It can be overridden by the kubelet configuration specified in the instance group.
        """
        return pulumi.get(self, "kubelet")

    @property
    @pulumi.getter(name="kubernetesApiAccesses")
    def kubernetes_api_accesses(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        - List(String) - KubernetesAPIAccess is a list of the CIDRs that can access the Kubernetes API endpoint (master HTTPS).
        """
        return pulumi.get(self, "kubernetes_api_accesses")

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> pulumi.Output[Optional[str]]:
        """
        - String - The version of kubernetes to install (optional, and can be a "spec" like stable).
        """
        return pulumi.get(self, "kubernetes_version")

    @property
    @pulumi.getter
    def labels(self) -> pulumi.Output[Optional[Mapping[str, str]]]:
        """
        - Map(String) - Map of string keys and values that can be used to organize and categorize<br />(scope and select) objects. May match selectors of replication controllers<br />and services.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="masterInternalName")
    def master_internal_name(self) -> pulumi.Output[str]:
        """
        - (Computed) - String - MasterInternalName is the internal DNS name for the master nodes.
        """
        return pulumi.get(self, "master_internal_name")

    @property
    @pulumi.getter(name="masterKubelet")
    def master_kubelet(self) -> pulumi.Output[Optional['outputs.ClusterMasterKubelet']]:
        """
        - kubelet_config_spec - MasterKubelet is the kubelet configuration for nodes belonging to the control plane<br />It can be overridden by the kubelet configuration specified in the instance group.
        """
        return pulumi.get(self, "master_kubelet")

    @property
    @pulumi.getter(name="masterPublicName")
    def master_public_name(self) -> pulumi.Output[str]:
        """
        - (Computed) - String - MasterPublicName is the external DNS name for the master nodes.
        """
        return pulumi.get(self, "master_public_name")

    @property
    @pulumi.getter(name="metricsServer")
    def metrics_server(self) -> pulumi.Output[Optional['outputs.ClusterMetricsServer']]:
        """
        - metrics_server_config - MetricsServer determines the metrics server configuration.
        """
        return pulumi.get(self, "metrics_server")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        - (Force new) - String - Name defines the cluster name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkCidr")
    def network_cidr(self) -> pulumi.Output[str]:
        """
        - (Computed) - String - NetworkCIDR is the CIDR used for the AWS VPC / DO/ GCE Network, or otherwise allocated to k8s<br />This is a real CIDR, not the internal k8s network<br />On AWS, it maps to the VPC CIDR.  It is not required on GCE.<br />On DO, it maps to the VPC CIDR.
        """
        return pulumi.get(self, "network_cidr")

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> pulumi.Output[str]:
        """
        - String - NetworkID is an identifier of a network, if we want to reuse/share an existing network (e.g. an AWS VPC).
        """
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter
    def networking(self) -> pulumi.Output['outputs.ClusterNetworking']:
        """
        - networking_spec - Networking configuration.
        """
        return pulumi.get(self, "networking")

    @property
    @pulumi.getter(name="nodeAuthorization")
    def node_authorization(self) -> pulumi.Output[Optional['outputs.ClusterNodeAuthorization']]:
        """
        - node_authorization_spec - NodeAuthorization defined the custom node authorization configuration.
        """
        return pulumi.get(self, "node_authorization")

    @property
    @pulumi.getter(name="nodePortAccesses")
    def node_port_accesses(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        - List(String) - NodePortAccess is a list of the CIDRs that can access the node ports range (30000-32767).
        """
        return pulumi.get(self, "node_port_accesses")

    @property
    @pulumi.getter(name="nodeProblemDetector")
    def node_problem_detector(self) -> pulumi.Output[Optional['outputs.ClusterNodeProblemDetector']]:
        """
        - node_problem_detector_config - NodeProblemDetector determines the node problem detector configuration.
        """
        return pulumi.get(self, "node_problem_detector")

    @property
    @pulumi.getter(name="nodeTerminationHandler")
    def node_termination_handler(self) -> pulumi.Output[Optional['outputs.ClusterNodeTerminationHandler']]:
        """
        - node_termination_handler_config - NodeTerminationHandler determines the node termination handler configuration.
        """
        return pulumi.get(self, "node_termination_handler")

    @property
    @pulumi.getter(name="nonMasqueradeCidr")
    def non_masquerade_cidr(self) -> pulumi.Output[str]:
        """
        - (Computed) - String - NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live)<br />It cannot overlap ServiceClusterIPRange.
        """
        return pulumi.get(self, "non_masquerade_cidr")

    @property
    @pulumi.getter
    def ntp(self) -> pulumi.Output[Optional['outputs.ClusterNtp']]:
        """
        - ntp_config
        """
        return pulumi.get(self, "ntp")

    @property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> pulumi.Output[Optional[str]]:
        """
        - String - PodCIDR is the CIDR from which we allocate IPs for pods.
        """
        return pulumi.get(self, "pod_cidr")

    @property
    @pulumi.getter(name="podIdentityWebhook")
    def pod_identity_webhook(self) -> pulumi.Output[Optional['outputs.ClusterPodIdentityWebhook']]:
        """
        - pod_identity_webhook_config - PodIdentityWebhook determines the EKS Pod Identity Webhook configuration.
        """
        return pulumi.get(self, "pod_identity_webhook")

    @property
    @pulumi.getter
    def project(self) -> pulumi.Output[Optional[str]]:
        """
        - String - Project is the cloud project we should use, required on GCE.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter
    def revision(self) -> pulumi.Output[int]:
        """
        - Int - Revision is incremented every time the resource changes, this is useful for triggering cluster updater.
        """
        return pulumi.get(self, "revision")

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> pulumi.Output[Optional['outputs.ClusterRollingUpdate']]:
        """
        - rolling_update - RollingUpdate defines the default rolling-update settings for instance groups.
        """
        return pulumi.get(self, "rolling_update")

    @property
    @pulumi.getter(name="secretStore")
    def secret_store(self) -> pulumi.Output[Optional[str]]:
        """
        - String - SecretStore is the VFS path to where secrets are stored.
        """
        return pulumi.get(self, "secret_store")

    @property
    @pulumi.getter
    def secrets(self) -> pulumi.Output[Optional['outputs.ClusterSecrets']]:
        """
        - cluster_secrets - Secrets defines the cluster secret.
        """
        return pulumi.get(self, "secrets")

    @property
    @pulumi.getter(name="serviceAccountIssuerDiscovery")
    def service_account_issuer_discovery(self) -> pulumi.Output[Optional['outputs.ClusterServiceAccountIssuerDiscovery']]:
        """
        - service_account_issuer_discovery_config - ServiceAccountIssuerDiscovery configures the OIDC Issuer for ServiceAccounts.
        """
        return pulumi.get(self, "service_account_issuer_discovery")

    @property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> pulumi.Output[Optional[str]]:
        """
        - String - ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services.
        """
        return pulumi.get(self, "service_cluster_ip_range")

    @property
    @pulumi.getter(name="snapshotController")
    def snapshot_controller(self) -> pulumi.Output[Optional['outputs.ClusterSnapshotController']]:
        """
        - snapshot_controller_config - SnapshotController defines the CSI Snapshot Controller configuration.
        """
        return pulumi.get(self, "snapshot_controller")

    @property
    @pulumi.getter(name="sshAccesses")
    def ssh_accesses(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        - List(String) - SSHAccess is a list of the CIDRs that can access SSH.
        """
        return pulumi.get(self, "ssh_accesses")

    @property
    @pulumi.getter(name="sshKeyName")
    def ssh_key_name(self) -> pulumi.Output[Optional[str]]:
        """
        - String - SSHKeyName specifies a preexisting SSH key to use.
        """
        return pulumi.get(self, "ssh_key_name")

    @property
    @pulumi.getter
    def subnets(self) -> pulumi.Output[Sequence['outputs.ClusterSubnet']]:
        """
        - List(cluster_subnet_spec) - Configuration of subnets we are targeting.
        """
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter(name="sysctlParameters")
    def sysctl_parameters(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        - List(String) - SysctlParameters will configure kernel parameters using sysctl(8). When<br />specified, each parameter must follow the form variable=value, the way<br />it would appear in sysctl.conf.
        """
        return pulumi.get(self, "sysctl_parameters")

    @property
    @pulumi.getter(name="tagSubnets")
    def tag_subnets(self) -> pulumi.Output[Optional['outputs.ClusterTagSubnets']]:
        """
        - Bool(Nullable) - TagSubnets controls if tags are added to subnets to enable use by load balancers (AWS only). Default: true.
        """
        return pulumi.get(self, "tag_subnets")

    @property
    @pulumi.getter
    def topology(self) -> pulumi.Output['outputs.ClusterTopology']:
        """
        - topology_spec - Topology defines the type of network topology to use on the cluster - default public<br />This is heavily weighted towards AWS for the time being, but should also be agnostic enough<br />to port out to GCE later if needed.
        """
        return pulumi.get(self, "topology")

    @property
    @pulumi.getter(name="updatePolicy")
    def update_policy(self) -> pulumi.Output[Optional[str]]:
        """
        - String - UpdatePolicy determines the policy for applying upgrades automatically.<br />Valid values:<br />  'automatic' (default): apply updates automatically (apply OS security upgrades, avoiding rebooting when possible)<br />  'external': do not apply updates automatically; they are applied manually or by an external system.
        """
        return pulumi.get(self, "update_policy")

    @property
    @pulumi.getter(name="useHostCertificates")
    def use_host_certificates(self) -> pulumi.Output[Optional[bool]]:
        """
        - Bool - UseHostCertificates will mount /etc/ssl/certs to inside needed containers.<br />This is needed if some APIs do have self-signed certs.
        """
        return pulumi.get(self, "use_host_certificates")

    @property
    @pulumi.getter(name="warmPool")
    def warm_pool(self) -> pulumi.Output[Optional['outputs.ClusterWarmPool']]:
        """
        - warm_pool_spec - WarmPool defines the default warm pool settings for instance groups (AWS only).
        """
        return pulumi.get(self, "warm_pool")

